/*
 * SPDX-FileCopyrightText: Copyright Corsinvest Srl
 * SPDX-License-Identifier: GPL-3.0-only
 */
package it.corsinvest.proxmoxve.api;

import java.util.HashMap;
import java.util.Map;
import org.json.JSONException;

/**
 * Proxmox VE Client
 */
public class PveClient extends PveClientBase {

    private final PveClient client;

    public PveClient(String hostname, int port) {
        super(hostname, port);
        client = this;
    }

    private PVECluster cluster;

    public PVECluster getCluster() {
        return cluster == null ? (cluster = new PVECluster(client)) : cluster;
    }
    private PVENodes nodes;

    public PVENodes getNodes() {
        return nodes == null ? (nodes = new PVENodes(client)) : nodes;
    }
    private PVEStorage storage;

    public PVEStorage getStorage() {
        return storage == null ? (storage = new PVEStorage(client)) : storage;
    }
    private PVEAccess access;

    public PVEAccess getAccess() {
        return access == null ? (access = new PVEAccess(client)) : access;
    }
    private PVEPools pools;

    public PVEPools getPools() {
        return pools == null ? (pools = new PVEPools(client)) : pools;
    }
    private PVEVersion version;

    public PVEVersion getVersion() {
        return version == null ? (version = new PVEVersion(client)) : version;
    }

    public class PVECluster {

        private final PveClient client;

        protected PVECluster(PveClient client) {
            this.client = client;

        }

        private PVEReplication replication;

        public PVEReplication getReplication() {
            return replication == null ? (replication = new PVEReplication(client)) : replication;
        }
        private PVEMetrics metrics;

        public PVEMetrics getMetrics() {
            return metrics == null ? (metrics = new PVEMetrics(client)) : metrics;
        }
        private PVENotifications notifications;

        public PVENotifications getNotifications() {
            return notifications == null ? (notifications = new PVENotifications(client)) : notifications;
        }
        private PVEConfig config;

        public PVEConfig getConfig() {
            return config == null ? (config = new PVEConfig(client)) : config;
        }
        private PVEFirewall firewall;

        public PVEFirewall getFirewall() {
            return firewall == null ? (firewall = new PVEFirewall(client)) : firewall;
        }
        private PVEBackup backup;

        public PVEBackup getBackup() {
            return backup == null ? (backup = new PVEBackup(client)) : backup;
        }
        private PVEBackupInfo backupInfo;

        public PVEBackupInfo getBackupInfo() {
            return backupInfo == null ? (backupInfo = new PVEBackupInfo(client)) : backupInfo;
        }
        private PVEHa ha;

        public PVEHa getHa() {
            return ha == null ? (ha = new PVEHa(client)) : ha;
        }
        private PVEAcme acme;

        public PVEAcme getAcme() {
            return acme == null ? (acme = new PVEAcme(client)) : acme;
        }
        private PVECeph ceph;

        public PVECeph getCeph() {
            return ceph == null ? (ceph = new PVECeph(client)) : ceph;
        }
        private PVEJobs jobs;

        public PVEJobs getJobs() {
            return jobs == null ? (jobs = new PVEJobs(client)) : jobs;
        }
        private PVEMapping mapping;

        public PVEMapping getMapping() {
            return mapping == null ? (mapping = new PVEMapping(client)) : mapping;
        }
        private PVESdn sdn;

        public PVESdn getSdn() {
            return sdn == null ? (sdn = new PVESdn(client)) : sdn;
        }
        private PVELog log;

        public PVELog getLog() {
            return log == null ? (log = new PVELog(client)) : log;
        }
        private PVEResources resources;

        public PVEResources getResources() {
            return resources == null ? (resources = new PVEResources(client)) : resources;
        }
        private PVETasks tasks;

        public PVETasks getTasks() {
            return tasks == null ? (tasks = new PVETasks(client)) : tasks;
        }
        private PVEOptions options;

        public PVEOptions getOptions() {
            return options == null ? (options = new PVEOptions(client)) : options;
        }
        private PVEStatus status;

        public PVEStatus getStatus() {
            return status == null ? (status = new PVEStatus(client)) : status;
        }
        private PVENextid nextid;

        public PVENextid getNextid() {
            return nextid == null ? (nextid = new PVENextid(client)) : nextid;
        }

        public class PVEReplication {

            private final PveClient client;

            protected PVEReplication(PveClient client) {
                this.client = client;

            }

            public PVEIdItem get(Object id) {
                return new PVEIdItem(client, id);
            }

            public class PVEIdItem {

                private final PveClient client;
                private final Object id;

                protected PVEIdItem(PveClient client, Object id) {
                    this.client = client;
                    this.id = id;
                }

                /**
                 * Mark replication job for removal.
                 *
                 * @param force Will remove the jobconfig entry, but will not
                 * cleanup.
                 * @param keep Keep replicated data at target (do not remove).
                 * @return Result
                 * @throws JSONException
                 */
                public Result delete(Boolean force, Boolean keep) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("force", force);
                    parameters.put("keep", keep);
                    return client.delete("/cluster/replication/" + this.id + "", parameters);
                }

                /**
                 * Mark replication job for removal.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result delete() throws JSONException {
                    return client.delete("/cluster/replication/" + this.id + "", null);
                }

                /**
                 * Read replication job configuration.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result read() throws JSONException {
                    return client.get("/cluster/replication/" + this.id + "", null);
                }

                /**
                 * Update replication job configuration.
                 *
                 * @param comment Description.
                 * @param delete A list of settings you want to delete.
                 * @param digest Prevent changes if current configuration file
                 * has a different digest. This can be used to prevent
                 * concurrent modifications.
                 * @param disable Flag to disable/deactivate the entry.
                 * @param rate Rate limit in mbps (megabytes per second) as
                 * floating point number.
                 * @param remove_job Mark the replication job for removal. The
                 * job will remove all local replication snapshots. When set to
                 * 'full', it also tries to remove replicated volumes on the
                 * target. The job then removes itself from the configuration
                 * file. Enum: local,full
                 * @param schedule Storage replication schedule. The format is a
                 * subset of `systemd` calendar events.
                 * @param source For internal use, to detect if the guest was
                 * stolen.
                 * @return Result
                 * @throws JSONException
                 */

                public Result update(String comment, String delete, String digest, Boolean disable, Float rate, String remove_job, String schedule, String source) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("comment", comment);
                    parameters.put("delete", delete);
                    parameters.put("digest", digest);
                    parameters.put("disable", disable);
                    parameters.put("rate", rate);
                    parameters.put("remove_job", remove_job);
                    parameters.put("schedule", schedule);
                    parameters.put("source", source);
                    return client.set("/cluster/replication/" + this.id + "", parameters);
                }

                /**
                 * Update replication job configuration.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result update() throws JSONException {
                    return client.set("/cluster/replication/" + this.id + "", null);
                }

            }

            /**
             * List replication jobs.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/replication", null);
            }

            /**
             * Create a new replication job
             *
             * @param id Replication Job ID. The ID is composed of a Guest ID
             * and a job number, separated by a hyphen, i.e.
             * '&amp;lt;GUEST&amp;gt;-&amp;lt;JOBNUM&amp;gt;'.
             * @param target Target node.
             * @param type Section type. Enum: local
             * @param comment Description.
             * @param disable Flag to disable/deactivate the entry.
             * @param rate Rate limit in mbps (megabytes per second) as floating
             * point number.
             * @param remove_job Mark the replication job for removal. The job
             * will remove all local replication snapshots. When set to 'full',
             * it also tries to remove replicated volumes on the target. The job
             * then removes itself from the configuration file. Enum: local,full
             * @param schedule Storage replication schedule. The format is a
             * subset of `systemd` calendar events.
             * @param source For internal use, to detect if the guest was
             * stolen.
             * @return Result
             * @throws JSONException
             */

            public Result create(String id, String target, String type, String comment, Boolean disable, Float rate, String remove_job, String schedule, String source) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("id", id);
                parameters.put("target", target);
                parameters.put("type", type);
                parameters.put("comment", comment);
                parameters.put("disable", disable);
                parameters.put("rate", rate);
                parameters.put("remove_job", remove_job);
                parameters.put("schedule", schedule);
                parameters.put("source", source);
                return client.create("/cluster/replication", parameters);
            }

            /**
             * Create a new replication job
             *
             * @param id Replication Job ID. The ID is composed of a Guest ID
             * and a job number, separated by a hyphen, i.e.
             * '&amp;lt;GUEST&amp;gt;-&amp;lt;JOBNUM&amp;gt;'.
             * @param target Target node.
             * @param type Section type. Enum: local
             * @return Result
             * @throws JSONException
             */

            public Result create(String id, String target, String type) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("id", id);
                parameters.put("target", target);
                parameters.put("type", type);
                return client.create("/cluster/replication", parameters);
            }

        }

        public class PVEMetrics {

            private final PveClient client;

            protected PVEMetrics(PveClient client) {
                this.client = client;

            }

            private PVEServer server;

            public PVEServer getServer() {
                return server == null ? (server = new PVEServer(client)) : server;
            }

            public class PVEServer {

                private final PveClient client;

                protected PVEServer(PveClient client) {
                    this.client = client;

                }

                public PVEIdItem get(Object id) {
                    return new PVEIdItem(client, id);
                }

                public class PVEIdItem {

                    private final PveClient client;
                    private final Object id;

                    protected PVEIdItem(PveClient client, Object id) {
                        this.client = client;
                        this.id = id;
                    }

                    /**
                     * Remove Metric server.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result delete() throws JSONException {
                        return client.delete("/cluster/metrics/server/" + this.id + "", null);
                    }

                    /**
                     * Read metric server configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result read() throws JSONException {
                        return client.get("/cluster/metrics/server/" + this.id + "", null);
                    }

                    /**
                     * Create a new external metric server config
                     *
                     * @param port server network port
                     * @param server server dns name or IP address
                     * @param type Plugin type. Enum: graphite,influxdb
                     * @param api_path_prefix An API path prefix inserted
                     * between '&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/' and
                     * '/api2/'. Can be useful if the InfluxDB service runs
                     * behind a reverse proxy.
                     * @param bucket The InfluxDB bucket/db. Only necessary when
                     * using the http v2 api.
                     * @param disable Flag to disable the plugin.
                     * @param influxdbproto Enum: udp,http,https
                     * @param max_body_size InfluxDB max-body-size in bytes.
                     * Requests are batched up to this size.
                     * @param mtu MTU for metrics transmission over UDP
                     * @param organization The InfluxDB organization. Only
                     * necessary when using the http v2 api. Has no meaning when
                     * using v2 compatibility api.
                     * @param path root graphite path (ex:
                     * proxmox.mycluster.mykey)
                     * @param proto Protocol to send graphite data. TCP or UDP
                     * (default) Enum: udp,tcp
                     * @param timeout graphite TCP socket timeout (default=1)
                     * @param token The InfluxDB access token. Only necessary
                     * when using the http v2 api. If the v2 compatibility api
                     * is used, use 'user:password' instead.
                     * @param verify_certificate Set to 0 to disable certificate
                     * verification for https endpoints.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result create(int port, String server, String type, String api_path_prefix, String bucket, Boolean disable, String influxdbproto, Integer max_body_size, Integer mtu, String organization, String path, String proto, Integer timeout, String token, Boolean verify_certificate) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("port", port);
                        parameters.put("server", server);
                        parameters.put("type", type);
                        parameters.put("api-path-prefix", api_path_prefix);
                        parameters.put("bucket", bucket);
                        parameters.put("disable", disable);
                        parameters.put("influxdbproto", influxdbproto);
                        parameters.put("max-body-size", max_body_size);
                        parameters.put("mtu", mtu);
                        parameters.put("organization", organization);
                        parameters.put("path", path);
                        parameters.put("proto", proto);
                        parameters.put("timeout", timeout);
                        parameters.put("token", token);
                        parameters.put("verify-certificate", verify_certificate);
                        return client.create("/cluster/metrics/server/" + this.id + "", parameters);
                    }

                    /**
                     * Create a new external metric server config
                     *
                     * @param port server network port
                     * @param server server dns name or IP address
                     * @param type Plugin type. Enum: graphite,influxdb
                     * @return Result
                     * @throws JSONException
                     */

                    public Result create(int port, String server, String type) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("port", port);
                        parameters.put("server", server);
                        parameters.put("type", type);
                        return client.create("/cluster/metrics/server/" + this.id + "", parameters);
                    }

                    /**
                     * Update metric server configuration.
                     *
                     * @param port server network port
                     * @param server server dns name or IP address
                     * @param api_path_prefix An API path prefix inserted
                     * between '&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/' and
                     * '/api2/'. Can be useful if the InfluxDB service runs
                     * behind a reverse proxy.
                     * @param bucket The InfluxDB bucket/db. Only necessary when
                     * using the http v2 api.
                     * @param delete A list of settings you want to delete.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param disable Flag to disable the plugin.
                     * @param influxdbproto Enum: udp,http,https
                     * @param max_body_size InfluxDB max-body-size in bytes.
                     * Requests are batched up to this size.
                     * @param mtu MTU for metrics transmission over UDP
                     * @param organization The InfluxDB organization. Only
                     * necessary when using the http v2 api. Has no meaning when
                     * using v2 compatibility api.
                     * @param path root graphite path (ex:
                     * proxmox.mycluster.mykey)
                     * @param proto Protocol to send graphite data. TCP or UDP
                     * (default) Enum: udp,tcp
                     * @param timeout graphite TCP socket timeout (default=1)
                     * @param token The InfluxDB access token. Only necessary
                     * when using the http v2 api. If the v2 compatibility api
                     * is used, use 'user:password' instead.
                     * @param verify_certificate Set to 0 to disable certificate
                     * verification for https endpoints.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(int port, String server, String api_path_prefix, String bucket, String delete, String digest, Boolean disable, String influxdbproto, Integer max_body_size, Integer mtu, String organization, String path, String proto, Integer timeout, String token, Boolean verify_certificate) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("port", port);
                        parameters.put("server", server);
                        parameters.put("api-path-prefix", api_path_prefix);
                        parameters.put("bucket", bucket);
                        parameters.put("delete", delete);
                        parameters.put("digest", digest);
                        parameters.put("disable", disable);
                        parameters.put("influxdbproto", influxdbproto);
                        parameters.put("max-body-size", max_body_size);
                        parameters.put("mtu", mtu);
                        parameters.put("organization", organization);
                        parameters.put("path", path);
                        parameters.put("proto", proto);
                        parameters.put("timeout", timeout);
                        parameters.put("token", token);
                        parameters.put("verify-certificate", verify_certificate);
                        return client.set("/cluster/metrics/server/" + this.id + "", parameters);
                    }

                    /**
                     * Update metric server configuration.
                     *
                     * @param port server network port
                     * @param server server dns name or IP address
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(int port, String server) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("port", port);
                        parameters.put("server", server);
                        return client.set("/cluster/metrics/server/" + this.id + "", parameters);
                    }

                }

                /**
                 * List configured metric servers.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result serverIndex() throws JSONException {
                    return client.get("/cluster/metrics/server", null);
                }

            }

            /**
             * Metrics index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/metrics", null);
            }

        }

        public class PVENotifications {

            private final PveClient client;

            protected PVENotifications(PveClient client) {
                this.client = client;

            }

            private PVEEndpoints endpoints;

            public PVEEndpoints getEndpoints() {
                return endpoints == null ? (endpoints = new PVEEndpoints(client)) : endpoints;
            }
            private PVETargets targets;

            public PVETargets getTargets() {
                return targets == null ? (targets = new PVETargets(client)) : targets;
            }
            private PVEMatchers matchers;

            public PVEMatchers getMatchers() {
                return matchers == null ? (matchers = new PVEMatchers(client)) : matchers;
            }

            public class PVEEndpoints {

                private final PveClient client;

                protected PVEEndpoints(PveClient client) {
                    this.client = client;

                }

                private PVESendmail sendmail;

                public PVESendmail getSendmail() {
                    return sendmail == null ? (sendmail = new PVESendmail(client)) : sendmail;
                }
                private PVEGotify gotify;

                public PVEGotify getGotify() {
                    return gotify == null ? (gotify = new PVEGotify(client)) : gotify;
                }
                private PVESmtp smtp;

                public PVESmtp getSmtp() {
                    return smtp == null ? (smtp = new PVESmtp(client)) : smtp;
                }

                public class PVESendmail {

                    private final PveClient client;

                    protected PVESendmail(PveClient client) {
                        this.client = client;

                    }

                    public PVENameItem get(Object name) {
                        return new PVENameItem(client, name);
                    }

                    public class PVENameItem {

                        private final PveClient client;
                        private final Object name;

                        protected PVENameItem(PveClient client, Object name) {
                            this.client = client;
                            this.name = name;
                        }

                        /**
                         * Remove sendmail endpoint
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result deleteSendmailEndpoint() throws JSONException {
                            return client.delete("/cluster/notifications/endpoints/sendmail/" + this.name + "", null);
                        }

                        /**
                         * Return a specific sendmail endpoint
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result getSendmailEndpoint() throws JSONException {
                            return client.get("/cluster/notifications/endpoints/sendmail/" + this.name + "", null);
                        }

                        /**
                         * Update existing sendmail endpoint
                         *
                         * @param author Author of the mail
                         * @param comment Comment
                         * @param delete A list of settings you want to delete.
                         * @param digest Prevent changes if current
                         * configuration file has a different digest. This can
                         * be used to prevent concurrent modifications.
                         * @param disable Disable this target
                         * @param from_address `From` address for the mail
                         * @param mailto List of email recipients
                         * @param mailto_user List of users
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateSendmailEndpoint(String author, String comment, String delete, String digest, Boolean disable, String from_address, String mailto, String mailto_user) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("author", author);
                            parameters.put("comment", comment);
                            parameters.put("delete", delete);
                            parameters.put("digest", digest);
                            parameters.put("disable", disable);
                            parameters.put("from-address", from_address);
                            parameters.put("mailto", mailto);
                            parameters.put("mailto-user", mailto_user);
                            return client.set("/cluster/notifications/endpoints/sendmail/" + this.name + "", parameters);
                        }

                        /**
                         * Update existing sendmail endpoint
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateSendmailEndpoint() throws JSONException {
                            return client.set("/cluster/notifications/endpoints/sendmail/" + this.name + "", null);
                        }

                    }

                    /**
                     * Returns a list of all sendmail endpoints
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result getSendmailEndpoints() throws JSONException {
                        return client.get("/cluster/notifications/endpoints/sendmail", null);
                    }

                    /**
                     * Create a new sendmail endpoint
                     *
                     * @param name The name of the endpoint.
                     * @param author Author of the mail
                     * @param comment Comment
                     * @param disable Disable this target
                     * @param from_address `From` address for the mail
                     * @param mailto List of email recipients
                     * @param mailto_user List of users
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createSendmailEndpoint(String name, String author, String comment, Boolean disable, String from_address, String mailto, String mailto_user) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("name", name);
                        parameters.put("author", author);
                        parameters.put("comment", comment);
                        parameters.put("disable", disable);
                        parameters.put("from-address", from_address);
                        parameters.put("mailto", mailto);
                        parameters.put("mailto-user", mailto_user);
                        return client.create("/cluster/notifications/endpoints/sendmail", parameters);
                    }

                    /**
                     * Create a new sendmail endpoint
                     *
                     * @param name The name of the endpoint.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createSendmailEndpoint(String name) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("name", name);
                        return client.create("/cluster/notifications/endpoints/sendmail", parameters);
                    }

                }

                public class PVEGotify {

                    private final PveClient client;

                    protected PVEGotify(PveClient client) {
                        this.client = client;

                    }

                    public PVENameItem get(Object name) {
                        return new PVENameItem(client, name);
                    }

                    public class PVENameItem {

                        private final PveClient client;
                        private final Object name;

                        protected PVENameItem(PveClient client, Object name) {
                            this.client = client;
                            this.name = name;
                        }

                        /**
                         * Remove gotify endpoint
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result deleteGotifyEndpoint() throws JSONException {
                            return client.delete("/cluster/notifications/endpoints/gotify/" + this.name + "", null);
                        }

                        /**
                         * Return a specific gotify endpoint
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result getGotifyEndpoint() throws JSONException {
                            return client.get("/cluster/notifications/endpoints/gotify/" + this.name + "", null);
                        }

                        /**
                         * Update existing gotify endpoint
                         *
                         * @param comment Comment
                         * @param delete A list of settings you want to delete.
                         * @param digest Prevent changes if current
                         * configuration file has a different digest. This can
                         * be used to prevent concurrent modifications.
                         * @param disable Disable this target
                         * @param server Server URL
                         * @param token Secret token
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateGotifyEndpoint(String comment, String delete, String digest, Boolean disable, String server, String token) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("comment", comment);
                            parameters.put("delete", delete);
                            parameters.put("digest", digest);
                            parameters.put("disable", disable);
                            parameters.put("server", server);
                            parameters.put("token", token);
                            return client.set("/cluster/notifications/endpoints/gotify/" + this.name + "", parameters);
                        }

                        /**
                         * Update existing gotify endpoint
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateGotifyEndpoint() throws JSONException {
                            return client.set("/cluster/notifications/endpoints/gotify/" + this.name + "", null);
                        }

                    }

                    /**
                     * Returns a list of all gotify endpoints
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result getGotifyEndpoints() throws JSONException {
                        return client.get("/cluster/notifications/endpoints/gotify", null);
                    }

                    /**
                     * Create a new gotify endpoint
                     *
                     * @param name The name of the endpoint.
                     * @param server Server URL
                     * @param token Secret token
                     * @param comment Comment
                     * @param disable Disable this target
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createGotifyEndpoint(String name, String server, String token, String comment, Boolean disable) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("name", name);
                        parameters.put("server", server);
                        parameters.put("token", token);
                        parameters.put("comment", comment);
                        parameters.put("disable", disable);
                        return client.create("/cluster/notifications/endpoints/gotify", parameters);
                    }

                    /**
                     * Create a new gotify endpoint
                     *
                     * @param name The name of the endpoint.
                     * @param server Server URL
                     * @param token Secret token
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createGotifyEndpoint(String name, String server, String token) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("name", name);
                        parameters.put("server", server);
                        parameters.put("token", token);
                        return client.create("/cluster/notifications/endpoints/gotify", parameters);
                    }

                }

                public class PVESmtp {

                    private final PveClient client;

                    protected PVESmtp(PveClient client) {
                        this.client = client;

                    }

                    public PVENameItem get(Object name) {
                        return new PVENameItem(client, name);
                    }

                    public class PVENameItem {

                        private final PveClient client;
                        private final Object name;

                        protected PVENameItem(PveClient client, Object name) {
                            this.client = client;
                            this.name = name;
                        }

                        /**
                         * Remove smtp endpoint
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result deleteSmtpEndpoint() throws JSONException {
                            return client.delete("/cluster/notifications/endpoints/smtp/" + this.name + "", null);
                        }

                        /**
                         * Return a specific smtp endpoint
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result getSmtpEndpoint() throws JSONException {
                            return client.get("/cluster/notifications/endpoints/smtp/" + this.name + "", null);
                        }

                        /**
                         * Update existing smtp endpoint
                         *
                         * @param author Author of the mail. Defaults to
                         * 'Proxmox VE'.
                         * @param comment Comment
                         * @param delete A list of settings you want to delete.
                         * @param digest Prevent changes if current
                         * configuration file has a different digest. This can
                         * be used to prevent concurrent modifications.
                         * @param disable Disable this target
                         * @param from_address `From` address for the mail
                         * @param mailto List of email recipients
                         * @param mailto_user List of users
                         * @param mode Determine which encryption method shall
                         * be used for the connection. Enum:
                         * insecure,starttls,tls
                         * @param password Password for SMTP authentication
                         * @param port The port to be used. Defaults to 465 for
                         * TLS based connections, 587 for STARTTLS based
                         * connections and port 25 for insecure plain-text
                         * connections.
                         * @param server The address of the SMTP server.
                         * @param username Username for SMTP authentication
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateSmtpEndpoint(String author, String comment, String delete, String digest, Boolean disable, String from_address, String mailto, String mailto_user, String mode, String password, Integer port, String server, String username) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("author", author);
                            parameters.put("comment", comment);
                            parameters.put("delete", delete);
                            parameters.put("digest", digest);
                            parameters.put("disable", disable);
                            parameters.put("from-address", from_address);
                            parameters.put("mailto", mailto);
                            parameters.put("mailto-user", mailto_user);
                            parameters.put("mode", mode);
                            parameters.put("password", password);
                            parameters.put("port", port);
                            parameters.put("server", server);
                            parameters.put("username", username);
                            return client.set("/cluster/notifications/endpoints/smtp/" + this.name + "", parameters);
                        }

                        /**
                         * Update existing smtp endpoint
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateSmtpEndpoint() throws JSONException {
                            return client.set("/cluster/notifications/endpoints/smtp/" + this.name + "", null);
                        }

                    }

                    /**
                     * Returns a list of all smtp endpoints
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result getSmtpEndpoints() throws JSONException {
                        return client.get("/cluster/notifications/endpoints/smtp", null);
                    }

                    /**
                     * Create a new smtp endpoint
                     *
                     * @param from_address `From` address for the mail
                     * @param name The name of the endpoint.
                     * @param server The address of the SMTP server.
                     * @param author Author of the mail. Defaults to 'Proxmox
                     * VE'.
                     * @param comment Comment
                     * @param disable Disable this target
                     * @param mailto List of email recipients
                     * @param mailto_user List of users
                     * @param mode Determine which encryption method shall be
                     * used for the connection. Enum: insecure,starttls,tls
                     * @param password Password for SMTP authentication
                     * @param port The port to be used. Defaults to 465 for TLS
                     * based connections, 587 for STARTTLS based connections and
                     * port 25 for insecure plain-text connections.
                     * @param username Username for SMTP authentication
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createSmtpEndpoint(String from_address, String name, String server, String author, String comment, Boolean disable, String mailto, String mailto_user, String mode, String password, Integer port, String username) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("from-address", from_address);
                        parameters.put("name", name);
                        parameters.put("server", server);
                        parameters.put("author", author);
                        parameters.put("comment", comment);
                        parameters.put("disable", disable);
                        parameters.put("mailto", mailto);
                        parameters.put("mailto-user", mailto_user);
                        parameters.put("mode", mode);
                        parameters.put("password", password);
                        parameters.put("port", port);
                        parameters.put("username", username);
                        return client.create("/cluster/notifications/endpoints/smtp", parameters);
                    }

                    /**
                     * Create a new smtp endpoint
                     *
                     * @param from_address `From` address for the mail
                     * @param name The name of the endpoint.
                     * @param server The address of the SMTP server.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createSmtpEndpoint(String from_address, String name, String server) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("from-address", from_address);
                        parameters.put("name", name);
                        parameters.put("server", server);
                        return client.create("/cluster/notifications/endpoints/smtp", parameters);
                    }

                }

                /**
                 * Index for all available endpoint types.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result endpointsIndex() throws JSONException {
                    return client.get("/cluster/notifications/endpoints", null);
                }

            }

            public class PVETargets {

                private final PveClient client;

                protected PVETargets(PveClient client) {
                    this.client = client;

                }

                public PVENameItem get(Object name) {
                    return new PVENameItem(client, name);
                }

                public class PVENameItem {

                    private final PveClient client;
                    private final Object name;

                    protected PVENameItem(PveClient client, Object name) {
                        this.client = client;
                        this.name = name;
                    }

                    private PVETest test;

                    public PVETest getTest() {
                        return test == null ? (test = new PVETest(client, this.name)) : test;
                    }

                    public class PVETest {

                        private final PveClient client;
                        private final Object name;

                        protected PVETest(PveClient client, Object name) {
                            this.client = client;
                            this.name = name;
                        }

                        /**
                         * Send a test notification to a provided target.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result testTarget() throws JSONException {
                            return client.create("/cluster/notifications/targets/" + this.name + "/test", null);
                        }

                    }

                }

                /**
                 * Returns a list of all entities that can be used as
                 * notification targets.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result getAllTargets() throws JSONException {
                    return client.get("/cluster/notifications/targets", null);
                }

            }

            public class PVEMatchers {

                private final PveClient client;

                protected PVEMatchers(PveClient client) {
                    this.client = client;

                }

                public PVENameItem get(Object name) {
                    return new PVENameItem(client, name);
                }

                public class PVENameItem {

                    private final PveClient client;
                    private final Object name;

                    protected PVENameItem(PveClient client, Object name) {
                        this.client = client;
                        this.name = name;
                    }

                    /**
                     * Remove matcher
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result deleteMatcher() throws JSONException {
                        return client.delete("/cluster/notifications/matchers/" + this.name + "", null);
                    }

                    /**
                     * Return a specific matcher
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result getMatcher() throws JSONException {
                        return client.get("/cluster/notifications/matchers/" + this.name + "", null);
                    }

                    /**
                     * Update existing matcher
                     *
                     * @param comment Comment
                     * @param delete A list of settings you want to delete.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param disable Disable this matcher
                     * @param invert_match Invert match of the whole matcher
                     * @param match_calendar Match notification timestamp
                     * @param match_field Metadata fields to match (regex or
                     * exact match). Must be in the form
                     * (regex|exact):&amp;lt;field&amp;gt;=&amp;lt;value&amp;gt;
                     * @param match_severity Notification severities to match
                     * @param mode Choose between 'all' and 'any' for when
                     * multiple properties are specified Enum: all,any
                     * @param target Targets to notify on match
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateMatcher(String comment, String delete, String digest, Boolean disable, Boolean invert_match, String match_calendar, String match_field, String match_severity, String mode, String target) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("comment", comment);
                        parameters.put("delete", delete);
                        parameters.put("digest", digest);
                        parameters.put("disable", disable);
                        parameters.put("invert-match", invert_match);
                        parameters.put("match-calendar", match_calendar);
                        parameters.put("match-field", match_field);
                        parameters.put("match-severity", match_severity);
                        parameters.put("mode", mode);
                        parameters.put("target", target);
                        return client.set("/cluster/notifications/matchers/" + this.name + "", parameters);
                    }

                    /**
                     * Update existing matcher
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateMatcher() throws JSONException {
                        return client.set("/cluster/notifications/matchers/" + this.name + "", null);
                    }

                }

                /**
                 * Returns a list of all matchers
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result getMatchers() throws JSONException {
                    return client.get("/cluster/notifications/matchers", null);
                }

                /**
                 * Create a new matcher
                 *
                 * @param name Name of the matcher.
                 * @param comment Comment
                 * @param disable Disable this matcher
                 * @param invert_match Invert match of the whole matcher
                 * @param match_calendar Match notification timestamp
                 * @param match_field Metadata fields to match (regex or exact
                 * match). Must be in the form
                 * (regex|exact):&amp;lt;field&amp;gt;=&amp;lt;value&amp;gt;
                 * @param match_severity Notification severities to match
                 * @param mode Choose between 'all' and 'any' for when multiple
                 * properties are specified Enum: all,any
                 * @param target Targets to notify on match
                 * @return Result
                 * @throws JSONException
                 */

                public Result createMatcher(String name, String comment, Boolean disable, Boolean invert_match, String match_calendar, String match_field, String match_severity, String mode, String target) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("name", name);
                    parameters.put("comment", comment);
                    parameters.put("disable", disable);
                    parameters.put("invert-match", invert_match);
                    parameters.put("match-calendar", match_calendar);
                    parameters.put("match-field", match_field);
                    parameters.put("match-severity", match_severity);
                    parameters.put("mode", mode);
                    parameters.put("target", target);
                    return client.create("/cluster/notifications/matchers", parameters);
                }

                /**
                 * Create a new matcher
                 *
                 * @param name Name of the matcher.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createMatcher(String name) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("name", name);
                    return client.create("/cluster/notifications/matchers", parameters);
                }

            }

            /**
             * Index for notification-related API endpoints.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/notifications", null);
            }

        }

        public class PVEConfig {

            private final PveClient client;

            protected PVEConfig(PveClient client) {
                this.client = client;

            }

            private PVEApiversion apiversion;

            public PVEApiversion getApiversion() {
                return apiversion == null ? (apiversion = new PVEApiversion(client)) : apiversion;
            }
            private PVENodes nodes;

            public PVENodes getNodes() {
                return nodes == null ? (nodes = new PVENodes(client)) : nodes;
            }
            private PVEJoin join;

            public PVEJoin getJoin() {
                return join == null ? (join = new PVEJoin(client)) : join;
            }
            private PVETotem totem;

            public PVETotem getTotem() {
                return totem == null ? (totem = new PVETotem(client)) : totem;
            }
            private PVEQdevice qdevice;

            public PVEQdevice getQdevice() {
                return qdevice == null ? (qdevice = new PVEQdevice(client)) : qdevice;
            }

            public class PVEApiversion {

                private final PveClient client;

                protected PVEApiversion(PveClient client) {
                    this.client = client;

                }

                /**
                 * Return the version of the cluster join API available on this
                 * node.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result joinApiVersion() throws JSONException {
                    return client.get("/cluster/config/apiversion", null);
                }

            }

            public class PVENodes {

                private final PveClient client;

                protected PVENodes(PveClient client) {
                    this.client = client;

                }

                public PVENodeItem get(Object node) {
                    return new PVENodeItem(client, node);
                }

                public class PVENodeItem {

                    private final PveClient client;
                    private final Object node;

                    protected PVENodeItem(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Removes a node from the cluster configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result delnode() throws JSONException {
                        return client.delete("/cluster/config/nodes/" + this.node + "", null);
                    }

                    /**
                     * Adds a node to the cluster configuration. This call is
                     * for internal use.
                     *
                     * @param apiversion The JOIN_API_VERSION of the new node.
                     * @param force Do not throw error if node already exists.
                     * @param linkN Address and priority information of a single
                     * corosync link. (up to 8 links supported; link0..link7)
                     * @param new_node_ip IP Address of node to add. Used as
                     * fallback if no links are given.
                     * @param nodeid Node id for this node.
                     * @param votes Number of votes for this node
                     * @return Result
                     * @throws JSONException
                     */

                    public Result addnode(Integer apiversion, Boolean force, Map<Integer, String> linkN, String new_node_ip, Integer nodeid, Integer votes) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("apiversion", apiversion);
                        parameters.put("force", force);
                        parameters.put("new_node_ip", new_node_ip);
                        parameters.put("nodeid", nodeid);
                        parameters.put("votes", votes);
                        addIndexedParameter(parameters, "link", linkN);
                        return client.create("/cluster/config/nodes/" + this.node + "", parameters);
                    }

                    /**
                     * Adds a node to the cluster configuration. This call is
                     * for internal use.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result addnode() throws JSONException {
                        return client.create("/cluster/config/nodes/" + this.node + "", null);
                    }

                }

                /**
                 * Corosync node list.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result nodes() throws JSONException {
                    return client.get("/cluster/config/nodes", null);
                }

            }

            public class PVEJoin {

                private final PveClient client;

                protected PVEJoin(PveClient client) {
                    this.client = client;

                }

                /**
                 * Get information needed to join this cluster over the
                 * connected node.
                 *
                 * @param node The node for which the joinee gets the nodeinfo.
                 * @return Result
                 * @throws JSONException
                 */
                public Result joinInfo(String node) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("node", node);
                    return client.get("/cluster/config/join", parameters);
                }

                /**
                 * Get information needed to join this cluster over the
                 * connected node.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result joinInfo() throws JSONException {
                    return client.get("/cluster/config/join", null);
                }

                /**
                 * Joins this node into an existing cluster. If no links are
                 * given, default to IP resolved by node's hostname on single
                 * link (fallback fails for clusters with multiple links).
                 *
                 * @param fingerprint Certificate SHA 256 fingerprint.
                 * @param hostname Hostname (or IP) of an existing cluster
                 * member.
                 * @param password Superuser (root) password of peer node.
                 * @param force Do not throw error if node already exists.
                 * @param linkN Address and priority information of a single
                 * corosync link. (up to 8 links supported; link0..link7)
                 * @param nodeid Node id for this node.
                 * @param votes Number of votes for this node
                 * @return Result
                 * @throws JSONException
                 */

                public Result join(String fingerprint, String hostname, String password, Boolean force, Map<Integer, String> linkN, Integer nodeid, Integer votes) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("fingerprint", fingerprint);
                    parameters.put("hostname", hostname);
                    parameters.put("password", password);
                    parameters.put("force", force);
                    parameters.put("nodeid", nodeid);
                    parameters.put("votes", votes);
                    addIndexedParameter(parameters, "link", linkN);
                    return client.create("/cluster/config/join", parameters);
                }

                /**
                 * Joins this node into an existing cluster. If no links are
                 * given, default to IP resolved by node's hostname on single
                 * link (fallback fails for clusters with multiple links).
                 *
                 * @param fingerprint Certificate SHA 256 fingerprint.
                 * @param hostname Hostname (or IP) of an existing cluster
                 * member.
                 * @param password Superuser (root) password of peer node.
                 * @return Result
                 * @throws JSONException
                 */

                public Result join(String fingerprint, String hostname, String password) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("fingerprint", fingerprint);
                    parameters.put("hostname", hostname);
                    parameters.put("password", password);
                    return client.create("/cluster/config/join", parameters);
                }

            }

            public class PVETotem {

                private final PveClient client;

                protected PVETotem(PveClient client) {
                    this.client = client;

                }

                /**
                 * Get corosync totem protocol settings.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result totem() throws JSONException {
                    return client.get("/cluster/config/totem", null);
                }

            }

            public class PVEQdevice {

                private final PveClient client;

                protected PVEQdevice(PveClient client) {
                    this.client = client;

                }

                /**
                 * Get QDevice status
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result status() throws JSONException {
                    return client.get("/cluster/config/qdevice", null);
                }

            }

            /**
             * Directory index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/config", null);
            }

            /**
             * Generate new cluster configuration. If no links given, default to
             * local IP address as link0.
             *
             * @param clustername The name of the cluster.
             * @param linkN Address and priority information of a single
             * corosync link. (up to 8 links supported; link0..link7)
             * @param nodeid Node id for this node.
             * @param votes Number of votes for this node.
             * @return Result
             * @throws JSONException
             */

            public Result create(String clustername, Map<Integer, String> linkN, Integer nodeid, Integer votes) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("clustername", clustername);
                parameters.put("nodeid", nodeid);
                parameters.put("votes", votes);
                addIndexedParameter(parameters, "link", linkN);
                return client.create("/cluster/config", parameters);
            }

            /**
             * Generate new cluster configuration. If no links given, default to
             * local IP address as link0.
             *
             * @param clustername The name of the cluster.
             * @return Result
             * @throws JSONException
             */

            public Result create(String clustername) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("clustername", clustername);
                return client.create("/cluster/config", parameters);
            }

        }

        public class PVEFirewall {

            private final PveClient client;

            protected PVEFirewall(PveClient client) {
                this.client = client;

            }

            private PVEGroups groups;

            public PVEGroups getGroups() {
                return groups == null ? (groups = new PVEGroups(client)) : groups;
            }
            private PVERules rules;

            public PVERules getRules() {
                return rules == null ? (rules = new PVERules(client)) : rules;
            }
            private PVEIpset ipset;

            public PVEIpset getIpset() {
                return ipset == null ? (ipset = new PVEIpset(client)) : ipset;
            }
            private PVEAliases aliases;

            public PVEAliases getAliases() {
                return aliases == null ? (aliases = new PVEAliases(client)) : aliases;
            }
            private PVEOptions options;

            public PVEOptions getOptions() {
                return options == null ? (options = new PVEOptions(client)) : options;
            }
            private PVEMacros macros;

            public PVEMacros getMacros() {
                return macros == null ? (macros = new PVEMacros(client)) : macros;
            }
            private PVERefs refs;

            public PVERefs getRefs() {
                return refs == null ? (refs = new PVERefs(client)) : refs;
            }

            public class PVEGroups {

                private final PveClient client;

                protected PVEGroups(PveClient client) {
                    this.client = client;

                }

                public PVEGroupItem get(Object group) {
                    return new PVEGroupItem(client, group);
                }

                public class PVEGroupItem {

                    private final PveClient client;
                    private final Object group;

                    protected PVEGroupItem(PveClient client, Object group) {
                        this.client = client;
                        this.group = group;
                    }

                    public PVEPosItem get(Object pos) {
                        return new PVEPosItem(client, this.group, pos);
                    }

                    public class PVEPosItem {

                        private final PveClient client;
                        private final Object group;
                        private final Object pos;

                        protected PVEPosItem(PveClient client, Object group, Object pos) {
                            this.client = client;
                            this.group = group;
                            this.pos = pos;
                        }

                        /**
                         * Delete rule.
                         *
                         * @param digest Prevent changes if current
                         * configuration file has a different digest. This can
                         * be used to prevent concurrent modifications.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result deleteRule(String digest) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("digest", digest);
                            return client.delete("/cluster/firewall/groups/" + this.group + "/" + this.pos + "", parameters);
                        }

                        /**
                         * Delete rule.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result deleteRule() throws JSONException {
                            return client.delete("/cluster/firewall/groups/" + this.group + "/" + this.pos + "", null);
                        }

                        /**
                         * Get single rule data.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result getRule() throws JSONException {
                            return client.get("/cluster/firewall/groups/" + this.group + "/" + this.pos + "", null);
                        }

                        /**
                         * Modify rule data.
                         *
                         * @param action Rule action ('ACCEPT', 'DROP',
                         * 'REJECT') or security group name.
                         * @param comment Descriptive comment.
                         * @param delete A list of settings you want to delete.
                         * @param dest Restrict packet destination address. This
                         * can refer to a single IP address, an IP set
                         * ('+ipsetname') or an IP alias definition. You can
                         * also specify an address range like
                         * '20.34.101.207-201.3.9.99', or a list of IP addresses
                         * and networks (entries are separated by comma). Please
                         * do not mix IPv4 and IPv6 addresses inside such lists.
                         * @param digest Prevent changes if current
                         * configuration file has a different digest. This can
                         * be used to prevent concurrent modifications.
                         * @param dport Restrict TCP/UDP destination port. You
                         * can use service names or simple numbers (0-65535), as
                         * defined in '/etc/services'. Port ranges can be
                         * specified with '\d+:\d+', for example '80:85', and
                         * you can use comma separated list to match several
                         * ports or ranges.
                         * @param enable Flag to enable/disable a rule.
                         * @param icmp_type Specify icmp-type. Only valid if
                         * proto equals 'icmp' or 'icmpv6'/'ipv6-icmp'.
                         * @param iface Network interface name. You have to use
                         * network configuration key names for VMs and
                         * containers ('net\d+'). Host related rules can use
                         * arbitrary strings.
                         * @param log Log level for firewall rule. Enum:
                         * emerg,alert,crit,err,warning,notice,info,debug,nolog
                         * @param macro Use predefined standard macro.
                         * @param moveto Move rule to new position
                         * &amp;lt;moveto&amp;gt;. Other arguments are ignored.
                         * @param proto IP protocol. You can use protocol names
                         * ('tcp'/'udp') or simple numbers, as defined in
                         * '/etc/protocols'.
                         * @param source Restrict packet source address. This
                         * can refer to a single IP address, an IP set
                         * ('+ipsetname') or an IP alias definition. You can
                         * also specify an address range like
                         * '20.34.101.207-201.3.9.99', or a list of IP addresses
                         * and networks (entries are separated by comma). Please
                         * do not mix IPv4 and IPv6 addresses inside such lists.
                         * @param sport Restrict TCP/UDP source port. You can
                         * use service names or simple numbers (0-65535), as
                         * defined in '/etc/services'. Port ranges can be
                         * specified with '\d+:\d+', for example '80:85', and
                         * you can use comma separated list to match several
                         * ports or ranges.
                         * @param type Rule type. Enum: in,out,group
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateRule(String action, String comment, String delete, String dest, String digest, String dport, Integer enable, String icmp_type, String iface, String log, String macro, Integer moveto, String proto, String source, String sport, String type) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("action", action);
                            parameters.put("comment", comment);
                            parameters.put("delete", delete);
                            parameters.put("dest", dest);
                            parameters.put("digest", digest);
                            parameters.put("dport", dport);
                            parameters.put("enable", enable);
                            parameters.put("icmp-type", icmp_type);
                            parameters.put("iface", iface);
                            parameters.put("log", log);
                            parameters.put("macro", macro);
                            parameters.put("moveto", moveto);
                            parameters.put("proto", proto);
                            parameters.put("source", source);
                            parameters.put("sport", sport);
                            parameters.put("type", type);
                            return client.set("/cluster/firewall/groups/" + this.group + "/" + this.pos + "", parameters);
                        }

                        /**
                         * Modify rule data.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateRule() throws JSONException {
                            return client.set("/cluster/firewall/groups/" + this.group + "/" + this.pos + "", null);
                        }

                    }

                    /**
                     * Delete security group.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result deleteSecurityGroup() throws JSONException {
                        return client.delete("/cluster/firewall/groups/" + this.group + "", null);
                    }

                    /**
                     * List rules.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result getRules() throws JSONException {
                        return client.get("/cluster/firewall/groups/" + this.group + "", null);
                    }

                    /**
                     * Create new rule.
                     *
                     * @param action Rule action ('ACCEPT', 'DROP', 'REJECT') or
                     * security group name.
                     * @param type Rule type. Enum: in,out,group
                     * @param comment Descriptive comment.
                     * @param dest Restrict packet destination address. This can
                     * refer to a single IP address, an IP set ('+ipsetname') or
                     * an IP alias definition. You can also specify an address
                     * range like '20.34.101.207-201.3.9.99', or a list of IP
                     * addresses and networks (entries are separated by comma).
                     * Please do not mix IPv4 and IPv6 addresses inside such
                     * lists.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param dport Restrict TCP/UDP destination port. You can
                     * use service names or simple numbers (0-65535), as defined
                     * in '/etc/services'. Port ranges can be specified with
                     * '\d+:\d+', for example '80:85', and you can use comma
                     * separated list to match several ports or ranges.
                     * @param enable Flag to enable/disable a rule.
                     * @param icmp_type Specify icmp-type. Only valid if proto
                     * equals 'icmp' or 'icmpv6'/'ipv6-icmp'.
                     * @param iface Network interface name. You have to use
                     * network configuration key names for VMs and containers
                     * ('net\d+'). Host related rules can use arbitrary strings.
                     * @param log Log level for firewall rule. Enum:
                     * emerg,alert,crit,err,warning,notice,info,debug,nolog
                     * @param macro Use predefined standard macro.
                     * @param pos Update rule at position &amp;lt;pos&amp;gt;.
                     * @param proto IP protocol. You can use protocol names
                     * ('tcp'/'udp') or simple numbers, as defined in
                     * '/etc/protocols'.
                     * @param source Restrict packet source address. This can
                     * refer to a single IP address, an IP set ('+ipsetname') or
                     * an IP alias definition. You can also specify an address
                     * range like '20.34.101.207-201.3.9.99', or a list of IP
                     * addresses and networks (entries are separated by comma).
                     * Please do not mix IPv4 and IPv6 addresses inside such
                     * lists.
                     * @param sport Restrict TCP/UDP source port. You can use
                     * service names or simple numbers (0-65535), as defined in
                     * '/etc/services'. Port ranges can be specified with
                     * '\d+:\d+', for example '80:85', and you can use comma
                     * separated list to match several ports or ranges.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createRule(String action, String type, String comment, String dest, String digest, String dport, Integer enable, String icmp_type, String iface, String log, String macro, Integer pos, String proto, String source, String sport) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("action", action);
                        parameters.put("type", type);
                        parameters.put("comment", comment);
                        parameters.put("dest", dest);
                        parameters.put("digest", digest);
                        parameters.put("dport", dport);
                        parameters.put("enable", enable);
                        parameters.put("icmp-type", icmp_type);
                        parameters.put("iface", iface);
                        parameters.put("log", log);
                        parameters.put("macro", macro);
                        parameters.put("pos", pos);
                        parameters.put("proto", proto);
                        parameters.put("source", source);
                        parameters.put("sport", sport);
                        return client.create("/cluster/firewall/groups/" + this.group + "", parameters);
                    }

                    /**
                     * Create new rule.
                     *
                     * @param action Rule action ('ACCEPT', 'DROP', 'REJECT') or
                     * security group name.
                     * @param type Rule type. Enum: in,out,group
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createRule(String action, String type) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("action", action);
                        parameters.put("type", type);
                        return client.create("/cluster/firewall/groups/" + this.group + "", parameters);
                    }

                }

                /**
                 * List security groups.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result listSecurityGroups() throws JSONException {
                    return client.get("/cluster/firewall/groups", null);
                }

                /**
                 * Create new security group.
                 *
                 * @param group Security Group name.
                 * @param comment
                 * @param digest Prevent changes if current configuration file
                 * has a different digest. This can be used to prevent
                 * concurrent modifications.
                 * @param rename Rename/update an existing security group. You
                 * can set 'rename' to the same value as 'name' to update the
                 * 'comment' of an existing group.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createSecurityGroup(String group, String comment, String digest, String rename) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("group", group);
                    parameters.put("comment", comment);
                    parameters.put("digest", digest);
                    parameters.put("rename", rename);
                    return client.create("/cluster/firewall/groups", parameters);
                }

                /**
                 * Create new security group.
                 *
                 * @param group Security Group name.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createSecurityGroup(String group) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("group", group);
                    return client.create("/cluster/firewall/groups", parameters);
                }

            }

            public class PVERules {

                private final PveClient client;

                protected PVERules(PveClient client) {
                    this.client = client;

                }

                public PVEPosItem get(Object pos) {
                    return new PVEPosItem(client, pos);
                }

                public class PVEPosItem {

                    private final PveClient client;
                    private final Object pos;

                    protected PVEPosItem(PveClient client, Object pos) {
                        this.client = client;
                        this.pos = pos;
                    }

                    /**
                     * Delete rule.
                     *
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result deleteRule(String digest) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("digest", digest);
                        return client.delete("/cluster/firewall/rules/" + this.pos + "", parameters);
                    }

                    /**
                     * Delete rule.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result deleteRule() throws JSONException {
                        return client.delete("/cluster/firewall/rules/" + this.pos + "", null);
                    }

                    /**
                     * Get single rule data.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result getRule() throws JSONException {
                        return client.get("/cluster/firewall/rules/" + this.pos + "", null);
                    }

                    /**
                     * Modify rule data.
                     *
                     * @param action Rule action ('ACCEPT', 'DROP', 'REJECT') or
                     * security group name.
                     * @param comment Descriptive comment.
                     * @param delete A list of settings you want to delete.
                     * @param dest Restrict packet destination address. This can
                     * refer to a single IP address, an IP set ('+ipsetname') or
                     * an IP alias definition. You can also specify an address
                     * range like '20.34.101.207-201.3.9.99', or a list of IP
                     * addresses and networks (entries are separated by comma).
                     * Please do not mix IPv4 and IPv6 addresses inside such
                     * lists.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param dport Restrict TCP/UDP destination port. You can
                     * use service names or simple numbers (0-65535), as defined
                     * in '/etc/services'. Port ranges can be specified with
                     * '\d+:\d+', for example '80:85', and you can use comma
                     * separated list to match several ports or ranges.
                     * @param enable Flag to enable/disable a rule.
                     * @param icmp_type Specify icmp-type. Only valid if proto
                     * equals 'icmp' or 'icmpv6'/'ipv6-icmp'.
                     * @param iface Network interface name. You have to use
                     * network configuration key names for VMs and containers
                     * ('net\d+'). Host related rules can use arbitrary strings.
                     * @param log Log level for firewall rule. Enum:
                     * emerg,alert,crit,err,warning,notice,info,debug,nolog
                     * @param macro Use predefined standard macro.
                     * @param moveto Move rule to new position
                     * &amp;lt;moveto&amp;gt;. Other arguments are ignored.
                     * @param proto IP protocol. You can use protocol names
                     * ('tcp'/'udp') or simple numbers, as defined in
                     * '/etc/protocols'.
                     * @param source Restrict packet source address. This can
                     * refer to a single IP address, an IP set ('+ipsetname') or
                     * an IP alias definition. You can also specify an address
                     * range like '20.34.101.207-201.3.9.99', or a list of IP
                     * addresses and networks (entries are separated by comma).
                     * Please do not mix IPv4 and IPv6 addresses inside such
                     * lists.
                     * @param sport Restrict TCP/UDP source port. You can use
                     * service names or simple numbers (0-65535), as defined in
                     * '/etc/services'. Port ranges can be specified with
                     * '\d+:\d+', for example '80:85', and you can use comma
                     * separated list to match several ports or ranges.
                     * @param type Rule type. Enum: in,out,group
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateRule(String action, String comment, String delete, String dest, String digest, String dport, Integer enable, String icmp_type, String iface, String log, String macro, Integer moveto, String proto, String source, String sport, String type) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("action", action);
                        parameters.put("comment", comment);
                        parameters.put("delete", delete);
                        parameters.put("dest", dest);
                        parameters.put("digest", digest);
                        parameters.put("dport", dport);
                        parameters.put("enable", enable);
                        parameters.put("icmp-type", icmp_type);
                        parameters.put("iface", iface);
                        parameters.put("log", log);
                        parameters.put("macro", macro);
                        parameters.put("moveto", moveto);
                        parameters.put("proto", proto);
                        parameters.put("source", source);
                        parameters.put("sport", sport);
                        parameters.put("type", type);
                        return client.set("/cluster/firewall/rules/" + this.pos + "", parameters);
                    }

                    /**
                     * Modify rule data.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateRule() throws JSONException {
                        return client.set("/cluster/firewall/rules/" + this.pos + "", null);
                    }

                }

                /**
                 * List rules.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result getRules() throws JSONException {
                    return client.get("/cluster/firewall/rules", null);
                }

                /**
                 * Create new rule.
                 *
                 * @param action Rule action ('ACCEPT', 'DROP', 'REJECT') or
                 * security group name.
                 * @param type Rule type. Enum: in,out,group
                 * @param comment Descriptive comment.
                 * @param dest Restrict packet destination address. This can
                 * refer to a single IP address, an IP set ('+ipsetname') or an
                 * IP alias definition. You can also specify an address range
                 * like '20.34.101.207-201.3.9.99', or a list of IP addresses
                 * and networks (entries are separated by comma). Please do not
                 * mix IPv4 and IPv6 addresses inside such lists.
                 * @param digest Prevent changes if current configuration file
                 * has a different digest. This can be used to prevent
                 * concurrent modifications.
                 * @param dport Restrict TCP/UDP destination port. You can use
                 * service names or simple numbers (0-65535), as defined in
                 * '/etc/services'. Port ranges can be specified with '\d+:\d+',
                 * for example '80:85', and you can use comma separated list to
                 * match several ports or ranges.
                 * @param enable Flag to enable/disable a rule.
                 * @param icmp_type Specify icmp-type. Only valid if proto
                 * equals 'icmp' or 'icmpv6'/'ipv6-icmp'.
                 * @param iface Network interface name. You have to use network
                 * configuration key names for VMs and containers ('net\d+').
                 * Host related rules can use arbitrary strings.
                 * @param log Log level for firewall rule. Enum:
                 * emerg,alert,crit,err,warning,notice,info,debug,nolog
                 * @param macro Use predefined standard macro.
                 * @param pos Update rule at position &amp;lt;pos&amp;gt;.
                 * @param proto IP protocol. You can use protocol names
                 * ('tcp'/'udp') or simple numbers, as defined in
                 * '/etc/protocols'.
                 * @param source Restrict packet source address. This can refer
                 * to a single IP address, an IP set ('+ipsetname') or an IP
                 * alias definition. You can also specify an address range like
                 * '20.34.101.207-201.3.9.99', or a list of IP addresses and
                 * networks (entries are separated by comma). Please do not mix
                 * IPv4 and IPv6 addresses inside such lists.
                 * @param sport Restrict TCP/UDP source port. You can use
                 * service names or simple numbers (0-65535), as defined in
                 * '/etc/services'. Port ranges can be specified with '\d+:\d+',
                 * for example '80:85', and you can use comma separated list to
                 * match several ports or ranges.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createRule(String action, String type, String comment, String dest, String digest, String dport, Integer enable, String icmp_type, String iface, String log, String macro, Integer pos, String proto, String source, String sport) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("action", action);
                    parameters.put("type", type);
                    parameters.put("comment", comment);
                    parameters.put("dest", dest);
                    parameters.put("digest", digest);
                    parameters.put("dport", dport);
                    parameters.put("enable", enable);
                    parameters.put("icmp-type", icmp_type);
                    parameters.put("iface", iface);
                    parameters.put("log", log);
                    parameters.put("macro", macro);
                    parameters.put("pos", pos);
                    parameters.put("proto", proto);
                    parameters.put("source", source);
                    parameters.put("sport", sport);
                    return client.create("/cluster/firewall/rules", parameters);
                }

                /**
                 * Create new rule.
                 *
                 * @param action Rule action ('ACCEPT', 'DROP', 'REJECT') or
                 * security group name.
                 * @param type Rule type. Enum: in,out,group
                 * @return Result
                 * @throws JSONException
                 */

                public Result createRule(String action, String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("action", action);
                    parameters.put("type", type);
                    return client.create("/cluster/firewall/rules", parameters);
                }

            }

            public class PVEIpset {

                private final PveClient client;

                protected PVEIpset(PveClient client) {
                    this.client = client;

                }

                public PVENameItem get(Object name) {
                    return new PVENameItem(client, name);
                }

                public class PVENameItem {

                    private final PveClient client;
                    private final Object name;

                    protected PVENameItem(PveClient client, Object name) {
                        this.client = client;
                        this.name = name;
                    }

                    public PVECidrItem get(Object cidr) {
                        return new PVECidrItem(client, this.name, cidr);
                    }

                    public class PVECidrItem {

                        private final PveClient client;
                        private final Object name;
                        private final Object cidr;

                        protected PVECidrItem(PveClient client, Object name, Object cidr) {
                            this.client = client;
                            this.name = name;
                            this.cidr = cidr;
                        }

                        /**
                         * Remove IP or Network from IPSet.
                         *
                         * @param digest Prevent changes if current
                         * configuration file has a different digest. This can
                         * be used to prevent concurrent modifications.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result removeIp(String digest) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("digest", digest);
                            return client.delete("/cluster/firewall/ipset/" + this.name + "/" + this.cidr + "", parameters);
                        }

                        /**
                         * Remove IP or Network from IPSet.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result removeIp() throws JSONException {
                            return client.delete("/cluster/firewall/ipset/" + this.name + "/" + this.cidr + "", null);
                        }

                        /**
                         * Read IP or Network settings from IPSet.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result readIp() throws JSONException {
                            return client.get("/cluster/firewall/ipset/" + this.name + "/" + this.cidr + "", null);
                        }

                        /**
                         * Update IP or Network settings
                         *
                         * @param comment
                         * @param digest Prevent changes if current
                         * configuration file has a different digest. This can
                         * be used to prevent concurrent modifications.
                         * @param nomatch
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateIp(String comment, String digest, Boolean nomatch) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("comment", comment);
                            parameters.put("digest", digest);
                            parameters.put("nomatch", nomatch);
                            return client.set("/cluster/firewall/ipset/" + this.name + "/" + this.cidr + "", parameters);
                        }

                        /**
                         * Update IP or Network settings
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateIp() throws JSONException {
                            return client.set("/cluster/firewall/ipset/" + this.name + "/" + this.cidr + "", null);
                        }

                    }

                    /**
                     * Delete IPSet
                     *
                     * @param force Delete all members of the IPSet, if there
                     * are any.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result deleteIpset(Boolean force) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("force", force);
                        return client.delete("/cluster/firewall/ipset/" + this.name + "", parameters);
                    }

                    /**
                     * Delete IPSet
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result deleteIpset() throws JSONException {
                        return client.delete("/cluster/firewall/ipset/" + this.name + "", null);
                    }

                    /**
                     * List IPSet content
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result getIpset() throws JSONException {
                        return client.get("/cluster/firewall/ipset/" + this.name + "", null);
                    }

                    /**
                     * Add IP or Network to IPSet.
                     *
                     * @param cidr Network/IP specification in CIDR format.
                     * @param comment
                     * @param nomatch
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createIp(String cidr, String comment, Boolean nomatch) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("cidr", cidr);
                        parameters.put("comment", comment);
                        parameters.put("nomatch", nomatch);
                        return client.create("/cluster/firewall/ipset/" + this.name + "", parameters);
                    }

                    /**
                     * Add IP or Network to IPSet.
                     *
                     * @param cidr Network/IP specification in CIDR format.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createIp(String cidr) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("cidr", cidr);
                        return client.create("/cluster/firewall/ipset/" + this.name + "", parameters);
                    }

                }

                /**
                 * List IPSets
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result ipsetIndex() throws JSONException {
                    return client.get("/cluster/firewall/ipset", null);
                }

                /**
                 * Create new IPSet
                 *
                 * @param name IP set name.
                 * @param comment
                 * @param digest Prevent changes if current configuration file
                 * has a different digest. This can be used to prevent
                 * concurrent modifications.
                 * @param rename Rename an existing IPSet. You can set 'rename'
                 * to the same value as 'name' to update the 'comment' of an
                 * existing IPSet.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createIpset(String name, String comment, String digest, String rename) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("name", name);
                    parameters.put("comment", comment);
                    parameters.put("digest", digest);
                    parameters.put("rename", rename);
                    return client.create("/cluster/firewall/ipset", parameters);
                }

                /**
                 * Create new IPSet
                 *
                 * @param name IP set name.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createIpset(String name) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("name", name);
                    return client.create("/cluster/firewall/ipset", parameters);
                }

            }

            public class PVEAliases {

                private final PveClient client;

                protected PVEAliases(PveClient client) {
                    this.client = client;

                }

                public PVENameItem get(Object name) {
                    return new PVENameItem(client, name);
                }

                public class PVENameItem {

                    private final PveClient client;
                    private final Object name;

                    protected PVENameItem(PveClient client, Object name) {
                        this.client = client;
                        this.name = name;
                    }

                    /**
                     * Remove IP or Network alias.
                     *
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result removeAlias(String digest) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("digest", digest);
                        return client.delete("/cluster/firewall/aliases/" + this.name + "", parameters);
                    }

                    /**
                     * Remove IP or Network alias.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result removeAlias() throws JSONException {
                        return client.delete("/cluster/firewall/aliases/" + this.name + "", null);
                    }

                    /**
                     * Read alias.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result readAlias() throws JSONException {
                        return client.get("/cluster/firewall/aliases/" + this.name + "", null);
                    }

                    /**
                     * Update IP or Network alias.
                     *
                     * @param cidr Network/IP specification in CIDR format.
                     * @param comment
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param rename Rename an existing alias.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateAlias(String cidr, String comment, String digest, String rename) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("cidr", cidr);
                        parameters.put("comment", comment);
                        parameters.put("digest", digest);
                        parameters.put("rename", rename);
                        return client.set("/cluster/firewall/aliases/" + this.name + "", parameters);
                    }

                    /**
                     * Update IP or Network alias.
                     *
                     * @param cidr Network/IP specification in CIDR format.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateAlias(String cidr) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("cidr", cidr);
                        return client.set("/cluster/firewall/aliases/" + this.name + "", parameters);
                    }

                }

                /**
                 * List aliases
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result getAliases() throws JSONException {
                    return client.get("/cluster/firewall/aliases", null);
                }

                /**
                 * Create IP or Network Alias.
                 *
                 * @param cidr Network/IP specification in CIDR format.
                 * @param name Alias name.
                 * @param comment
                 * @return Result
                 * @throws JSONException
                 */

                public Result createAlias(String cidr, String name, String comment) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("cidr", cidr);
                    parameters.put("name", name);
                    parameters.put("comment", comment);
                    return client.create("/cluster/firewall/aliases", parameters);
                }

                /**
                 * Create IP or Network Alias.
                 *
                 * @param cidr Network/IP specification in CIDR format.
                 * @param name Alias name.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createAlias(String cidr, String name) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("cidr", cidr);
                    parameters.put("name", name);
                    return client.create("/cluster/firewall/aliases", parameters);
                }

            }

            public class PVEOptions {

                private final PveClient client;

                protected PVEOptions(PveClient client) {
                    this.client = client;

                }

                /**
                 * Get Firewall options.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result getOptions() throws JSONException {
                    return client.get("/cluster/firewall/options", null);
                }

                /**
                 * Set Firewall options.
                 *
                 * @param delete A list of settings you want to delete.
                 * @param digest Prevent changes if current configuration file
                 * has a different digest. This can be used to prevent
                 * concurrent modifications.
                 * @param ebtables Enable ebtables rules cluster wide.
                 * @param enable Enable or disable the firewall cluster wide.
                 * @param log_ratelimit Log ratelimiting settings
                 * @param policy_in Input policy. Enum: ACCEPT,REJECT,DROP
                 * @param policy_out Output policy. Enum: ACCEPT,REJECT,DROP
                 * @return Result
                 * @throws JSONException
                 */

                public Result setOptions(String delete, String digest, Boolean ebtables, Integer enable, String log_ratelimit, String policy_in, String policy_out) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("delete", delete);
                    parameters.put("digest", digest);
                    parameters.put("ebtables", ebtables);
                    parameters.put("enable", enable);
                    parameters.put("log_ratelimit", log_ratelimit);
                    parameters.put("policy_in", policy_in);
                    parameters.put("policy_out", policy_out);
                    return client.set("/cluster/firewall/options", parameters);
                }

                /**
                 * Set Firewall options.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result setOptions() throws JSONException {
                    return client.set("/cluster/firewall/options", null);
                }

            }

            public class PVEMacros {

                private final PveClient client;

                protected PVEMacros(PveClient client) {
                    this.client = client;

                }

                /**
                 * List available macros
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result getMacros() throws JSONException {
                    return client.get("/cluster/firewall/macros", null);
                }

            }

            public class PVERefs {

                private final PveClient client;

                protected PVERefs(PveClient client) {
                    this.client = client;

                }

                /**
                 * Lists possible IPSet/Alias reference which are allowed in
                 * source/dest properties.
                 *
                 * @param type Only list references of specified type. Enum:
                 * alias,ipset
                 * @return Result
                 * @throws JSONException
                 */
                public Result refs(String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("type", type);
                    return client.get("/cluster/firewall/refs", parameters);
                }

                /**
                 * Lists possible IPSet/Alias reference which are allowed in
                 * source/dest properties.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result refs() throws JSONException {
                    return client.get("/cluster/firewall/refs", null);
                }

            }

            /**
             * Directory index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/firewall", null);
            }

        }

        public class PVEBackup {

            private final PveClient client;

            protected PVEBackup(PveClient client) {
                this.client = client;

            }

            public PVEIdItem get(Object id) {
                return new PVEIdItem(client, id);
            }

            public class PVEIdItem {

                private final PveClient client;
                private final Object id;

                protected PVEIdItem(PveClient client, Object id) {
                    this.client = client;
                    this.id = id;
                }

                private PVEIncludedVolumes includedVolumes;

                public PVEIncludedVolumes getIncludedVolumes() {
                    return includedVolumes == null ? (includedVolumes = new PVEIncludedVolumes(client, this.id)) : includedVolumes;
                }

                public class PVEIncludedVolumes {

                    private final PveClient client;
                    private final Object id;

                    protected PVEIncludedVolumes(PveClient client, Object id) {
                        this.client = client;
                        this.id = id;
                    }

                    /**
                     * Returns included guests and the backup status of their
                     * disks. Optimized to be used in ExtJS tree views.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result getVolumeBackupIncluded() throws JSONException {
                        return client.get("/cluster/backup/" + this.id + "/included_volumes", null);
                    }

                }

                /**
                 * Delete vzdump backup job definition.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result deleteJob() throws JSONException {
                    return client.delete("/cluster/backup/" + this.id + "", null);
                }

                /**
                 * Read vzdump backup job definition.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result readJob() throws JSONException {
                    return client.get("/cluster/backup/" + this.id + "", null);
                }

                /**
                 * Update vzdump backup job definition.
                 *
                 * @param all Backup all known guest systems on this host.
                 * @param bwlimit Limit I/O bandwidth (in KiB/s).
                 * @param comment Description for the Job.
                 * @param compress Compress dump file. Enum: 0,1,gzip,lzo,zstd
                 * @param delete A list of settings you want to delete.
                 * @param dow Day of week selection.
                 * @param dumpdir Store resulting files to specified directory.
                 * @param enabled Enable or disable the job.
                 * @param exclude Exclude specified guest systems (assumes
                 * --all)
                 * @param exclude_path Exclude certain files/directories (shell
                 * globs). Paths starting with '/' are anchored to the
                 * container's root, other paths match relative to each
                 * subdirectory.
                 * @param ionice Set IO priority when using the BFQ scheduler.
                 * For snapshot and suspend mode backups of VMs, this only
                 * affects the compressor. A value of 8 means the idle priority
                 * is used, otherwise the best-effort priority is used with the
                 * specified value.
                 * @param lockwait Maximal time to wait for the global lock
                 * (minutes).
                 * @param mailnotification Deprecated: use 'notification-policy'
                 * instead. Enum: always,failure
                 * @param mailto Comma-separated list of email addresses or
                 * users that should receive email notifications. Has no effect
                 * if the 'notification-target' option is set at the same time.
                 * @param maxfiles Deprecated: use 'prune-backups' instead.
                 * Maximal number of backup files per guest system.
                 * @param mode Backup mode. Enum: snapshot,suspend,stop
                 * @param node Only run if executed on this node.
                 * @param notes_template Template string for generating notes
                 * for the backup(s). It can contain variables which will be
                 * replaced by their values. Currently supported are
                 * {{cluster}}, {{guestname}}, {{node}}, and {{vmid}}, but more
                 * might be added in the future. Needs to be a single line,
                 * newline and backslash need to be escaped as '\n' and '\\'
                 * respectively.
                 * @param notification_policy Specify when to send a
                 * notification Enum: always,failure,never
                 * @param notification_target Determine the target to which
                 * notifications should be sent. Can either be a notification
                 * endpoint or a notification group. This option takes
                 * precedence over 'mailto', meaning that if both are set, the
                 * 'mailto' option will be ignored.
                 * @param performance Other performance-related settings.
                 * @param pigz Use pigz instead of gzip when N&amp;gt;0. N=1
                 * uses half of cores, N&amp;gt;1 uses N as thread count.
                 * @param pool Backup all known guest systems included in the
                 * specified pool.
                 * @param protected_ If true, mark backup(s) as protected.
                 * @param prune_backups Use these retention options instead of
                 * those from the storage configuration.
                 * @param quiet Be quiet.
                 * @param remove Prune older backups according to
                 * 'prune-backups'.
                 * @param repeat_missed If true, the job will be run as soon as
                 * possible if it was missed while the scheduler was not
                 * running.
                 * @param schedule Backup schedule. The format is a subset of
                 * `systemd` calendar events.
                 * @param script Use specified hook script.
                 * @param starttime Job Start time.
                 * @param stdexcludes Exclude temporary files and logs.
                 * @param stop Stop running backup jobs on this host.
                 * @param stopwait Maximal time to wait until a guest system is
                 * stopped (minutes).
                 * @param storage Store resulting file to this storage.
                 * @param tmpdir Store temporary files to specified directory.
                 * @param vmid The ID of the guest system you want to backup.
                 * @param zstd Zstd threads. N=0 uses half of the available
                 * cores, N&amp;gt;0 uses N as thread count.
                 * @return Result
                 * @throws JSONException
                 */

                public Result updateJob(Boolean all, Integer bwlimit, String comment, String compress, String delete, String dow, String dumpdir, Boolean enabled, String exclude, String exclude_path, Integer ionice, Integer lockwait, String mailnotification, String mailto, Integer maxfiles, String mode, String node, String notes_template, String notification_policy, String notification_target, String performance, Integer pigz, String pool, Boolean protected_, String prune_backups, Boolean quiet, Boolean remove, Boolean repeat_missed, String schedule, String script, String starttime, Boolean stdexcludes, Boolean stop, Integer stopwait, String storage, String tmpdir, String vmid, Integer zstd) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("all", all);
                    parameters.put("bwlimit", bwlimit);
                    parameters.put("comment", comment);
                    parameters.put("compress", compress);
                    parameters.put("delete", delete);
                    parameters.put("dow", dow);
                    parameters.put("dumpdir", dumpdir);
                    parameters.put("enabled", enabled);
                    parameters.put("exclude", exclude);
                    parameters.put("exclude-path", exclude_path);
                    parameters.put("ionice", ionice);
                    parameters.put("lockwait", lockwait);
                    parameters.put("mailnotification", mailnotification);
                    parameters.put("mailto", mailto);
                    parameters.put("maxfiles", maxfiles);
                    parameters.put("mode", mode);
                    parameters.put("node", node);
                    parameters.put("notes-template", notes_template);
                    parameters.put("notification-policy", notification_policy);
                    parameters.put("notification-target", notification_target);
                    parameters.put("performance", performance);
                    parameters.put("pigz", pigz);
                    parameters.put("pool", pool);
                    parameters.put("protected", protected_);
                    parameters.put("prune-backups", prune_backups);
                    parameters.put("quiet", quiet);
                    parameters.put("remove", remove);
                    parameters.put("repeat-missed", repeat_missed);
                    parameters.put("schedule", schedule);
                    parameters.put("script", script);
                    parameters.put("starttime", starttime);
                    parameters.put("stdexcludes", stdexcludes);
                    parameters.put("stop", stop);
                    parameters.put("stopwait", stopwait);
                    parameters.put("storage", storage);
                    parameters.put("tmpdir", tmpdir);
                    parameters.put("vmid", vmid);
                    parameters.put("zstd", zstd);
                    return client.set("/cluster/backup/" + this.id + "", parameters);
                }

                /**
                 * Update vzdump backup job definition.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result updateJob() throws JSONException {
                    return client.set("/cluster/backup/" + this.id + "", null);
                }

            }

            /**
             * List vzdump backup schedule.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/backup", null);
            }

            /**
             * Create new vzdump backup job.
             *
             * @param all Backup all known guest systems on this host.
             * @param bwlimit Limit I/O bandwidth (in KiB/s).
             * @param comment Description for the Job.
             * @param compress Compress dump file. Enum: 0,1,gzip,lzo,zstd
             * @param dow Day of week selection.
             * @param dumpdir Store resulting files to specified directory.
             * @param enabled Enable or disable the job.
             * @param exclude Exclude specified guest systems (assumes --all)
             * @param exclude_path Exclude certain files/directories (shell
             * globs). Paths starting with '/' are anchored to the container's
             * root, other paths match relative to each subdirectory.
             * @param id Job ID (will be autogenerated).
             * @param ionice Set IO priority when using the BFQ scheduler. For
             * snapshot and suspend mode backups of VMs, this only affects the
             * compressor. A value of 8 means the idle priority is used,
             * otherwise the best-effort priority is used with the specified
             * value.
             * @param lockwait Maximal time to wait for the global lock
             * (minutes).
             * @param mailnotification Deprecated: use 'notification-policy'
             * instead. Enum: always,failure
             * @param mailto Comma-separated list of email addresses or users
             * that should receive email notifications. Has no effect if the
             * 'notification-target' option is set at the same time.
             * @param maxfiles Deprecated: use 'prune-backups' instead. Maximal
             * number of backup files per guest system.
             * @param mode Backup mode. Enum: snapshot,suspend,stop
             * @param node Only run if executed on this node.
             * @param notes_template Template string for generating notes for
             * the backup(s). It can contain variables which will be replaced by
             * their values. Currently supported are {{cluster}}, {{guestname}},
             * {{node}}, and {{vmid}}, but more might be added in the future.
             * Needs to be a single line, newline and backslash need to be
             * escaped as '\n' and '\\' respectively.
             * @param notification_policy Specify when to send a notification
             * Enum: always,failure,never
             * @param notification_target Determine the target to which
             * notifications should be sent. Can either be a notification
             * endpoint or a notification group. This option takes precedence
             * over 'mailto', meaning that if both are set, the 'mailto' option
             * will be ignored.
             * @param performance Other performance-related settings.
             * @param pigz Use pigz instead of gzip when N&amp;gt;0. N=1 uses
             * half of cores, N&amp;gt;1 uses N as thread count.
             * @param pool Backup all known guest systems included in the
             * specified pool.
             * @param protected_ If true, mark backup(s) as protected.
             * @param prune_backups Use these retention options instead of those
             * from the storage configuration.
             * @param quiet Be quiet.
             * @param remove Prune older backups according to 'prune-backups'.
             * @param repeat_missed If true, the job will be run as soon as
             * possible if it was missed while the scheduler was not running.
             * @param schedule Backup schedule. The format is a subset of
             * `systemd` calendar events.
             * @param script Use specified hook script.
             * @param starttime Job Start time.
             * @param stdexcludes Exclude temporary files and logs.
             * @param stop Stop running backup jobs on this host.
             * @param stopwait Maximal time to wait until a guest system is
             * stopped (minutes).
             * @param storage Store resulting file to this storage.
             * @param tmpdir Store temporary files to specified directory.
             * @param vmid The ID of the guest system you want to backup.
             * @param zstd Zstd threads. N=0 uses half of the available cores,
             * N&amp;gt;0 uses N as thread count.
             * @return Result
             * @throws JSONException
             */

            public Result createJob(Boolean all, Integer bwlimit, String comment, String compress, String dow, String dumpdir, Boolean enabled, String exclude, String exclude_path, String id, Integer ionice, Integer lockwait, String mailnotification, String mailto, Integer maxfiles, String mode, String node, String notes_template, String notification_policy, String notification_target, String performance, Integer pigz, String pool, Boolean protected_, String prune_backups, Boolean quiet, Boolean remove, Boolean repeat_missed, String schedule, String script, String starttime, Boolean stdexcludes, Boolean stop, Integer stopwait, String storage, String tmpdir, String vmid, Integer zstd) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("all", all);
                parameters.put("bwlimit", bwlimit);
                parameters.put("comment", comment);
                parameters.put("compress", compress);
                parameters.put("dow", dow);
                parameters.put("dumpdir", dumpdir);
                parameters.put("enabled", enabled);
                parameters.put("exclude", exclude);
                parameters.put("exclude-path", exclude_path);
                parameters.put("id", id);
                parameters.put("ionice", ionice);
                parameters.put("lockwait", lockwait);
                parameters.put("mailnotification", mailnotification);
                parameters.put("mailto", mailto);
                parameters.put("maxfiles", maxfiles);
                parameters.put("mode", mode);
                parameters.put("node", node);
                parameters.put("notes-template", notes_template);
                parameters.put("notification-policy", notification_policy);
                parameters.put("notification-target", notification_target);
                parameters.put("performance", performance);
                parameters.put("pigz", pigz);
                parameters.put("pool", pool);
                parameters.put("protected", protected_);
                parameters.put("prune-backups", prune_backups);
                parameters.put("quiet", quiet);
                parameters.put("remove", remove);
                parameters.put("repeat-missed", repeat_missed);
                parameters.put("schedule", schedule);
                parameters.put("script", script);
                parameters.put("starttime", starttime);
                parameters.put("stdexcludes", stdexcludes);
                parameters.put("stop", stop);
                parameters.put("stopwait", stopwait);
                parameters.put("storage", storage);
                parameters.put("tmpdir", tmpdir);
                parameters.put("vmid", vmid);
                parameters.put("zstd", zstd);
                return client.create("/cluster/backup", parameters);
            }

            /**
             * Create new vzdump backup job.
             *
             * @return Result
             * @throws JSONException
             */

            public Result createJob() throws JSONException {
                return client.create("/cluster/backup", null);
            }

        }

        public class PVEBackupInfo {

            private final PveClient client;

            protected PVEBackupInfo(PveClient client) {
                this.client = client;

            }

            private PVENotBackedUp notBackedUp;

            public PVENotBackedUp getNotBackedUp() {
                return notBackedUp == null ? (notBackedUp = new PVENotBackedUp(client)) : notBackedUp;
            }

            public class PVENotBackedUp {

                private final PveClient client;

                protected PVENotBackedUp(PveClient client) {
                    this.client = client;

                }

                /**
                 * Shows all guests which are not covered by any backup job.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result getGuestsNotInBackup() throws JSONException {
                    return client.get("/cluster/backup-info/not-backed-up", null);
                }

            }

            /**
             * Index for backup info related endpoints
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/backup-info", null);
            }

        }

        public class PVEHa {

            private final PveClient client;

            protected PVEHa(PveClient client) {
                this.client = client;

            }

            private PVEResources resources;

            public PVEResources getResources() {
                return resources == null ? (resources = new PVEResources(client)) : resources;
            }
            private PVEGroups groups;

            public PVEGroups getGroups() {
                return groups == null ? (groups = new PVEGroups(client)) : groups;
            }
            private PVEStatus status;

            public PVEStatus getStatus() {
                return status == null ? (status = new PVEStatus(client)) : status;
            }

            public class PVEResources {

                private final PveClient client;

                protected PVEResources(PveClient client) {
                    this.client = client;

                }

                public PVESidItem get(Object sid) {
                    return new PVESidItem(client, sid);
                }

                public class PVESidItem {

                    private final PveClient client;
                    private final Object sid;

                    protected PVESidItem(PveClient client, Object sid) {
                        this.client = client;
                        this.sid = sid;
                    }

                    private PVEMigrate migrate;

                    public PVEMigrate getMigrate() {
                        return migrate == null ? (migrate = new PVEMigrate(client, this.sid)) : migrate;
                    }
                    private PVERelocate relocate;

                    public PVERelocate getRelocate() {
                        return relocate == null ? (relocate = new PVERelocate(client, this.sid)) : relocate;
                    }

                    public class PVEMigrate {

                        private final PveClient client;
                        private final Object sid;

                        protected PVEMigrate(PveClient client, Object sid) {
                            this.client = client;
                            this.sid = sid;
                        }

                        /**
                         * Request resource migration (online) to another node.
                         *
                         * @param node Target node.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result migrate(String node) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("node", node);
                            return client.create("/cluster/ha/resources/" + this.sid + "/migrate", parameters);
                        }

                    }

                    public class PVERelocate {

                        private final PveClient client;
                        private final Object sid;

                        protected PVERelocate(PveClient client, Object sid) {
                            this.client = client;
                            this.sid = sid;
                        }

                        /**
                         * Request resource relocatzion to another node. This
                         * stops the service on the old node, and restarts it on
                         * the target node.
                         *
                         * @param node Target node.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result relocate(String node) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("node", node);
                            return client.create("/cluster/ha/resources/" + this.sid + "/relocate", parameters);
                        }

                    }

                    /**
                     * Delete resource configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result delete() throws JSONException {
                        return client.delete("/cluster/ha/resources/" + this.sid + "", null);
                    }

                    /**
                     * Read resource configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result read() throws JSONException {
                        return client.get("/cluster/ha/resources/" + this.sid + "", null);
                    }

                    /**
                     * Update resource configuration.
                     *
                     * @param comment Description.
                     * @param delete A list of settings you want to delete.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param group The HA group identifier.
                     * @param max_relocate Maximal number of service relocate
                     * tries when a service failes to start.
                     * @param max_restart Maximal number of tries to restart the
                     * service on a node after its start failed.
                     * @param state Requested resource state. Enum:
                     * started,stopped,enabled,disabled,ignored
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(String comment, String delete, String digest, String group, Integer max_relocate, Integer max_restart, String state) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("comment", comment);
                        parameters.put("delete", delete);
                        parameters.put("digest", digest);
                        parameters.put("group", group);
                        parameters.put("max_relocate", max_relocate);
                        parameters.put("max_restart", max_restart);
                        parameters.put("state", state);
                        return client.set("/cluster/ha/resources/" + this.sid + "", parameters);
                    }

                    /**
                     * Update resource configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update() throws JSONException {
                        return client.set("/cluster/ha/resources/" + this.sid + "", null);
                    }

                }

                /**
                 * List HA resources.
                 *
                 * @param type Only list resources of specific type Enum: ct,vm
                 * @return Result
                 * @throws JSONException
                 */
                public Result index(String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("type", type);
                    return client.get("/cluster/ha/resources", parameters);
                }

                /**
                 * List HA resources.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result index() throws JSONException {
                    return client.get("/cluster/ha/resources", null);
                }

                /**
                 * Create a new HA resource.
                 *
                 * @param sid HA resource ID. This consists of a resource type
                 * followed by a resource specific name, separated with colon
                 * (example: vm:100 / ct:100). For virtual machines and
                 * containers, you can simply use the VM or CT id as a shortcut
                 * (example: 100).
                 * @param comment Description.
                 * @param group The HA group identifier.
                 * @param max_relocate Maximal number of service relocate tries
                 * when a service failes to start.
                 * @param max_restart Maximal number of tries to restart the
                 * service on a node after its start failed.
                 * @param state Requested resource state. Enum:
                 * started,stopped,enabled,disabled,ignored
                 * @param type Resource type. Enum: ct,vm
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String sid, String comment, String group, Integer max_relocate, Integer max_restart, String state, String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("sid", sid);
                    parameters.put("comment", comment);
                    parameters.put("group", group);
                    parameters.put("max_relocate", max_relocate);
                    parameters.put("max_restart", max_restart);
                    parameters.put("state", state);
                    parameters.put("type", type);
                    return client.create("/cluster/ha/resources", parameters);
                }

                /**
                 * Create a new HA resource.
                 *
                 * @param sid HA resource ID. This consists of a resource type
                 * followed by a resource specific name, separated with colon
                 * (example: vm:100 / ct:100). For virtual machines and
                 * containers, you can simply use the VM or CT id as a shortcut
                 * (example: 100).
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String sid) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("sid", sid);
                    return client.create("/cluster/ha/resources", parameters);
                }

            }

            public class PVEGroups {

                private final PveClient client;

                protected PVEGroups(PveClient client) {
                    this.client = client;

                }

                public PVEGroupItem get(Object group) {
                    return new PVEGroupItem(client, group);
                }

                public class PVEGroupItem {

                    private final PveClient client;
                    private final Object group;

                    protected PVEGroupItem(PveClient client, Object group) {
                        this.client = client;
                        this.group = group;
                    }

                    /**
                     * Delete ha group configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result delete() throws JSONException {
                        return client.delete("/cluster/ha/groups/" + this.group + "", null);
                    }

                    /**
                     * Read ha group configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result read() throws JSONException {
                        return client.get("/cluster/ha/groups/" + this.group + "", null);
                    }

                    /**
                     * Update ha group configuration.
                     *
                     * @param comment Description.
                     * @param delete A list of settings you want to delete.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param nodes List of cluster node names with optional
                     * priority.
                     * @param nofailback The CRM tries to run services on the
                     * node with the highest priority. If a node with higher
                     * priority comes online, the CRM migrates the service to
                     * that node. Enabling nofailback prevents that behavior.
                     * @param restricted Resources bound to restricted groups
                     * may only run on nodes defined by the group.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(String comment, String delete, String digest, String nodes, Boolean nofailback, Boolean restricted) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("comment", comment);
                        parameters.put("delete", delete);
                        parameters.put("digest", digest);
                        parameters.put("nodes", nodes);
                        parameters.put("nofailback", nofailback);
                        parameters.put("restricted", restricted);
                        return client.set("/cluster/ha/groups/" + this.group + "", parameters);
                    }

                    /**
                     * Update ha group configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update() throws JSONException {
                        return client.set("/cluster/ha/groups/" + this.group + "", null);
                    }

                }

                /**
                 * Get HA groups.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result index() throws JSONException {
                    return client.get("/cluster/ha/groups", null);
                }

                /**
                 * Create a new HA group.
                 *
                 * @param group The HA group identifier.
                 * @param nodes List of cluster node names with optional
                 * priority.
                 * @param comment Description.
                 * @param nofailback The CRM tries to run services on the node
                 * with the highest priority. If a node with higher priority
                 * comes online, the CRM migrates the service to that node.
                 * Enabling nofailback prevents that behavior.
                 * @param restricted Resources bound to restricted groups may
                 * only run on nodes defined by the group.
                 * @param type Group type. Enum: group
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String group, String nodes, String comment, Boolean nofailback, Boolean restricted, String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("group", group);
                    parameters.put("nodes", nodes);
                    parameters.put("comment", comment);
                    parameters.put("nofailback", nofailback);
                    parameters.put("restricted", restricted);
                    parameters.put("type", type);
                    return client.create("/cluster/ha/groups", parameters);
                }

                /**
                 * Create a new HA group.
                 *
                 * @param group The HA group identifier.
                 * @param nodes List of cluster node names with optional
                 * priority.
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String group, String nodes) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("group", group);
                    parameters.put("nodes", nodes);
                    return client.create("/cluster/ha/groups", parameters);
                }

            }

            public class PVEStatus {

                private final PveClient client;

                protected PVEStatus(PveClient client) {
                    this.client = client;

                }

                private PVECurrent current;

                public PVECurrent getCurrent() {
                    return current == null ? (current = new PVECurrent(client)) : current;
                }
                private PVEManagerStatus managerStatus;

                public PVEManagerStatus getManagerStatus() {
                    return managerStatus == null ? (managerStatus = new PVEManagerStatus(client)) : managerStatus;
                }

                public class PVECurrent {

                    private final PveClient client;

                    protected PVECurrent(PveClient client) {
                        this.client = client;

                    }

                    /**
                     * Get HA manger status.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result status() throws JSONException {
                        return client.get("/cluster/ha/status/current", null);
                    }

                }

                public class PVEManagerStatus {

                    private final PveClient client;

                    protected PVEManagerStatus(PveClient client) {
                        this.client = client;

                    }

                    /**
                     * Get full HA manger status, including LRM status.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result managerStatus() throws JSONException {
                        return client.get("/cluster/ha/status/manager_status", null);
                    }

                }

                /**
                 * Directory index.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result index() throws JSONException {
                    return client.get("/cluster/ha/status", null);
                }

            }

            /**
             * Directory index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/ha", null);
            }

        }

        public class PVEAcme {

            private final PveClient client;

            protected PVEAcme(PveClient client) {
                this.client = client;

            }

            private PVEPlugins plugins;

            public PVEPlugins getPlugins() {
                return plugins == null ? (plugins = new PVEPlugins(client)) : plugins;
            }
            private PVEAccount account;

            public PVEAccount getAccount() {
                return account == null ? (account = new PVEAccount(client)) : account;
            }
            private PVETos tos;

            public PVETos getTos() {
                return tos == null ? (tos = new PVETos(client)) : tos;
            }
            private PVEMeta meta;

            public PVEMeta getMeta() {
                return meta == null ? (meta = new PVEMeta(client)) : meta;
            }
            private PVEDirectories directories;

            public PVEDirectories getDirectories() {
                return directories == null ? (directories = new PVEDirectories(client)) : directories;
            }
            private PVEChallengeSchema challengeSchema;

            public PVEChallengeSchema getChallengeSchema() {
                return challengeSchema == null ? (challengeSchema = new PVEChallengeSchema(client)) : challengeSchema;
            }

            public class PVEPlugins {

                private final PveClient client;

                protected PVEPlugins(PveClient client) {
                    this.client = client;

                }

                public PVEIdItem get(Object id) {
                    return new PVEIdItem(client, id);
                }

                public class PVEIdItem {

                    private final PveClient client;
                    private final Object id;

                    protected PVEIdItem(PveClient client, Object id) {
                        this.client = client;
                        this.id = id;
                    }

                    /**
                     * Delete ACME plugin configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result deletePlugin() throws JSONException {
                        return client.delete("/cluster/acme/plugins/" + this.id + "", null);
                    }

                    /**
                     * Get ACME plugin configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result getPluginConfig() throws JSONException {
                        return client.get("/cluster/acme/plugins/" + this.id + "", null);
                    }

                    /**
                     * Update ACME plugin configuration.
                     *
                     * @param api API plugin name Enum:
                     * 1984hosting,acmedns,acmeproxy,active24,ad,ali,anx,artfiles,arvan,aurora,autodns,aws,azion,azure,bookmyname,bunny,cf,clouddns,cloudns,cn,conoha,constellix,cpanel,curanet,cyon,da,ddnss,desec,df,dgon,dnsexit,dnshome,dnsimple,dnsservices,do,doapi,domeneshop,dp,dpi,dreamhost,duckdns,durabledns,dyn,dynu,dynv6,easydns,edgedns,euserv,exoscale,fornex,freedns,gandi_livedns,gcloud,gcore,gd,geoscaling,googledomains,he,hetzner,hexonet,hostingde,huaweicloud,infoblox,infomaniak,internetbs,inwx,ionos,ipv64,ispconfig,jd,joker,kappernet,kas,kinghost,knot,la,leaseweb,lexicon,linode,linode_v4,loopia,lua,maradns,me,miab,misaka,myapi,mydevil,mydnsjp,mythic_beasts,namecheap,namecom,namesilo,nanelo,nederhost,neodigit,netcup,netlify,nic,njalla,nm,nsd,nsone,nsupdate,nw,oci,one,online,openprovider,openstack,opnsense,ovh,pdns,pleskxml,pointhq,porkbun,rackcorp,rackspace,rage4,rcode0,regru,scaleway,schlundtech,selectel,selfhost,servercow,simply,tele3,tencent,transip,udr,ultra,unoeuro,variomedia,veesp,vercel,vscale,vultr,websupport,world4you,yandex,yc,zilore,zone,zonomi
                     * @param data DNS plugin data. (base64 encoded)
                     * @param delete A list of settings you want to delete.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param disable Flag to disable the config.
                     * @param nodes List of cluster node names.
                     * @param validation_delay Extra delay in seconds to wait
                     * before requesting validation. Allows to cope with a long
                     * TTL of DNS records.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updatePlugin(String api, String data, String delete, String digest, Boolean disable, String nodes, Integer validation_delay) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("api", api);
                        parameters.put("data", data);
                        parameters.put("delete", delete);
                        parameters.put("digest", digest);
                        parameters.put("disable", disable);
                        parameters.put("nodes", nodes);
                        parameters.put("validation-delay", validation_delay);
                        return client.set("/cluster/acme/plugins/" + this.id + "", parameters);
                    }

                    /**
                     * Update ACME plugin configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updatePlugin() throws JSONException {
                        return client.set("/cluster/acme/plugins/" + this.id + "", null);
                    }

                }

                /**
                 * ACME plugin index.
                 *
                 * @param type Only list ACME plugins of a specific type Enum:
                 * dns,standalone
                 * @return Result
                 * @throws JSONException
                 */
                public Result index(String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("type", type);
                    return client.get("/cluster/acme/plugins", parameters);
                }

                /**
                 * ACME plugin index.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result index() throws JSONException {
                    return client.get("/cluster/acme/plugins", null);
                }

                /**
                 * Add ACME plugin configuration.
                 *
                 * @param id ACME Plugin ID name
                 * @param type ACME challenge type. Enum: dns,standalone
                 * @param api API plugin name Enum:
                 * 1984hosting,acmedns,acmeproxy,active24,ad,ali,anx,artfiles,arvan,aurora,autodns,aws,azion,azure,bookmyname,bunny,cf,clouddns,cloudns,cn,conoha,constellix,cpanel,curanet,cyon,da,ddnss,desec,df,dgon,dnsexit,dnshome,dnsimple,dnsservices,do,doapi,domeneshop,dp,dpi,dreamhost,duckdns,durabledns,dyn,dynu,dynv6,easydns,edgedns,euserv,exoscale,fornex,freedns,gandi_livedns,gcloud,gcore,gd,geoscaling,googledomains,he,hetzner,hexonet,hostingde,huaweicloud,infoblox,infomaniak,internetbs,inwx,ionos,ipv64,ispconfig,jd,joker,kappernet,kas,kinghost,knot,la,leaseweb,lexicon,linode,linode_v4,loopia,lua,maradns,me,miab,misaka,myapi,mydevil,mydnsjp,mythic_beasts,namecheap,namecom,namesilo,nanelo,nederhost,neodigit,netcup,netlify,nic,njalla,nm,nsd,nsone,nsupdate,nw,oci,one,online,openprovider,openstack,opnsense,ovh,pdns,pleskxml,pointhq,porkbun,rackcorp,rackspace,rage4,rcode0,regru,scaleway,schlundtech,selectel,selfhost,servercow,simply,tele3,tencent,transip,udr,ultra,unoeuro,variomedia,veesp,vercel,vscale,vultr,websupport,world4you,yandex,yc,zilore,zone,zonomi
                 * @param data DNS plugin data. (base64 encoded)
                 * @param disable Flag to disable the config.
                 * @param nodes List of cluster node names.
                 * @param validation_delay Extra delay in seconds to wait before
                 * requesting validation. Allows to cope with a long TTL of DNS
                 * records.
                 * @return Result
                 * @throws JSONException
                 */

                public Result addPlugin(String id, String type, String api, String data, Boolean disable, String nodes, Integer validation_delay) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("id", id);
                    parameters.put("type", type);
                    parameters.put("api", api);
                    parameters.put("data", data);
                    parameters.put("disable", disable);
                    parameters.put("nodes", nodes);
                    parameters.put("validation-delay", validation_delay);
                    return client.create("/cluster/acme/plugins", parameters);
                }

                /**
                 * Add ACME plugin configuration.
                 *
                 * @param id ACME Plugin ID name
                 * @param type ACME challenge type. Enum: dns,standalone
                 * @return Result
                 * @throws JSONException
                 */

                public Result addPlugin(String id, String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("id", id);
                    parameters.put("type", type);
                    return client.create("/cluster/acme/plugins", parameters);
                }

            }

            public class PVEAccount {

                private final PveClient client;

                protected PVEAccount(PveClient client) {
                    this.client = client;

                }

                public PVENameItem get(Object name) {
                    return new PVENameItem(client, name);
                }

                public class PVENameItem {

                    private final PveClient client;
                    private final Object name;

                    protected PVENameItem(PveClient client, Object name) {
                        this.client = client;
                        this.name = name;
                    }

                    /**
                     * Deactivate existing ACME account at CA.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result deactivateAccount() throws JSONException {
                        return client.delete("/cluster/acme/account/" + this.name + "", null);
                    }

                    /**
                     * Return existing ACME account information.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result getAccount() throws JSONException {
                        return client.get("/cluster/acme/account/" + this.name + "", null);
                    }

                    /**
                     * Update existing ACME account information with CA. Note:
                     * not specifying any new account information triggers a
                     * refresh.
                     *
                     * @param contact Contact email addresses.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateAccount(String contact) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("contact", contact);
                        return client.set("/cluster/acme/account/" + this.name + "", parameters);
                    }

                    /**
                     * Update existing ACME account information with CA. Note:
                     * not specifying any new account information triggers a
                     * refresh.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateAccount() throws JSONException {
                        return client.set("/cluster/acme/account/" + this.name + "", null);
                    }

                }

                /**
                 * ACMEAccount index.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result accountIndex() throws JSONException {
                    return client.get("/cluster/acme/account", null);
                }

                /**
                 * Register a new ACME account with CA.
                 *
                 * @param contact Contact email addresses.
                 * @param directory URL of ACME CA directory endpoint.
                 * @param eab_hmac_key HMAC key for External Account Binding.
                 * @param eab_kid Key Identifier for External Account Binding.
                 * @param name ACME account config file name.
                 * @param tos_url URL of CA TermsOfService - setting this
                 * indicates agreement.
                 * @return Result
                 * @throws JSONException
                 */

                public Result registerAccount(String contact, String directory, String eab_hmac_key, String eab_kid, String name, String tos_url) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("contact", contact);
                    parameters.put("directory", directory);
                    parameters.put("eab-hmac-key", eab_hmac_key);
                    parameters.put("eab-kid", eab_kid);
                    parameters.put("name", name);
                    parameters.put("tos_url", tos_url);
                    return client.create("/cluster/acme/account", parameters);
                }

                /**
                 * Register a new ACME account with CA.
                 *
                 * @param contact Contact email addresses.
                 * @return Result
                 * @throws JSONException
                 */

                public Result registerAccount(String contact) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("contact", contact);
                    return client.create("/cluster/acme/account", parameters);
                }

            }

            public class PVETos {

                private final PveClient client;

                protected PVETos(PveClient client) {
                    this.client = client;

                }

                /**
                 * Retrieve ACME TermsOfService URL from CA. Deprecated, please
                 * use /cluster/acme/meta.
                 *
                 * @param directory URL of ACME CA directory endpoint.
                 * @return Result
                 * @throws JSONException
                 */
                public Result getTos(String directory) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("directory", directory);
                    return client.get("/cluster/acme/tos", parameters);
                }

                /**
                 * Retrieve ACME TermsOfService URL from CA. Deprecated, please
                 * use /cluster/acme/meta.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result getTos() throws JSONException {
                    return client.get("/cluster/acme/tos", null);
                }

            }

            public class PVEMeta {

                private final PveClient client;

                protected PVEMeta(PveClient client) {
                    this.client = client;

                }

                /**
                 * Retrieve ACME Directory Meta Information
                 *
                 * @param directory URL of ACME CA directory endpoint.
                 * @return Result
                 * @throws JSONException
                 */
                public Result getMeta(String directory) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("directory", directory);
                    return client.get("/cluster/acme/meta", parameters);
                }

                /**
                 * Retrieve ACME Directory Meta Information
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result getMeta() throws JSONException {
                    return client.get("/cluster/acme/meta", null);
                }

            }

            public class PVEDirectories {

                private final PveClient client;

                protected PVEDirectories(PveClient client) {
                    this.client = client;

                }

                /**
                 * Get named known ACME directory endpoints.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result getDirectories() throws JSONException {
                    return client.get("/cluster/acme/directories", null);
                }

            }

            public class PVEChallengeSchema {

                private final PveClient client;

                protected PVEChallengeSchema(PveClient client) {
                    this.client = client;

                }

                /**
                 * Get schema of ACME challenge types.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result challengeschema() throws JSONException {
                    return client.get("/cluster/acme/challenge-schema", null);
                }

            }

            /**
             * ACMEAccount index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/acme", null);
            }

        }

        public class PVECeph {

            private final PveClient client;

            protected PVECeph(PveClient client) {
                this.client = client;

            }

            private PVEMetadata metadata;

            public PVEMetadata getMetadata() {
                return metadata == null ? (metadata = new PVEMetadata(client)) : metadata;
            }
            private PVEStatus status;

            public PVEStatus getStatus() {
                return status == null ? (status = new PVEStatus(client)) : status;
            }
            private PVEFlags flags;

            public PVEFlags getFlags() {
                return flags == null ? (flags = new PVEFlags(client)) : flags;
            }

            public class PVEMetadata {

                private final PveClient client;

                protected PVEMetadata(PveClient client) {
                    this.client = client;

                }

                /**
                 * Get ceph metadata.
                 *
                 * @param scope Enum: all,versions
                 * @return Result
                 * @throws JSONException
                 */
                public Result metadata(String scope) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("scope", scope);
                    return client.get("/cluster/ceph/metadata", parameters);
                }

                /**
                 * Get ceph metadata.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result metadata() throws JSONException {
                    return client.get("/cluster/ceph/metadata", null);
                }

            }

            public class PVEStatus {

                private final PveClient client;

                protected PVEStatus(PveClient client) {
                    this.client = client;

                }

                /**
                 * Get ceph status.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result status() throws JSONException {
                    return client.get("/cluster/ceph/status", null);
                }

            }

            public class PVEFlags {

                private final PveClient client;

                protected PVEFlags(PveClient client) {
                    this.client = client;

                }

                public PVEFlagItem get(Object flag) {
                    return new PVEFlagItem(client, flag);
                }

                public class PVEFlagItem {

                    private final PveClient client;
                    private final Object flag;

                    protected PVEFlagItem(PveClient client, Object flag) {
                        this.client = client;
                        this.flag = flag;
                    }

                    /**
                     * Get the status of a specific ceph flag.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result getFlag() throws JSONException {
                        return client.get("/cluster/ceph/flags/" + this.flag + "", null);
                    }

                    /**
                     * Set or clear (unset) a specific ceph flag
                     *
                     * @param value The new value of the flag
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateFlag(boolean value) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("value", value);
                        return client.set("/cluster/ceph/flags/" + this.flag + "", parameters);
                    }

                }

                /**
                 * get the status of all ceph flags
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result getAllFlags() throws JSONException {
                    return client.get("/cluster/ceph/flags", null);
                }

                /**
                 * Set/Unset multiple ceph flags at once.
                 *
                 * @param nobackfill Backfilling of PGs is suspended.
                 * @param nodeep_scrub Deep Scrubbing is disabled.
                 * @param nodown OSD failure reports are being ignored, such
                 * that the monitors will not mark OSDs down.
                 * @param noin OSDs that were previously marked out will not be
                 * marked back in when they start.
                 * @param noout OSDs will not automatically be marked out after
                 * the configured interval.
                 * @param norebalance Rebalancing of PGs is suspended.
                 * @param norecover Recovery of PGs is suspended.
                 * @param noscrub Scrubbing is disabled.
                 * @param notieragent Cache tiering activity is suspended.
                 * @param noup OSDs are not allowed to start.
                 * @param pause Pauses read and writes.
                 * @return Result
                 * @throws JSONException
                 */

                public Result setFlags(Boolean nobackfill, Boolean nodeep_scrub, Boolean nodown, Boolean noin, Boolean noout, Boolean norebalance, Boolean norecover, Boolean noscrub, Boolean notieragent, Boolean noup, Boolean pause) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("nobackfill", nobackfill);
                    parameters.put("nodeep-scrub", nodeep_scrub);
                    parameters.put("nodown", nodown);
                    parameters.put("noin", noin);
                    parameters.put("noout", noout);
                    parameters.put("norebalance", norebalance);
                    parameters.put("norecover", norecover);
                    parameters.put("noscrub", noscrub);
                    parameters.put("notieragent", notieragent);
                    parameters.put("noup", noup);
                    parameters.put("pause", pause);
                    return client.set("/cluster/ceph/flags", parameters);
                }

                /**
                 * Set/Unset multiple ceph flags at once.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result setFlags() throws JSONException {
                    return client.set("/cluster/ceph/flags", null);
                }

            }

            /**
             * Cluster ceph index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result cephindex() throws JSONException {
                return client.get("/cluster/ceph", null);
            }

        }

        public class PVEJobs {

            private final PveClient client;

            protected PVEJobs(PveClient client) {
                this.client = client;

            }

            private PVERealmSync realmSync;

            public PVERealmSync getRealmSync() {
                return realmSync == null ? (realmSync = new PVERealmSync(client)) : realmSync;
            }
            private PVEScheduleAnalyze scheduleAnalyze;

            public PVEScheduleAnalyze getScheduleAnalyze() {
                return scheduleAnalyze == null ? (scheduleAnalyze = new PVEScheduleAnalyze(client)) : scheduleAnalyze;
            }

            public class PVERealmSync {

                private final PveClient client;

                protected PVERealmSync(PveClient client) {
                    this.client = client;

                }

                public PVEIdItem get(Object id) {
                    return new PVEIdItem(client, id);
                }

                public class PVEIdItem {

                    private final PveClient client;
                    private final Object id;

                    protected PVEIdItem(PveClient client, Object id) {
                        this.client = client;
                        this.id = id;
                    }

                    /**
                     * Delete realm-sync job definition.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result deleteJob() throws JSONException {
                        return client.delete("/cluster/jobs/realm-sync/" + this.id + "", null);
                    }

                    /**
                     * Read realm-sync job definition.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result readJob() throws JSONException {
                        return client.get("/cluster/jobs/realm-sync/" + this.id + "", null);
                    }

                    /**
                     * Create new realm-sync job.
                     *
                     * @param schedule Backup schedule. The format is a subset
                     * of `systemd` calendar events.
                     * @param comment Description for the Job.
                     * @param enable_new Enable newly synced users immediately.
                     * @param enabled Determines if the job is enabled.
                     * @param realm Authentication domain ID
                     * @param remove_vanished A semicolon-seperated list of
                     * things to remove when they or the user vanishes during a
                     * sync. The following values are possible: 'entry' removes
                     * the user/group when not returned from the sync.
                     * 'properties' removes the set properties on existing
                     * user/group that do not appear in the source (even custom
                     * ones). 'acl' removes acls when the user/group is not
                     * returned from the sync. Instead of a list it also can be
                     * 'none' (the default).
                     * @param scope Select what to sync. Enum: users,groups,both
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createJob(String schedule, String comment, Boolean enable_new, Boolean enabled, String realm, String remove_vanished, String scope) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("schedule", schedule);
                        parameters.put("comment", comment);
                        parameters.put("enable-new", enable_new);
                        parameters.put("enabled", enabled);
                        parameters.put("realm", realm);
                        parameters.put("remove-vanished", remove_vanished);
                        parameters.put("scope", scope);
                        return client.create("/cluster/jobs/realm-sync/" + this.id + "", parameters);
                    }

                    /**
                     * Create new realm-sync job.
                     *
                     * @param schedule Backup schedule. The format is a subset
                     * of `systemd` calendar events.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createJob(String schedule) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("schedule", schedule);
                        return client.create("/cluster/jobs/realm-sync/" + this.id + "", parameters);
                    }

                    /**
                     * Update realm-sync job definition.
                     *
                     * @param schedule Backup schedule. The format is a subset
                     * of `systemd` calendar events.
                     * @param comment Description for the Job.
                     * @param delete A list of settings you want to delete.
                     * @param enable_new Enable newly synced users immediately.
                     * @param enabled Determines if the job is enabled.
                     * @param remove_vanished A semicolon-seperated list of
                     * things to remove when they or the user vanishes during a
                     * sync. The following values are possible: 'entry' removes
                     * the user/group when not returned from the sync.
                     * 'properties' removes the set properties on existing
                     * user/group that do not appear in the source (even custom
                     * ones). 'acl' removes acls when the user/group is not
                     * returned from the sync. Instead of a list it also can be
                     * 'none' (the default).
                     * @param scope Select what to sync. Enum: users,groups,both
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateJob(String schedule, String comment, String delete, Boolean enable_new, Boolean enabled, String remove_vanished, String scope) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("schedule", schedule);
                        parameters.put("comment", comment);
                        parameters.put("delete", delete);
                        parameters.put("enable-new", enable_new);
                        parameters.put("enabled", enabled);
                        parameters.put("remove-vanished", remove_vanished);
                        parameters.put("scope", scope);
                        return client.set("/cluster/jobs/realm-sync/" + this.id + "", parameters);
                    }

                    /**
                     * Update realm-sync job definition.
                     *
                     * @param schedule Backup schedule. The format is a subset
                     * of `systemd` calendar events.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateJob(String schedule) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("schedule", schedule);
                        return client.set("/cluster/jobs/realm-sync/" + this.id + "", parameters);
                    }

                }

                /**
                 * List configured realm-sync-jobs.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result syncjobIndex() throws JSONException {
                    return client.get("/cluster/jobs/realm-sync", null);
                }

            }

            public class PVEScheduleAnalyze {

                private final PveClient client;

                protected PVEScheduleAnalyze(PveClient client) {
                    this.client = client;

                }

                /**
                 * Returns a list of future schedule runtimes.
                 *
                 * @param schedule Job schedule. The format is a subset of
                 * `systemd` calendar events.
                 * @param iterations Number of event-iteration to simulate and
                 * return.
                 * @param starttime UNIX timestamp to start the calculation
                 * from. Defaults to the current time.
                 * @return Result
                 * @throws JSONException
                 */
                public Result scheduleAnalyze(String schedule, Integer iterations, Integer starttime) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("schedule", schedule);
                    parameters.put("iterations", iterations);
                    parameters.put("starttime", starttime);
                    return client.get("/cluster/jobs/schedule-analyze", parameters);
                }

                /**
                 * Returns a list of future schedule runtimes.
                 *
                 * @param schedule Job schedule. The format is a subset of
                 * `systemd` calendar events.
                 * @return Result
                 * @throws JSONException
                 */

                public Result scheduleAnalyze(String schedule) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("schedule", schedule);
                    return client.get("/cluster/jobs/schedule-analyze", parameters);
                }

            }

            /**
             * Index for jobs related endpoints.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/jobs", null);
            }

        }

        public class PVEMapping {

            private final PveClient client;

            protected PVEMapping(PveClient client) {
                this.client = client;

            }

            private PVEPci pci;

            public PVEPci getPci() {
                return pci == null ? (pci = new PVEPci(client)) : pci;
            }
            private PVEUsb usb;

            public PVEUsb getUsb() {
                return usb == null ? (usb = new PVEUsb(client)) : usb;
            }

            public class PVEPci {

                private final PveClient client;

                protected PVEPci(PveClient client) {
                    this.client = client;

                }

                public PVEIdItem get(Object id) {
                    return new PVEIdItem(client, id);
                }

                public class PVEIdItem {

                    private final PveClient client;
                    private final Object id;

                    protected PVEIdItem(PveClient client, Object id) {
                        this.client = client;
                        this.id = id;
                    }

                    /**
                     * Remove Hardware Mapping.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result delete() throws JSONException {
                        return client.delete("/cluster/mapping/pci/" + this.id + "", null);
                    }

                    /**
                     * Get PCI Mapping.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result get() throws JSONException {
                        return client.get("/cluster/mapping/pci/" + this.id + "", null);
                    }

                    /**
                     * Update a hardware mapping.
                     *
                     * @param delete A list of settings you want to delete.
                     * @param description Description of the logical PCI device.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param map A list of maps for the cluster nodes.
                     * @param mdev
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(String delete, String description, String digest, String map, Boolean mdev) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("delete", delete);
                        parameters.put("description", description);
                        parameters.put("digest", digest);
                        parameters.put("map", map);
                        parameters.put("mdev", mdev);
                        return client.set("/cluster/mapping/pci/" + this.id + "", parameters);
                    }

                    /**
                     * Update a hardware mapping.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update() throws JSONException {
                        return client.set("/cluster/mapping/pci/" + this.id + "", null);
                    }

                }

                /**
                 * List PCI Hardware Mapping
                 *
                 * @param check_node If given, checks the configurations on the
                 * given node for correctness, and adds relevant diagnostics for
                 * the devices to the response.
                 * @return Result
                 * @throws JSONException
                 */
                public Result index(String check_node) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("check-node", check_node);
                    return client.get("/cluster/mapping/pci", parameters);
                }

                /**
                 * List PCI Hardware Mapping
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result index() throws JSONException {
                    return client.get("/cluster/mapping/pci", null);
                }

                /**
                 * Create a new hardware mapping.
                 *
                 * @param id The ID of the logical PCI mapping.
                 * @param map A list of maps for the cluster nodes.
                 * @param description Description of the logical PCI device.
                 * @param mdev
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String id, String map, String description, Boolean mdev) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("id", id);
                    parameters.put("map", map);
                    parameters.put("description", description);
                    parameters.put("mdev", mdev);
                    return client.create("/cluster/mapping/pci", parameters);
                }

                /**
                 * Create a new hardware mapping.
                 *
                 * @param id The ID of the logical PCI mapping.
                 * @param map A list of maps for the cluster nodes.
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String id, String map) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("id", id);
                    parameters.put("map", map);
                    return client.create("/cluster/mapping/pci", parameters);
                }

            }

            public class PVEUsb {

                private final PveClient client;

                protected PVEUsb(PveClient client) {
                    this.client = client;

                }

                public PVEIdItem get(Object id) {
                    return new PVEIdItem(client, id);
                }

                public class PVEIdItem {

                    private final PveClient client;
                    private final Object id;

                    protected PVEIdItem(PveClient client, Object id) {
                        this.client = client;
                        this.id = id;
                    }

                    /**
                     * Remove Hardware Mapping.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result delete() throws JSONException {
                        return client.delete("/cluster/mapping/usb/" + this.id + "", null);
                    }

                    /**
                     * Get USB Mapping.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result get() throws JSONException {
                        return client.get("/cluster/mapping/usb/" + this.id + "", null);
                    }

                    /**
                     * Update a hardware mapping.
                     *
                     * @param map A list of maps for the cluster nodes.
                     * @param delete A list of settings you want to delete.
                     * @param description Description of the logical USB device.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(String map, String delete, String description, String digest) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("map", map);
                        parameters.put("delete", delete);
                        parameters.put("description", description);
                        parameters.put("digest", digest);
                        return client.set("/cluster/mapping/usb/" + this.id + "", parameters);
                    }

                    /**
                     * Update a hardware mapping.
                     *
                     * @param map A list of maps for the cluster nodes.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(String map) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("map", map);
                        return client.set("/cluster/mapping/usb/" + this.id + "", parameters);
                    }

                }

                /**
                 * List USB Hardware Mappings
                 *
                 * @param check_node If given, checks the configurations on the
                 * given node for correctness, and adds relevant errors to the
                 * devices.
                 * @return Result
                 * @throws JSONException
                 */
                public Result index(String check_node) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("check-node", check_node);
                    return client.get("/cluster/mapping/usb", parameters);
                }

                /**
                 * List USB Hardware Mappings
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result index() throws JSONException {
                    return client.get("/cluster/mapping/usb", null);
                }

                /**
                 * Create a new hardware mapping.
                 *
                 * @param id The ID of the logical USB mapping.
                 * @param map A list of maps for the cluster nodes.
                 * @param description Description of the logical USB device.
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String id, String map, String description) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("id", id);
                    parameters.put("map", map);
                    parameters.put("description", description);
                    return client.create("/cluster/mapping/usb", parameters);
                }

                /**
                 * Create a new hardware mapping.
                 *
                 * @param id The ID of the logical USB mapping.
                 * @param map A list of maps for the cluster nodes.
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String id, String map) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("id", id);
                    parameters.put("map", map);
                    return client.create("/cluster/mapping/usb", parameters);
                }

            }

            /**
             * List resource types.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/mapping", null);
            }

        }

        public class PVESdn {

            private final PveClient client;

            protected PVESdn(PveClient client) {
                this.client = client;

            }

            private PVEVnets vnets;

            public PVEVnets getVnets() {
                return vnets == null ? (vnets = new PVEVnets(client)) : vnets;
            }
            private PVEZones zones;

            public PVEZones getZones() {
                return zones == null ? (zones = new PVEZones(client)) : zones;
            }
            private PVEControllers controllers;

            public PVEControllers getControllers() {
                return controllers == null ? (controllers = new PVEControllers(client)) : controllers;
            }
            private PVEIpams ipams;

            public PVEIpams getIpams() {
                return ipams == null ? (ipams = new PVEIpams(client)) : ipams;
            }
            private PVEDns dns;

            public PVEDns getDns() {
                return dns == null ? (dns = new PVEDns(client)) : dns;
            }

            public class PVEVnets {

                private final PveClient client;

                protected PVEVnets(PveClient client) {
                    this.client = client;

                }

                public PVEVnetItem get(Object vnet) {
                    return new PVEVnetItem(client, vnet);
                }

                public class PVEVnetItem {

                    private final PveClient client;
                    private final Object vnet;

                    protected PVEVnetItem(PveClient client, Object vnet) {
                        this.client = client;
                        this.vnet = vnet;
                    }

                    private PVESubnets subnets;

                    public PVESubnets getSubnets() {
                        return subnets == null ? (subnets = new PVESubnets(client, this.vnet)) : subnets;
                    }
                    private PVEIps ips;

                    public PVEIps getIps() {
                        return ips == null ? (ips = new PVEIps(client, this.vnet)) : ips;
                    }

                    public class PVESubnets {

                        private final PveClient client;
                        private final Object vnet;

                        protected PVESubnets(PveClient client, Object vnet) {
                            this.client = client;
                            this.vnet = vnet;
                        }

                        public PVESubnetItem get(Object subnet) {
                            return new PVESubnetItem(client, this.vnet, subnet);
                        }

                        public class PVESubnetItem {

                            private final PveClient client;
                            private final Object vnet;
                            private final Object subnet;

                            protected PVESubnetItem(PveClient client, Object vnet, Object subnet) {
                                this.client = client;
                                this.vnet = vnet;
                                this.subnet = subnet;
                            }

                            /**
                             * Delete sdn subnet object configuration.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result delete() throws JSONException {
                                return client.delete("/cluster/sdn/vnets/" + this.vnet + "/subnets/" + this.subnet + "", null);
                            }

                            /**
                             * Read sdn subnet configuration.
                             *
                             * @param pending Display pending config.
                             * @param running Display running config.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result read(Boolean pending, Boolean running) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("pending", pending);
                                parameters.put("running", running);
                                return client.get("/cluster/sdn/vnets/" + this.vnet + "/subnets/" + this.subnet + "", parameters);
                            }

                            /**
                             * Read sdn subnet configuration.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result read() throws JSONException {
                                return client.get("/cluster/sdn/vnets/" + this.vnet + "/subnets/" + this.subnet + "", null);
                            }

                            /**
                             * Update sdn subnet object configuration.
                             *
                             * @param delete A list of settings you want to
                             * delete.
                             * @param dhcp_dns_server IP address for the DNS
                             * server
                             * @param dhcp_range A list of DHCP ranges for this
                             * subnet
                             * @param digest Prevent changes if current
                             * configuration file has a different digest. This
                             * can be used to prevent concurrent modifications.
                             * @param dnszoneprefix dns domain zone prefix ex:
                             * 'adm' -&amp;gt;
                             * &amp;lt;hostname&amp;gt;.adm.mydomain.com
                             * @param gateway Subnet Gateway: Will be assign on
                             * vnet for layer3 zones
                             * @param snat enable masquerade for this subnet if
                             * pve-firewall
                             * @return Result
                             * @throws JSONException
                             */

                            public Result update(String delete, String dhcp_dns_server, String dhcp_range, String digest, String dnszoneprefix, String gateway, Boolean snat) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("delete", delete);
                                parameters.put("dhcp-dns-server", dhcp_dns_server);
                                parameters.put("dhcp-range", dhcp_range);
                                parameters.put("digest", digest);
                                parameters.put("dnszoneprefix", dnszoneprefix);
                                parameters.put("gateway", gateway);
                                parameters.put("snat", snat);
                                return client.set("/cluster/sdn/vnets/" + this.vnet + "/subnets/" + this.subnet + "", parameters);
                            }

                            /**
                             * Update sdn subnet object configuration.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result update() throws JSONException {
                                return client.set("/cluster/sdn/vnets/" + this.vnet + "/subnets/" + this.subnet + "", null);
                            }

                        }

                        /**
                         * SDN subnets index.
                         *
                         * @param pending Display pending config.
                         * @param running Display running config.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result index(Boolean pending, Boolean running) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("pending", pending);
                            parameters.put("running", running);
                            return client.get("/cluster/sdn/vnets/" + this.vnet + "/subnets", parameters);
                        }

                        /**
                         * SDN subnets index.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result index() throws JSONException {
                            return client.get("/cluster/sdn/vnets/" + this.vnet + "/subnets", null);
                        }

                        /**
                         * Create a new sdn subnet object.
                         *
                         * @param subnet The SDN subnet object identifier.
                         * @param type Enum: subnet
                         * @param dhcp_dns_server IP address for the DNS server
                         * @param dhcp_range A list of DHCP ranges for this
                         * subnet
                         * @param dnszoneprefix dns domain zone prefix ex: 'adm'
                         * -&amp;gt; &amp;lt;hostname&amp;gt;.adm.mydomain.com
                         * @param gateway Subnet Gateway: Will be assign on vnet
                         * for layer3 zones
                         * @param snat enable masquerade for this subnet if
                         * pve-firewall
                         * @return Result
                         * @throws JSONException
                         */

                        public Result create(String subnet, String type, String dhcp_dns_server, String dhcp_range, String dnszoneprefix, String gateway, Boolean snat) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("subnet", subnet);
                            parameters.put("type", type);
                            parameters.put("dhcp-dns-server", dhcp_dns_server);
                            parameters.put("dhcp-range", dhcp_range);
                            parameters.put("dnszoneprefix", dnszoneprefix);
                            parameters.put("gateway", gateway);
                            parameters.put("snat", snat);
                            return client.create("/cluster/sdn/vnets/" + this.vnet + "/subnets", parameters);
                        }

                        /**
                         * Create a new sdn subnet object.
                         *
                         * @param subnet The SDN subnet object identifier.
                         * @param type Enum: subnet
                         * @return Result
                         * @throws JSONException
                         */

                        public Result create(String subnet, String type) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("subnet", subnet);
                            parameters.put("type", type);
                            return client.create("/cluster/sdn/vnets/" + this.vnet + "/subnets", parameters);
                        }

                    }

                    public class PVEIps {

                        private final PveClient client;
                        private final Object vnet;

                        protected PVEIps(PveClient client, Object vnet) {
                            this.client = client;
                            this.vnet = vnet;
                        }

                        /**
                         * Delete IP Mappings in a VNet
                         *
                         * @param ip The IP address to delete
                         * @param zone The SDN zone object identifier.
                         * @param mac Unicast MAC address.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result ipdelete(String ip, String zone, String mac) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ip", ip);
                            parameters.put("zone", zone);
                            parameters.put("mac", mac);
                            return client.delete("/cluster/sdn/vnets/" + this.vnet + "/ips", parameters);
                        }

                        /**
                         * Delete IP Mappings in a VNet
                         *
                         * @param ip The IP address to delete
                         * @param zone The SDN zone object identifier.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result ipdelete(String ip, String zone) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ip", ip);
                            parameters.put("zone", zone);
                            return client.delete("/cluster/sdn/vnets/" + this.vnet + "/ips", parameters);
                        }

                        /**
                         * Create IP Mapping in a VNet
                         *
                         * @param ip The IP address to associate with the given
                         * MAC address
                         * @param zone The SDN zone object identifier.
                         * @param mac Unicast MAC address.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result ipcreate(String ip, String zone, String mac) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ip", ip);
                            parameters.put("zone", zone);
                            parameters.put("mac", mac);
                            return client.create("/cluster/sdn/vnets/" + this.vnet + "/ips", parameters);
                        }

                        /**
                         * Create IP Mapping in a VNet
                         *
                         * @param ip The IP address to associate with the given
                         * MAC address
                         * @param zone The SDN zone object identifier.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result ipcreate(String ip, String zone) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ip", ip);
                            parameters.put("zone", zone);
                            return client.create("/cluster/sdn/vnets/" + this.vnet + "/ips", parameters);
                        }

                        /**
                         * Update IP Mapping in a VNet
                         *
                         * @param ip The IP address to associate with the given
                         * MAC address
                         * @param zone The SDN zone object identifier.
                         * @param mac Unicast MAC address.
                         * @param vmid The (unique) ID of the VM.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result ipupdate(String ip, String zone, String mac, Integer vmid) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ip", ip);
                            parameters.put("zone", zone);
                            parameters.put("mac", mac);
                            parameters.put("vmid", vmid);
                            return client.set("/cluster/sdn/vnets/" + this.vnet + "/ips", parameters);
                        }

                        /**
                         * Update IP Mapping in a VNet
                         *
                         * @param ip The IP address to associate with the given
                         * MAC address
                         * @param zone The SDN zone object identifier.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result ipupdate(String ip, String zone) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ip", ip);
                            parameters.put("zone", zone);
                            return client.set("/cluster/sdn/vnets/" + this.vnet + "/ips", parameters);
                        }

                    }

                    /**
                     * Delete sdn vnet object configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result delete() throws JSONException {
                        return client.delete("/cluster/sdn/vnets/" + this.vnet + "", null);
                    }

                    /**
                     * Read sdn vnet configuration.
                     *
                     * @param pending Display pending config.
                     * @param running Display running config.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result read(Boolean pending, Boolean running) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("pending", pending);
                        parameters.put("running", running);
                        return client.get("/cluster/sdn/vnets/" + this.vnet + "", parameters);
                    }

                    /**
                     * Read sdn vnet configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result read() throws JSONException {
                        return client.get("/cluster/sdn/vnets/" + this.vnet + "", null);
                    }

                    /**
                     * Update sdn vnet object configuration.
                     *
                     * @param alias alias name of the vnet
                     * @param delete A list of settings you want to delete.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param tag vlan or vxlan id
                     * @param vlanaware Allow vm VLANs to pass through this
                     * vnet.
                     * @param zone zone id
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(String alias, String delete, String digest, Integer tag, Boolean vlanaware, String zone) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("alias", alias);
                        parameters.put("delete", delete);
                        parameters.put("digest", digest);
                        parameters.put("tag", tag);
                        parameters.put("vlanaware", vlanaware);
                        parameters.put("zone", zone);
                        return client.set("/cluster/sdn/vnets/" + this.vnet + "", parameters);
                    }

                    /**
                     * Update sdn vnet object configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update() throws JSONException {
                        return client.set("/cluster/sdn/vnets/" + this.vnet + "", null);
                    }

                }

                /**
                 * SDN vnets index.
                 *
                 * @param pending Display pending config.
                 * @param running Display running config.
                 * @return Result
                 * @throws JSONException
                 */
                public Result index(Boolean pending, Boolean running) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("pending", pending);
                    parameters.put("running", running);
                    return client.get("/cluster/sdn/vnets", parameters);
                }

                /**
                 * SDN vnets index.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result index() throws JSONException {
                    return client.get("/cluster/sdn/vnets", null);
                }

                /**
                 * Create a new sdn vnet object.
                 *
                 * @param vnet The SDN vnet object identifier.
                 * @param zone zone id
                 * @param alias alias name of the vnet
                 * @param tag vlan or vxlan id
                 * @param type Type Enum: vnet
                 * @param vlanaware Allow vm VLANs to pass through this vnet.
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String vnet, String zone, String alias, Integer tag, String type, Boolean vlanaware) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("vnet", vnet);
                    parameters.put("zone", zone);
                    parameters.put("alias", alias);
                    parameters.put("tag", tag);
                    parameters.put("type", type);
                    parameters.put("vlanaware", vlanaware);
                    return client.create("/cluster/sdn/vnets", parameters);
                }

                /**
                 * Create a new sdn vnet object.
                 *
                 * @param vnet The SDN vnet object identifier.
                 * @param zone zone id
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String vnet, String zone) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("vnet", vnet);
                    parameters.put("zone", zone);
                    return client.create("/cluster/sdn/vnets", parameters);
                }

            }

            public class PVEZones {

                private final PveClient client;

                protected PVEZones(PveClient client) {
                    this.client = client;

                }

                public PVEZoneItem get(Object zone) {
                    return new PVEZoneItem(client, zone);
                }

                public class PVEZoneItem {

                    private final PveClient client;
                    private final Object zone;

                    protected PVEZoneItem(PveClient client, Object zone) {
                        this.client = client;
                        this.zone = zone;
                    }

                    /**
                     * Delete sdn zone object configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result delete() throws JSONException {
                        return client.delete("/cluster/sdn/zones/" + this.zone + "", null);
                    }

                    /**
                     * Read sdn zone configuration.
                     *
                     * @param pending Display pending config.
                     * @param running Display running config.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result read(Boolean pending, Boolean running) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("pending", pending);
                        parameters.put("running", running);
                        return client.get("/cluster/sdn/zones/" + this.zone + "", parameters);
                    }

                    /**
                     * Read sdn zone configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result read() throws JSONException {
                        return client.get("/cluster/sdn/zones/" + this.zone + "", null);
                    }

                    /**
                     * Update sdn zone object configuration.
                     *
                     * @param advertise_subnets Advertise evpn subnets if you
                     * have silent hosts
                     * @param bridge
                     * @param bridge_disable_mac_learning Disable auto mac
                     * learning.
                     * @param controller Frr router name
                     * @param delete A list of settings you want to delete.
                     * @param dhcp Type of the DHCP backend for this zone Enum:
                     * dnsmasq
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param disable_arp_nd_suppression Disable ipv4 arp
                     * &amp;&amp; ipv6 neighbour discovery suppression
                     * @param dns dns api server
                     * @param dnszone dns domain zone ex: mydomain.com
                     * @param dp_id Faucet dataplane id
                     * @param exitnodes List of cluster node names.
                     * @param exitnodes_local_routing Allow exitnodes to connect
                     * to evpn guests
                     * @param exitnodes_primary Force traffic to this exitnode
                     * first.
                     * @param ipam use a specific ipam
                     * @param mac Anycast logical router mac address
                     * @param mtu MTU
                     * @param nodes List of cluster node names.
                     * @param peers peers address list.
                     * @param reversedns reverse dns api server
                     * @param rt_import Route-Target import
                     * @param tag Service-VLAN Tag
                     * @param vlan_protocol Enum: 802.1q,802.1ad
                     * @param vrf_vxlan l3vni.
                     * @param vxlan_port Vxlan tunnel udp port (default 4789).
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(Boolean advertise_subnets, String bridge, Boolean bridge_disable_mac_learning, String controller, String delete, String dhcp, String digest, Boolean disable_arp_nd_suppression, String dns, String dnszone, Integer dp_id, String exitnodes, Boolean exitnodes_local_routing, String exitnodes_primary, String ipam, String mac, Integer mtu, String nodes, String peers, String reversedns, String rt_import, Integer tag, String vlan_protocol, Integer vrf_vxlan, Integer vxlan_port) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("advertise-subnets", advertise_subnets);
                        parameters.put("bridge", bridge);
                        parameters.put("bridge-disable-mac-learning", bridge_disable_mac_learning);
                        parameters.put("controller", controller);
                        parameters.put("delete", delete);
                        parameters.put("dhcp", dhcp);
                        parameters.put("digest", digest);
                        parameters.put("disable-arp-nd-suppression", disable_arp_nd_suppression);
                        parameters.put("dns", dns);
                        parameters.put("dnszone", dnszone);
                        parameters.put("dp-id", dp_id);
                        parameters.put("exitnodes", exitnodes);
                        parameters.put("exitnodes-local-routing", exitnodes_local_routing);
                        parameters.put("exitnodes-primary", exitnodes_primary);
                        parameters.put("ipam", ipam);
                        parameters.put("mac", mac);
                        parameters.put("mtu", mtu);
                        parameters.put("nodes", nodes);
                        parameters.put("peers", peers);
                        parameters.put("reversedns", reversedns);
                        parameters.put("rt-import", rt_import);
                        parameters.put("tag", tag);
                        parameters.put("vlan-protocol", vlan_protocol);
                        parameters.put("vrf-vxlan", vrf_vxlan);
                        parameters.put("vxlan-port", vxlan_port);
                        return client.set("/cluster/sdn/zones/" + this.zone + "", parameters);
                    }

                    /**
                     * Update sdn zone object configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update() throws JSONException {
                        return client.set("/cluster/sdn/zones/" + this.zone + "", null);
                    }

                }

                /**
                 * SDN zones index.
                 *
                 * @param pending Display pending config.
                 * @param running Display running config.
                 * @param type Only list SDN zones of specific type Enum:
                 * evpn,faucet,qinq,simple,vlan,vxlan
                 * @return Result
                 * @throws JSONException
                 */
                public Result index(Boolean pending, Boolean running, String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("pending", pending);
                    parameters.put("running", running);
                    parameters.put("type", type);
                    return client.get("/cluster/sdn/zones", parameters);
                }

                /**
                 * SDN zones index.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result index() throws JSONException {
                    return client.get("/cluster/sdn/zones", null);
                }

                /**
                 * Create a new sdn zone object.
                 *
                 * @param type Plugin type. Enum:
                 * evpn,faucet,qinq,simple,vlan,vxlan
                 * @param zone The SDN zone object identifier.
                 * @param advertise_subnets Advertise evpn subnets if you have
                 * silent hosts
                 * @param bridge
                 * @param bridge_disable_mac_learning Disable auto mac learning.
                 * @param controller Frr router name
                 * @param dhcp Type of the DHCP backend for this zone Enum:
                 * dnsmasq
                 * @param disable_arp_nd_suppression Disable ipv4 arp &amp;&amp;
                 * ipv6 neighbour discovery suppression
                 * @param dns dns api server
                 * @param dnszone dns domain zone ex: mydomain.com
                 * @param dp_id Faucet dataplane id
                 * @param exitnodes List of cluster node names.
                 * @param exitnodes_local_routing Allow exitnodes to connect to
                 * evpn guests
                 * @param exitnodes_primary Force traffic to this exitnode
                 * first.
                 * @param ipam use a specific ipam
                 * @param mac Anycast logical router mac address
                 * @param mtu MTU
                 * @param nodes List of cluster node names.
                 * @param peers peers address list.
                 * @param reversedns reverse dns api server
                 * @param rt_import Route-Target import
                 * @param tag Service-VLAN Tag
                 * @param vlan_protocol Enum: 802.1q,802.1ad
                 * @param vrf_vxlan l3vni.
                 * @param vxlan_port Vxlan tunnel udp port (default 4789).
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String type, String zone, Boolean advertise_subnets, String bridge, Boolean bridge_disable_mac_learning, String controller, String dhcp, Boolean disable_arp_nd_suppression, String dns, String dnszone, Integer dp_id, String exitnodes, Boolean exitnodes_local_routing, String exitnodes_primary, String ipam, String mac, Integer mtu, String nodes, String peers, String reversedns, String rt_import, Integer tag, String vlan_protocol, Integer vrf_vxlan, Integer vxlan_port) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("type", type);
                    parameters.put("zone", zone);
                    parameters.put("advertise-subnets", advertise_subnets);
                    parameters.put("bridge", bridge);
                    parameters.put("bridge-disable-mac-learning", bridge_disable_mac_learning);
                    parameters.put("controller", controller);
                    parameters.put("dhcp", dhcp);
                    parameters.put("disable-arp-nd-suppression", disable_arp_nd_suppression);
                    parameters.put("dns", dns);
                    parameters.put("dnszone", dnszone);
                    parameters.put("dp-id", dp_id);
                    parameters.put("exitnodes", exitnodes);
                    parameters.put("exitnodes-local-routing", exitnodes_local_routing);
                    parameters.put("exitnodes-primary", exitnodes_primary);
                    parameters.put("ipam", ipam);
                    parameters.put("mac", mac);
                    parameters.put("mtu", mtu);
                    parameters.put("nodes", nodes);
                    parameters.put("peers", peers);
                    parameters.put("reversedns", reversedns);
                    parameters.put("rt-import", rt_import);
                    parameters.put("tag", tag);
                    parameters.put("vlan-protocol", vlan_protocol);
                    parameters.put("vrf-vxlan", vrf_vxlan);
                    parameters.put("vxlan-port", vxlan_port);
                    return client.create("/cluster/sdn/zones", parameters);
                }

                /**
                 * Create a new sdn zone object.
                 *
                 * @param type Plugin type. Enum:
                 * evpn,faucet,qinq,simple,vlan,vxlan
                 * @param zone The SDN zone object identifier.
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String type, String zone) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("type", type);
                    parameters.put("zone", zone);
                    return client.create("/cluster/sdn/zones", parameters);
                }

            }

            public class PVEControllers {

                private final PveClient client;

                protected PVEControllers(PveClient client) {
                    this.client = client;

                }

                public PVEControllerItem get(Object controller) {
                    return new PVEControllerItem(client, controller);
                }

                public class PVEControllerItem {

                    private final PveClient client;
                    private final Object controller;

                    protected PVEControllerItem(PveClient client, Object controller) {
                        this.client = client;
                        this.controller = controller;
                    }

                    /**
                     * Delete sdn controller object configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result delete() throws JSONException {
                        return client.delete("/cluster/sdn/controllers/" + this.controller + "", null);
                    }

                    /**
                     * Read sdn controller configuration.
                     *
                     * @param pending Display pending config.
                     * @param running Display running config.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result read(Boolean pending, Boolean running) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("pending", pending);
                        parameters.put("running", running);
                        return client.get("/cluster/sdn/controllers/" + this.controller + "", parameters);
                    }

                    /**
                     * Read sdn controller configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result read() throws JSONException {
                        return client.get("/cluster/sdn/controllers/" + this.controller + "", null);
                    }

                    /**
                     * Update sdn controller object configuration.
                     *
                     * @param asn autonomous system number
                     * @param bgp_multipath_as_path_relax
                     * @param delete A list of settings you want to delete.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param ebgp Enable ebgp. (remote-as external)
                     * @param ebgp_multihop
                     * @param isis_domain ISIS domain.
                     * @param isis_ifaces ISIS interface.
                     * @param isis_net ISIS network entity title.
                     * @param loopback source loopback interface.
                     * @param node The cluster node name.
                     * @param peers peers address list.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(Integer asn, Boolean bgp_multipath_as_path_relax, String delete, String digest, Boolean ebgp, Integer ebgp_multihop, String isis_domain, String isis_ifaces, String isis_net, String loopback, String node, String peers) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("asn", asn);
                        parameters.put("bgp-multipath-as-path-relax", bgp_multipath_as_path_relax);
                        parameters.put("delete", delete);
                        parameters.put("digest", digest);
                        parameters.put("ebgp", ebgp);
                        parameters.put("ebgp-multihop", ebgp_multihop);
                        parameters.put("isis-domain", isis_domain);
                        parameters.put("isis-ifaces", isis_ifaces);
                        parameters.put("isis-net", isis_net);
                        parameters.put("loopback", loopback);
                        parameters.put("node", node);
                        parameters.put("peers", peers);
                        return client.set("/cluster/sdn/controllers/" + this.controller + "", parameters);
                    }

                    /**
                     * Update sdn controller object configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update() throws JSONException {
                        return client.set("/cluster/sdn/controllers/" + this.controller + "", null);
                    }

                }

                /**
                 * SDN controllers index.
                 *
                 * @param pending Display pending config.
                 * @param running Display running config.
                 * @param type Only list sdn controllers of specific type Enum:
                 * bgp,evpn,faucet,isis
                 * @return Result
                 * @throws JSONException
                 */
                public Result index(Boolean pending, Boolean running, String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("pending", pending);
                    parameters.put("running", running);
                    parameters.put("type", type);
                    return client.get("/cluster/sdn/controllers", parameters);
                }

                /**
                 * SDN controllers index.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result index() throws JSONException {
                    return client.get("/cluster/sdn/controllers", null);
                }

                /**
                 * Create a new sdn controller object.
                 *
                 * @param controller The SDN controller object identifier.
                 * @param type Plugin type. Enum: bgp,evpn,faucet,isis
                 * @param asn autonomous system number
                 * @param bgp_multipath_as_path_relax
                 * @param ebgp Enable ebgp. (remote-as external)
                 * @param ebgp_multihop
                 * @param isis_domain ISIS domain.
                 * @param isis_ifaces ISIS interface.
                 * @param isis_net ISIS network entity title.
                 * @param loopback source loopback interface.
                 * @param node The cluster node name.
                 * @param peers peers address list.
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String controller, String type, Integer asn, Boolean bgp_multipath_as_path_relax, Boolean ebgp, Integer ebgp_multihop, String isis_domain, String isis_ifaces, String isis_net, String loopback, String node, String peers) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("controller", controller);
                    parameters.put("type", type);
                    parameters.put("asn", asn);
                    parameters.put("bgp-multipath-as-path-relax", bgp_multipath_as_path_relax);
                    parameters.put("ebgp", ebgp);
                    parameters.put("ebgp-multihop", ebgp_multihop);
                    parameters.put("isis-domain", isis_domain);
                    parameters.put("isis-ifaces", isis_ifaces);
                    parameters.put("isis-net", isis_net);
                    parameters.put("loopback", loopback);
                    parameters.put("node", node);
                    parameters.put("peers", peers);
                    return client.create("/cluster/sdn/controllers", parameters);
                }

                /**
                 * Create a new sdn controller object.
                 *
                 * @param controller The SDN controller object identifier.
                 * @param type Plugin type. Enum: bgp,evpn,faucet,isis
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String controller, String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("controller", controller);
                    parameters.put("type", type);
                    return client.create("/cluster/sdn/controllers", parameters);
                }

            }

            public class PVEIpams {

                private final PveClient client;

                protected PVEIpams(PveClient client) {
                    this.client = client;

                }

                public PVEIpamItem get(Object ipam) {
                    return new PVEIpamItem(client, ipam);
                }

                public class PVEIpamItem {

                    private final PveClient client;
                    private final Object ipam;

                    protected PVEIpamItem(PveClient client, Object ipam) {
                        this.client = client;
                        this.ipam = ipam;
                    }

                    private PVEStatus status;

                    public PVEStatus getStatus() {
                        return status == null ? (status = new PVEStatus(client, this.ipam)) : status;
                    }

                    public class PVEStatus {

                        private final PveClient client;
                        private final Object ipam;

                        protected PVEStatus(PveClient client, Object ipam) {
                            this.client = client;
                            this.ipam = ipam;
                        }

                        /**
                         * List PVE IPAM Entries
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result ipamindex() throws JSONException {
                            return client.get("/cluster/sdn/ipams/" + this.ipam + "/status", null);
                        }

                    }

                    /**
                     * Delete sdn ipam object configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result delete() throws JSONException {
                        return client.delete("/cluster/sdn/ipams/" + this.ipam + "", null);
                    }

                    /**
                     * Read sdn ipam configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result read() throws JSONException {
                        return client.get("/cluster/sdn/ipams/" + this.ipam + "", null);
                    }

                    /**
                     * Update sdn ipam object configuration.
                     *
                     * @param delete A list of settings you want to delete.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param section
                     * @param token
                     * @param url
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(String delete, String digest, Integer section, String token, String url) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("delete", delete);
                        parameters.put("digest", digest);
                        parameters.put("section", section);
                        parameters.put("token", token);
                        parameters.put("url", url);
                        return client.set("/cluster/sdn/ipams/" + this.ipam + "", parameters);
                    }

                    /**
                     * Update sdn ipam object configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update() throws JSONException {
                        return client.set("/cluster/sdn/ipams/" + this.ipam + "", null);
                    }

                }

                /**
                 * SDN ipams index.
                 *
                 * @param type Only list sdn ipams of specific type Enum:
                 * netbox,phpipam,pve
                 * @return Result
                 * @throws JSONException
                 */
                public Result index(String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("type", type);
                    return client.get("/cluster/sdn/ipams", parameters);
                }

                /**
                 * SDN ipams index.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result index() throws JSONException {
                    return client.get("/cluster/sdn/ipams", null);
                }

                /**
                 * Create a new sdn ipam object.
                 *
                 * @param ipam The SDN ipam object identifier.
                 * @param type Plugin type. Enum: netbox,phpipam,pve
                 * @param section
                 * @param token
                 * @param url
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String ipam, String type, Integer section, String token, String url) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("ipam", ipam);
                    parameters.put("type", type);
                    parameters.put("section", section);
                    parameters.put("token", token);
                    parameters.put("url", url);
                    return client.create("/cluster/sdn/ipams", parameters);
                }

                /**
                 * Create a new sdn ipam object.
                 *
                 * @param ipam The SDN ipam object identifier.
                 * @param type Plugin type. Enum: netbox,phpipam,pve
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String ipam, String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("ipam", ipam);
                    parameters.put("type", type);
                    return client.create("/cluster/sdn/ipams", parameters);
                }

            }

            public class PVEDns {

                private final PveClient client;

                protected PVEDns(PveClient client) {
                    this.client = client;

                }

                public PVEDnsItem get(Object dns) {
                    return new PVEDnsItem(client, dns);
                }

                public class PVEDnsItem {

                    private final PveClient client;
                    private final Object dns;

                    protected PVEDnsItem(PveClient client, Object dns) {
                        this.client = client;
                        this.dns = dns;
                    }

                    /**
                     * Delete sdn dns object configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result delete() throws JSONException {
                        return client.delete("/cluster/sdn/dns/" + this.dns + "", null);
                    }

                    /**
                     * Read sdn dns configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result read() throws JSONException {
                        return client.get("/cluster/sdn/dns/" + this.dns + "", null);
                    }

                    /**
                     * Update sdn dns object configuration.
                     *
                     * @param delete A list of settings you want to delete.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param key
                     * @param reversemaskv6
                     * @param ttl
                     * @param url
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update(String delete, String digest, String key, Integer reversemaskv6, Integer ttl, String url) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("delete", delete);
                        parameters.put("digest", digest);
                        parameters.put("key", key);
                        parameters.put("reversemaskv6", reversemaskv6);
                        parameters.put("ttl", ttl);
                        parameters.put("url", url);
                        return client.set("/cluster/sdn/dns/" + this.dns + "", parameters);
                    }

                    /**
                     * Update sdn dns object configuration.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result update() throws JSONException {
                        return client.set("/cluster/sdn/dns/" + this.dns + "", null);
                    }

                }

                /**
                 * SDN dns index.
                 *
                 * @param type Only list sdn dns of specific type Enum: powerdns
                 * @return Result
                 * @throws JSONException
                 */
                public Result index(String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("type", type);
                    return client.get("/cluster/sdn/dns", parameters);
                }

                /**
                 * SDN dns index.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result index() throws JSONException {
                    return client.get("/cluster/sdn/dns", null);
                }

                /**
                 * Create a new sdn dns object.
                 *
                 * @param dns The SDN dns object identifier.
                 * @param key
                 * @param type Plugin type. Enum: powerdns
                 * @param url
                 * @param reversemaskv6
                 * @param reversev6mask
                 * @param ttl
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String dns, String key, String type, String url, Integer reversemaskv6, Integer reversev6mask, Integer ttl) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("dns", dns);
                    parameters.put("key", key);
                    parameters.put("type", type);
                    parameters.put("url", url);
                    parameters.put("reversemaskv6", reversemaskv6);
                    parameters.put("reversev6mask", reversev6mask);
                    parameters.put("ttl", ttl);
                    return client.create("/cluster/sdn/dns", parameters);
                }

                /**
                 * Create a new sdn dns object.
                 *
                 * @param dns The SDN dns object identifier.
                 * @param key
                 * @param type Plugin type. Enum: powerdns
                 * @param url
                 * @return Result
                 * @throws JSONException
                 */

                public Result create(String dns, String key, String type, String url) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("dns", dns);
                    parameters.put("key", key);
                    parameters.put("type", type);
                    parameters.put("url", url);
                    return client.create("/cluster/sdn/dns", parameters);
                }

            }

            /**
             * Directory index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/cluster/sdn", null);
            }

            /**
             * Apply sdn controller changes &amp;&amp; reload.
             *
             * @return Result
             * @throws JSONException
             */

            public Result reload() throws JSONException {
                return client.set("/cluster/sdn", null);
            }

        }

        public class PVELog {

            private final PveClient client;

            protected PVELog(PveClient client) {
                this.client = client;

            }

            /**
             * Read cluster log
             *
             * @param max Maximum number of entries.
             * @return Result
             * @throws JSONException
             */
            public Result log(Integer max) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("max", max);
                return client.get("/cluster/log", parameters);
            }

            /**
             * Read cluster log
             *
             * @return Result
             * @throws JSONException
             */

            public Result log() throws JSONException {
                return client.get("/cluster/log", null);
            }

        }

        public class PVEResources {

            private final PveClient client;

            protected PVEResources(PveClient client) {
                this.client = client;

            }

            /**
             * Resources index (cluster wide).
             *
             * @param type Enum: vm,storage,node,sdn
             * @return Result
             * @throws JSONException
             */
            public Result resources(String type) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("type", type);
                return client.get("/cluster/resources", parameters);
            }

            /**
             * Resources index (cluster wide).
             *
             * @return Result
             * @throws JSONException
             */

            public Result resources() throws JSONException {
                return client.get("/cluster/resources", null);
            }

        }

        public class PVETasks {

            private final PveClient client;

            protected PVETasks(PveClient client) {
                this.client = client;

            }

            /**
             * List recent tasks (cluster wide).
             *
             * @return Result
             * @throws JSONException
             */
            public Result tasks() throws JSONException {
                return client.get("/cluster/tasks", null);
            }

        }

        public class PVEOptions {

            private final PveClient client;

            protected PVEOptions(PveClient client) {
                this.client = client;

            }

            /**
             * Get datacenter options. Without 'Sys.Audit' on '/' not all
             * options are returned.
             *
             * @return Result
             * @throws JSONException
             */
            public Result getOptions() throws JSONException {
                return client.get("/cluster/options", null);
            }

            /**
             * Set datacenter options.
             *
             * @param bwlimit Set I/O bandwidth limit for various operations (in
             * KiB/s).
             * @param console Select the default Console viewer. You can either
             * use the builtin java applet (VNC; deprecated and maps to html5),
             * an external virt-viewer comtatible application (SPICE), an HTML5
             * based vnc viewer (noVNC), or an HTML5 based console client
             * (xtermjs). If the selected viewer is not available (e.g. SPICE
             * not activated for the VM), the fallback is noVNC. Enum:
             * applet,vv,html5,xtermjs
             * @param crs Cluster resource scheduling settings.
             * @param delete A list of settings you want to delete.
             * @param description Datacenter description. Shown in the
             * web-interface datacenter notes panel. This is saved as comment
             * inside the configuration file.
             * @param email_from Specify email address to send notification from
             * (default is root@$hostname)
             * @param fencing Set the fencing mode of the HA cluster. Hardware
             * mode needs a valid configuration of fence devices in
             * /etc/pve/ha/fence.cfg. With both all two modes are used. WARNING:
             * 'hardware' and 'both' are EXPERIMENTAL &amp; WIP Enum:
             * watchdog,hardware,both
             * @param ha Cluster wide HA settings.
             * @param http_proxy Specify external http proxy which is used for
             * downloads (example: 'http://username:password@host:port/')
             * @param keyboard Default keybord layout for vnc server. Enum:
             * de,de-ch,da,en-gb,en-us,es,fi,fr,fr-be,fr-ca,fr-ch,hu,is,it,ja,lt,mk,nl,no,pl,pt,pt-br,sv,sl,tr
             * @param language Default GUI language. Enum:
             * ar,ca,da,de,en,es,eu,fa,fr,hr,he,it,ja,ka,kr,nb,nl,nn,pl,pt_BR,ru,sl,sv,tr,ukr,zh_CN,zh_TW
             * @param mac_prefix Prefix for the auto-generated MAC addresses of
             * virtual guests. The default 'BC:24:11' is the OUI assigned by the
             * IEEE to Proxmox Server Solutions GmbH for a 24-bit large MAC
             * block. You're allowed to use this in local networks, i.e., those
             * not directly reachable by the public (e.g., in a LAN or behind
             * NAT).
             * @param max_workers Defines how many workers (per node) are
             * maximal started on actions like 'stopall VMs' or task from the
             * ha-manager.
             * @param migration For cluster wide migration settings.
             * @param migration_unsecure Migration is secure using SSH tunnel by
             * default. For secure private networks you can disable it to speed
             * up migration. Deprecated, use the 'migration' property instead!
             * @param next_id Control the range for the free VMID auto-selection
             * pool.
             * @param notify Cluster-wide notification settings.
             * @param registered_tags A list of tags that require a `Sys.Modify`
             * on '/' to set and delete. Tags set here that are also in
             * 'user-tag-access' also require `Sys.Modify`.
             * @param tag_style Tag style options.
             * @param u2f u2f
             * @param user_tag_access Privilege options for user-settable tags
             * @param webauthn webauthn configuration
             * @return Result
             * @throws JSONException
             */

            public Result setOptions(String bwlimit, String console, String crs, String delete, String description, String email_from, String fencing, String ha, String http_proxy, String keyboard, String language, String mac_prefix, Integer max_workers, String migration, Boolean migration_unsecure, String next_id, String notify, String registered_tags, String tag_style, String u2f, String user_tag_access, String webauthn) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("bwlimit", bwlimit);
                parameters.put("console", console);
                parameters.put("crs", crs);
                parameters.put("delete", delete);
                parameters.put("description", description);
                parameters.put("email_from", email_from);
                parameters.put("fencing", fencing);
                parameters.put("ha", ha);
                parameters.put("http_proxy", http_proxy);
                parameters.put("keyboard", keyboard);
                parameters.put("language", language);
                parameters.put("mac_prefix", mac_prefix);
                parameters.put("max_workers", max_workers);
                parameters.put("migration", migration);
                parameters.put("migration_unsecure", migration_unsecure);
                parameters.put("next-id", next_id);
                parameters.put("notify", notify);
                parameters.put("registered-tags", registered_tags);
                parameters.put("tag-style", tag_style);
                parameters.put("u2f", u2f);
                parameters.put("user-tag-access", user_tag_access);
                parameters.put("webauthn", webauthn);
                return client.set("/cluster/options", parameters);
            }

            /**
             * Set datacenter options.
             *
             * @return Result
             * @throws JSONException
             */

            public Result setOptions() throws JSONException {
                return client.set("/cluster/options", null);
            }

        }

        public class PVEStatus {

            private final PveClient client;

            protected PVEStatus(PveClient client) {
                this.client = client;

            }

            /**
             * Get cluster status information.
             *
             * @return Result
             * @throws JSONException
             */
            public Result getStatus() throws JSONException {
                return client.get("/cluster/status", null);
            }

        }

        public class PVENextid {

            private final PveClient client;

            protected PVENextid(PveClient client) {
                this.client = client;

            }

            /**
             * Get next free VMID. Pass a VMID to assert that its free (at time
             * of check).
             *
             * @param vmid The (unique) ID of the VM.
             * @return Result
             * @throws JSONException
             */
            public Result nextid(Integer vmid) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("vmid", vmid);
                return client.get("/cluster/nextid", parameters);
            }

            /**
             * Get next free VMID. Pass a VMID to assert that its free (at time
             * of check).
             *
             * @return Result
             * @throws JSONException
             */

            public Result nextid() throws JSONException {
                return client.get("/cluster/nextid", null);
            }

        }

        /**
         * Cluster index.
         *
         * @return Result
         * @throws JSONException
         */
        public Result index() throws JSONException {
            return client.get("/cluster", null);
        }

    }

    public class PVENodes {

        private final PveClient client;

        protected PVENodes(PveClient client) {
            this.client = client;

        }

        public PVENodeItem get(Object node) {
            return new PVENodeItem(client, node);
        }

        public class PVENodeItem {

            private final PveClient client;
            private final Object node;

            protected PVENodeItem(PveClient client, Object node) {
                this.client = client;
                this.node = node;
            }

            private PVEQemu qemu;

            public PVEQemu getQemu() {
                return qemu == null ? (qemu = new PVEQemu(client, this.node)) : qemu;
            }
            private PVELxc lxc;

            public PVELxc getLxc() {
                return lxc == null ? (lxc = new PVELxc(client, this.node)) : lxc;
            }
            private PVECeph ceph;

            public PVECeph getCeph() {
                return ceph == null ? (ceph = new PVECeph(client, this.node)) : ceph;
            }
            private PVEVzdump vzdump;

            public PVEVzdump getVzdump() {
                return vzdump == null ? (vzdump = new PVEVzdump(client, this.node)) : vzdump;
            }
            private PVEServices services;

            public PVEServices getServices() {
                return services == null ? (services = new PVEServices(client, this.node)) : services;
            }
            private PVESubscription subscription;

            public PVESubscription getSubscription() {
                return subscription == null ? (subscription = new PVESubscription(client, this.node)) : subscription;
            }
            private PVENetwork network;

            public PVENetwork getNetwork() {
                return network == null ? (network = new PVENetwork(client, this.node)) : network;
            }
            private PVETasks tasks;

            public PVETasks getTasks() {
                return tasks == null ? (tasks = new PVETasks(client, this.node)) : tasks;
            }
            private PVEScan scan;

            public PVEScan getScan() {
                return scan == null ? (scan = new PVEScan(client, this.node)) : scan;
            }
            private PVEHardware hardware;

            public PVEHardware getHardware() {
                return hardware == null ? (hardware = new PVEHardware(client, this.node)) : hardware;
            }
            private PVECapabilities capabilities;

            public PVECapabilities getCapabilities() {
                return capabilities == null ? (capabilities = new PVECapabilities(client, this.node)) : capabilities;
            }
            private PVEStorage storage;

            public PVEStorage getStorage() {
                return storage == null ? (storage = new PVEStorage(client, this.node)) : storage;
            }
            private PVEDisks disks;

            public PVEDisks getDisks() {
                return disks == null ? (disks = new PVEDisks(client, this.node)) : disks;
            }
            private PVEApt apt;

            public PVEApt getApt() {
                return apt == null ? (apt = new PVEApt(client, this.node)) : apt;
            }
            private PVEFirewall firewall;

            public PVEFirewall getFirewall() {
                return firewall == null ? (firewall = new PVEFirewall(client, this.node)) : firewall;
            }
            private PVEReplication replication;

            public PVEReplication getReplication() {
                return replication == null ? (replication = new PVEReplication(client, this.node)) : replication;
            }
            private PVECertificates certificates;

            public PVECertificates getCertificates() {
                return certificates == null ? (certificates = new PVECertificates(client, this.node)) : certificates;
            }
            private PVEConfig config;

            public PVEConfig getConfig() {
                return config == null ? (config = new PVEConfig(client, this.node)) : config;
            }
            private PVESdn sdn;

            public PVESdn getSdn() {
                return sdn == null ? (sdn = new PVESdn(client, this.node)) : sdn;
            }
            private PVEVersion version;

            public PVEVersion getVersion() {
                return version == null ? (version = new PVEVersion(client, this.node)) : version;
            }
            private PVEStatus status;

            public PVEStatus getStatus() {
                return status == null ? (status = new PVEStatus(client, this.node)) : status;
            }
            private PVENetstat netstat;

            public PVENetstat getNetstat() {
                return netstat == null ? (netstat = new PVENetstat(client, this.node)) : netstat;
            }
            private PVEExecute execute;

            public PVEExecute getExecute() {
                return execute == null ? (execute = new PVEExecute(client, this.node)) : execute;
            }
            private PVEWakeonlan wakeonlan;

            public PVEWakeonlan getWakeonlan() {
                return wakeonlan == null ? (wakeonlan = new PVEWakeonlan(client, this.node)) : wakeonlan;
            }
            private PVERrd rrd;

            public PVERrd getRrd() {
                return rrd == null ? (rrd = new PVERrd(client, this.node)) : rrd;
            }
            private PVERrddata rrddata;

            public PVERrddata getRrddata() {
                return rrddata == null ? (rrddata = new PVERrddata(client, this.node)) : rrddata;
            }
            private PVESyslog syslog;

            public PVESyslog getSyslog() {
                return syslog == null ? (syslog = new PVESyslog(client, this.node)) : syslog;
            }
            private PVEJournal journal;

            public PVEJournal getJournal() {
                return journal == null ? (journal = new PVEJournal(client, this.node)) : journal;
            }
            private PVEVncshell vncshell;

            public PVEVncshell getVncshell() {
                return vncshell == null ? (vncshell = new PVEVncshell(client, this.node)) : vncshell;
            }
            private PVETermproxy termproxy;

            public PVETermproxy getTermproxy() {
                return termproxy == null ? (termproxy = new PVETermproxy(client, this.node)) : termproxy;
            }
            private PVEVncwebsocket vncwebsocket;

            public PVEVncwebsocket getVncwebsocket() {
                return vncwebsocket == null ? (vncwebsocket = new PVEVncwebsocket(client, this.node)) : vncwebsocket;
            }
            private PVESpiceshell spiceshell;

            public PVESpiceshell getSpiceshell() {
                return spiceshell == null ? (spiceshell = new PVESpiceshell(client, this.node)) : spiceshell;
            }
            private PVEDns dns;

            public PVEDns getDns() {
                return dns == null ? (dns = new PVEDns(client, this.node)) : dns;
            }
            private PVETime time;

            public PVETime getTime() {
                return time == null ? (time = new PVETime(client, this.node)) : time;
            }
            private PVEAplinfo aplinfo;

            public PVEAplinfo getAplinfo() {
                return aplinfo == null ? (aplinfo = new PVEAplinfo(client, this.node)) : aplinfo;
            }
            private PVEQueryUrlMetadata queryUrlMetadata;

            public PVEQueryUrlMetadata getQueryUrlMetadata() {
                return queryUrlMetadata == null ? (queryUrlMetadata = new PVEQueryUrlMetadata(client, this.node)) : queryUrlMetadata;
            }
            private PVEReport report;

            public PVEReport getReport() {
                return report == null ? (report = new PVEReport(client, this.node)) : report;
            }
            private PVEStartall startall;

            public PVEStartall getStartall() {
                return startall == null ? (startall = new PVEStartall(client, this.node)) : startall;
            }
            private PVEStopall stopall;

            public PVEStopall getStopall() {
                return stopall == null ? (stopall = new PVEStopall(client, this.node)) : stopall;
            }
            private PVESuspendall suspendall;

            public PVESuspendall getSuspendall() {
                return suspendall == null ? (suspendall = new PVESuspendall(client, this.node)) : suspendall;
            }
            private PVEMigrateall migrateall;

            public PVEMigrateall getMigrateall() {
                return migrateall == null ? (migrateall = new PVEMigrateall(client, this.node)) : migrateall;
            }
            private PVEHosts hosts;

            public PVEHosts getHosts() {
                return hosts == null ? (hosts = new PVEHosts(client, this.node)) : hosts;
            }

            public class PVEQemu {

                private final PveClient client;
                private final Object node;

                protected PVEQemu(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                public PVEVmidItem get(Object vmid) {
                    return new PVEVmidItem(client, this.node, vmid);
                }

                public class PVEVmidItem {

                    private final PveClient client;
                    private final Object node;
                    private final Object vmid;

                    protected PVEVmidItem(PveClient client, Object node, Object vmid) {
                        this.client = client;
                        this.node = node;
                        this.vmid = vmid;
                    }

                    private PVEFirewall firewall;

                    public PVEFirewall getFirewall() {
                        return firewall == null ? (firewall = new PVEFirewall(client, this.node, this.vmid)) : firewall;
                    }
                    private PVEAgent agent;

                    public PVEAgent getAgent() {
                        return agent == null ? (agent = new PVEAgent(client, this.node, this.vmid)) : agent;
                    }
                    private PVERrd rrd;

                    public PVERrd getRrd() {
                        return rrd == null ? (rrd = new PVERrd(client, this.node, this.vmid)) : rrd;
                    }
                    private PVERrddata rrddata;

                    public PVERrddata getRrddata() {
                        return rrddata == null ? (rrddata = new PVERrddata(client, this.node, this.vmid)) : rrddata;
                    }
                    private PVEConfig config;

                    public PVEConfig getConfig() {
                        return config == null ? (config = new PVEConfig(client, this.node, this.vmid)) : config;
                    }
                    private PVEPending pending;

                    public PVEPending getPending() {
                        return pending == null ? (pending = new PVEPending(client, this.node, this.vmid)) : pending;
                    }
                    private PVECloudinit cloudinit;

                    public PVECloudinit getCloudinit() {
                        return cloudinit == null ? (cloudinit = new PVECloudinit(client, this.node, this.vmid)) : cloudinit;
                    }
                    private PVEUnlink unlink;

                    public PVEUnlink getUnlink() {
                        return unlink == null ? (unlink = new PVEUnlink(client, this.node, this.vmid)) : unlink;
                    }
                    private PVEVncproxy vncproxy;

                    public PVEVncproxy getVncproxy() {
                        return vncproxy == null ? (vncproxy = new PVEVncproxy(client, this.node, this.vmid)) : vncproxy;
                    }
                    private PVETermproxy termproxy;

                    public PVETermproxy getTermproxy() {
                        return termproxy == null ? (termproxy = new PVETermproxy(client, this.node, this.vmid)) : termproxy;
                    }
                    private PVEVncwebsocket vncwebsocket;

                    public PVEVncwebsocket getVncwebsocket() {
                        return vncwebsocket == null ? (vncwebsocket = new PVEVncwebsocket(client, this.node, this.vmid)) : vncwebsocket;
                    }
                    private PVESpiceproxy spiceproxy;

                    public PVESpiceproxy getSpiceproxy() {
                        return spiceproxy == null ? (spiceproxy = new PVESpiceproxy(client, this.node, this.vmid)) : spiceproxy;
                    }
                    private PVEStatus status;

                    public PVEStatus getStatus() {
                        return status == null ? (status = new PVEStatus(client, this.node, this.vmid)) : status;
                    }
                    private PVESendkey sendkey;

                    public PVESendkey getSendkey() {
                        return sendkey == null ? (sendkey = new PVESendkey(client, this.node, this.vmid)) : sendkey;
                    }
                    private PVEFeature feature;

                    public PVEFeature getFeature() {
                        return feature == null ? (feature = new PVEFeature(client, this.node, this.vmid)) : feature;
                    }
                    private PVEClone clone;

                    public PVEClone getClone() {
                        return clone == null ? (clone = new PVEClone(client, this.node, this.vmid)) : clone;
                    }
                    private PVEMoveDisk moveDisk;

                    public PVEMoveDisk getMoveDisk() {
                        return moveDisk == null ? (moveDisk = new PVEMoveDisk(client, this.node, this.vmid)) : moveDisk;
                    }
                    private PVEMigrate migrate;

                    public PVEMigrate getMigrate() {
                        return migrate == null ? (migrate = new PVEMigrate(client, this.node, this.vmid)) : migrate;
                    }
                    private PVERemoteMigrate remoteMigrate;

                    public PVERemoteMigrate getRemoteMigrate() {
                        return remoteMigrate == null ? (remoteMigrate = new PVERemoteMigrate(client, this.node, this.vmid)) : remoteMigrate;
                    }
                    private PVEMonitor monitor;

                    public PVEMonitor getMonitor() {
                        return monitor == null ? (monitor = new PVEMonitor(client, this.node, this.vmid)) : monitor;
                    }
                    private PVEResize resize;

                    public PVEResize getResize() {
                        return resize == null ? (resize = new PVEResize(client, this.node, this.vmid)) : resize;
                    }
                    private PVESnapshot snapshot;

                    public PVESnapshot getSnapshot() {
                        return snapshot == null ? (snapshot = new PVESnapshot(client, this.node, this.vmid)) : snapshot;
                    }
                    private PVETemplate template;

                    public PVETemplate getTemplate() {
                        return template == null ? (template = new PVETemplate(client, this.node, this.vmid)) : template;
                    }
                    private PVEMtunnel mtunnel;

                    public PVEMtunnel getMtunnel() {
                        return mtunnel == null ? (mtunnel = new PVEMtunnel(client, this.node, this.vmid)) : mtunnel;
                    }
                    private PVEMtunnelwebsocket mtunnelwebsocket;

                    public PVEMtunnelwebsocket getMtunnelwebsocket() {
                        return mtunnelwebsocket == null ? (mtunnelwebsocket = new PVEMtunnelwebsocket(client, this.node, this.vmid)) : mtunnelwebsocket;
                    }

                    public class PVEFirewall {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEFirewall(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        private PVERules rules;

                        public PVERules getRules() {
                            return rules == null ? (rules = new PVERules(client, this.node, this.vmid)) : rules;
                        }
                        private PVEAliases aliases;

                        public PVEAliases getAliases() {
                            return aliases == null ? (aliases = new PVEAliases(client, this.node, this.vmid)) : aliases;
                        }
                        private PVEIpset ipset;

                        public PVEIpset getIpset() {
                            return ipset == null ? (ipset = new PVEIpset(client, this.node, this.vmid)) : ipset;
                        }
                        private PVEOptions options;

                        public PVEOptions getOptions() {
                            return options == null ? (options = new PVEOptions(client, this.node, this.vmid)) : options;
                        }
                        private PVELog log;

                        public PVELog getLog() {
                            return log == null ? (log = new PVELog(client, this.node, this.vmid)) : log;
                        }
                        private PVERefs refs;

                        public PVERefs getRefs() {
                            return refs == null ? (refs = new PVERefs(client, this.node, this.vmid)) : refs;
                        }

                        public class PVERules {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVERules(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            public PVEPosItem get(Object pos) {
                                return new PVEPosItem(client, this.node, this.vmid, pos);
                            }

                            public class PVEPosItem {

                                private final PveClient client;
                                private final Object node;
                                private final Object vmid;
                                private final Object pos;

                                protected PVEPosItem(PveClient client, Object node, Object vmid, Object pos) {
                                    this.client = client;
                                    this.node = node;
                                    this.vmid = vmid;
                                    this.pos = pos;
                                }

                                /**
                                 * Delete rule.
                                 *
                                 * @param digest Prevent changes if current
                                 * configuration file has a different digest.
                                 * This can be used to prevent concurrent
                                 * modifications.
                                 * @return Result
                                 * @throws JSONException
                                 */
                                public Result deleteRule(String digest) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("digest", digest);
                                    return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/rules/" + this.pos + "", parameters);
                                }

                                /**
                                 * Delete rule.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result deleteRule() throws JSONException {
                                    return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/rules/" + this.pos + "", null);
                                }

                                /**
                                 * Get single rule data.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result getRule() throws JSONException {
                                    return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/rules/" + this.pos + "", null);
                                }

                                /**
                                 * Modify rule data.
                                 *
                                 * @param action Rule action ('ACCEPT', 'DROP',
                                 * 'REJECT') or security group name.
                                 * @param comment Descriptive comment.
                                 * @param delete A list of settings you want to
                                 * delete.
                                 * @param dest Restrict packet destination
                                 * address. This can refer to a single IP
                                 * address, an IP set ('+ipsetname') or an IP
                                 * alias definition. You can also specify an
                                 * address range like
                                 * '20.34.101.207-201.3.9.99', or a list of IP
                                 * addresses and networks (entries are separated
                                 * by comma). Please do not mix IPv4 and IPv6
                                 * addresses inside such lists.
                                 * @param digest Prevent changes if current
                                 * configuration file has a different digest.
                                 * This can be used to prevent concurrent
                                 * modifications.
                                 * @param dport Restrict TCP/UDP destination
                                 * port. You can use service names or simple
                                 * numbers (0-65535), as defined in
                                 * '/etc/services'. Port ranges can be specified
                                 * with '\d+:\d+', for example '80:85', and you
                                 * can use comma separated list to match several
                                 * ports or ranges.
                                 * @param enable Flag to enable/disable a rule.
                                 * @param icmp_type Specify icmp-type. Only
                                 * valid if proto equals 'icmp' or
                                 * 'icmpv6'/'ipv6-icmp'.
                                 * @param iface Network interface name. You have
                                 * to use network configuration key names for
                                 * VMs and containers ('net\d+'). Host related
                                 * rules can use arbitrary strings.
                                 * @param log Log level for firewall rule. Enum:
                                 * emerg,alert,crit,err,warning,notice,info,debug,nolog
                                 * @param macro Use predefined standard macro.
                                 * @param moveto Move rule to new position
                                 * &amp;lt;moveto&amp;gt;. Other arguments are
                                 * ignored.
                                 * @param proto IP protocol. You can use
                                 * protocol names ('tcp'/'udp') or simple
                                 * numbers, as defined in '/etc/protocols'.
                                 * @param source Restrict packet source address.
                                 * This can refer to a single IP address, an IP
                                 * set ('+ipsetname') or an IP alias definition.
                                 * You can also specify an address range like
                                 * '20.34.101.207-201.3.9.99', or a list of IP
                                 * addresses and networks (entries are separated
                                 * by comma). Please do not mix IPv4 and IPv6
                                 * addresses inside such lists.
                                 * @param sport Restrict TCP/UDP source port.
                                 * You can use service names or simple numbers
                                 * (0-65535), as defined in '/etc/services'.
                                 * Port ranges can be specified with '\d+:\d+',
                                 * for example '80:85', and you can use comma
                                 * separated list to match several ports or
                                 * ranges.
                                 * @param type Rule type. Enum: in,out,group
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateRule(String action, String comment, String delete, String dest, String digest, String dport, Integer enable, String icmp_type, String iface, String log, String macro, Integer moveto, String proto, String source, String sport, String type) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("action", action);
                                    parameters.put("comment", comment);
                                    parameters.put("delete", delete);
                                    parameters.put("dest", dest);
                                    parameters.put("digest", digest);
                                    parameters.put("dport", dport);
                                    parameters.put("enable", enable);
                                    parameters.put("icmp-type", icmp_type);
                                    parameters.put("iface", iface);
                                    parameters.put("log", log);
                                    parameters.put("macro", macro);
                                    parameters.put("moveto", moveto);
                                    parameters.put("proto", proto);
                                    parameters.put("source", source);
                                    parameters.put("sport", sport);
                                    parameters.put("type", type);
                                    return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/rules/" + this.pos + "", parameters);
                                }

                                /**
                                 * Modify rule data.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateRule() throws JSONException {
                                    return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/rules/" + this.pos + "", null);
                                }

                            }

                            /**
                             * List rules.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getRules() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/rules", null);
                            }

                            /**
                             * Create new rule.
                             *
                             * @param action Rule action ('ACCEPT', 'DROP',
                             * 'REJECT') or security group name.
                             * @param type Rule type. Enum: in,out,group
                             * @param comment Descriptive comment.
                             * @param dest Restrict packet destination address.
                             * This can refer to a single IP address, an IP set
                             * ('+ipsetname') or an IP alias definition. You can
                             * also specify an address range like
                             * '20.34.101.207-201.3.9.99', or a list of IP
                             * addresses and networks (entries are separated by
                             * comma). Please do not mix IPv4 and IPv6 addresses
                             * inside such lists.
                             * @param digest Prevent changes if current
                             * configuration file has a different digest. This
                             * can be used to prevent concurrent modifications.
                             * @param dport Restrict TCP/UDP destination port.
                             * You can use service names or simple numbers
                             * (0-65535), as defined in '/etc/services'. Port
                             * ranges can be specified with '\d+:\d+', for
                             * example '80:85', and you can use comma separated
                             * list to match several ports or ranges.
                             * @param enable Flag to enable/disable a rule.
                             * @param icmp_type Specify icmp-type. Only valid if
                             * proto equals 'icmp' or 'icmpv6'/'ipv6-icmp'.
                             * @param iface Network interface name. You have to
                             * use network configuration key names for VMs and
                             * containers ('net\d+'). Host related rules can use
                             * arbitrary strings.
                             * @param log Log level for firewall rule. Enum:
                             * emerg,alert,crit,err,warning,notice,info,debug,nolog
                             * @param macro Use predefined standard macro.
                             * @param pos Update rule at position
                             * &amp;lt;pos&amp;gt;.
                             * @param proto IP protocol. You can use protocol
                             * names ('tcp'/'udp') or simple numbers, as defined
                             * in '/etc/protocols'.
                             * @param source Restrict packet source address.
                             * This can refer to a single IP address, an IP set
                             * ('+ipsetname') or an IP alias definition. You can
                             * also specify an address range like
                             * '20.34.101.207-201.3.9.99', or a list of IP
                             * addresses and networks (entries are separated by
                             * comma). Please do not mix IPv4 and IPv6 addresses
                             * inside such lists.
                             * @param sport Restrict TCP/UDP source port. You
                             * can use service names or simple numbers
                             * (0-65535), as defined in '/etc/services'. Port
                             * ranges can be specified with '\d+:\d+', for
                             * example '80:85', and you can use comma separated
                             * list to match several ports or ranges.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createRule(String action, String type, String comment, String dest, String digest, String dport, Integer enable, String icmp_type, String iface, String log, String macro, Integer pos, String proto, String source, String sport) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("action", action);
                                parameters.put("type", type);
                                parameters.put("comment", comment);
                                parameters.put("dest", dest);
                                parameters.put("digest", digest);
                                parameters.put("dport", dport);
                                parameters.put("enable", enable);
                                parameters.put("icmp-type", icmp_type);
                                parameters.put("iface", iface);
                                parameters.put("log", log);
                                parameters.put("macro", macro);
                                parameters.put("pos", pos);
                                parameters.put("proto", proto);
                                parameters.put("source", source);
                                parameters.put("sport", sport);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/rules", parameters);
                            }

                            /**
                             * Create new rule.
                             *
                             * @param action Rule action ('ACCEPT', 'DROP',
                             * 'REJECT') or security group name.
                             * @param type Rule type. Enum: in,out,group
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createRule(String action, String type) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("action", action);
                                parameters.put("type", type);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/rules", parameters);
                            }

                        }

                        public class PVEAliases {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEAliases(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            public PVENameItem get(Object name) {
                                return new PVENameItem(client, this.node, this.vmid, name);
                            }

                            public class PVENameItem {

                                private final PveClient client;
                                private final Object node;
                                private final Object vmid;
                                private final Object name;

                                protected PVENameItem(PveClient client, Object node, Object vmid, Object name) {
                                    this.client = client;
                                    this.node = node;
                                    this.vmid = vmid;
                                    this.name = name;
                                }

                                /**
                                 * Remove IP or Network alias.
                                 *
                                 * @param digest Prevent changes if current
                                 * configuration file has a different digest.
                                 * This can be used to prevent concurrent
                                 * modifications.
                                 * @return Result
                                 * @throws JSONException
                                 */
                                public Result removeAlias(String digest) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("digest", digest);
                                    return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/aliases/" + this.name + "", parameters);
                                }

                                /**
                                 * Remove IP or Network alias.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result removeAlias() throws JSONException {
                                    return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/aliases/" + this.name + "", null);
                                }

                                /**
                                 * Read alias.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result readAlias() throws JSONException {
                                    return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/aliases/" + this.name + "", null);
                                }

                                /**
                                 * Update IP or Network alias.
                                 *
                                 * @param cidr Network/IP specification in CIDR
                                 * format.
                                 * @param comment
                                 * @param digest Prevent changes if current
                                 * configuration file has a different digest.
                                 * This can be used to prevent concurrent
                                 * modifications.
                                 * @param rename Rename an existing alias.
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateAlias(String cidr, String comment, String digest, String rename) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("cidr", cidr);
                                    parameters.put("comment", comment);
                                    parameters.put("digest", digest);
                                    parameters.put("rename", rename);
                                    return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/aliases/" + this.name + "", parameters);
                                }

                                /**
                                 * Update IP or Network alias.
                                 *
                                 * @param cidr Network/IP specification in CIDR
                                 * format.
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateAlias(String cidr) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("cidr", cidr);
                                    return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/aliases/" + this.name + "", parameters);
                                }

                            }

                            /**
                             * List aliases
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getAliases() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/aliases", null);
                            }

                            /**
                             * Create IP or Network Alias.
                             *
                             * @param cidr Network/IP specification in CIDR
                             * format.
                             * @param name Alias name.
                             * @param comment
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createAlias(String cidr, String name, String comment) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("cidr", cidr);
                                parameters.put("name", name);
                                parameters.put("comment", comment);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/aliases", parameters);
                            }

                            /**
                             * Create IP or Network Alias.
                             *
                             * @param cidr Network/IP specification in CIDR
                             * format.
                             * @param name Alias name.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createAlias(String cidr, String name) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("cidr", cidr);
                                parameters.put("name", name);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/aliases", parameters);
                            }

                        }

                        public class PVEIpset {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEIpset(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            public PVENameItem get(Object name) {
                                return new PVENameItem(client, this.node, this.vmid, name);
                            }

                            public class PVENameItem {

                                private final PveClient client;
                                private final Object node;
                                private final Object vmid;
                                private final Object name;

                                protected PVENameItem(PveClient client, Object node, Object vmid, Object name) {
                                    this.client = client;
                                    this.node = node;
                                    this.vmid = vmid;
                                    this.name = name;
                                }

                                public PVECidrItem get(Object cidr) {
                                    return new PVECidrItem(client, this.node, this.vmid, this.name, cidr);
                                }

                                public class PVECidrItem {

                                    private final PveClient client;
                                    private final Object node;
                                    private final Object vmid;
                                    private final Object name;
                                    private final Object cidr;

                                    protected PVECidrItem(PveClient client, Object node, Object vmid, Object name, Object cidr) {
                                        this.client = client;
                                        this.node = node;
                                        this.vmid = vmid;
                                        this.name = name;
                                        this.cidr = cidr;
                                    }

                                    /**
                                     * Remove IP or Network from IPSet.
                                     *
                                     * @param digest Prevent changes if current
                                     * configuration file has a different
                                     * digest. This can be used to prevent
                                     * concurrent modifications.
                                     * @return Result
                                     * @throws JSONException
                                     */
                                    public Result removeIp(String digest) throws JSONException {
                                        Map<String, Object> parameters = new HashMap<>();
                                        parameters.put("digest", digest);
                                        return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset/" + this.name + "/" + this.cidr + "", parameters);
                                    }

                                    /**
                                     * Remove IP or Network from IPSet.
                                     *
                                     * @return Result
                                     * @throws JSONException
                                     */

                                    public Result removeIp() throws JSONException {
                                        return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset/" + this.name + "/" + this.cidr + "", null);
                                    }

                                    /**
                                     * Read IP or Network settings from IPSet.
                                     *
                                     * @return Result
                                     * @throws JSONException
                                     */

                                    public Result readIp() throws JSONException {
                                        return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset/" + this.name + "/" + this.cidr + "", null);
                                    }

                                    /**
                                     * Update IP or Network settings
                                     *
                                     * @param comment
                                     * @param digest Prevent changes if current
                                     * configuration file has a different
                                     * digest. This can be used to prevent
                                     * concurrent modifications.
                                     * @param nomatch
                                     * @return Result
                                     * @throws JSONException
                                     */

                                    public Result updateIp(String comment, String digest, Boolean nomatch) throws JSONException {
                                        Map<String, Object> parameters = new HashMap<>();
                                        parameters.put("comment", comment);
                                        parameters.put("digest", digest);
                                        parameters.put("nomatch", nomatch);
                                        return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset/" + this.name + "/" + this.cidr + "", parameters);
                                    }

                                    /**
                                     * Update IP or Network settings
                                     *
                                     * @return Result
                                     * @throws JSONException
                                     */

                                    public Result updateIp() throws JSONException {
                                        return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset/" + this.name + "/" + this.cidr + "", null);
                                    }

                                }

                                /**
                                 * Delete IPSet
                                 *
                                 * @param force Delete all members of the IPSet,
                                 * if there are any.
                                 * @return Result
                                 * @throws JSONException
                                 */
                                public Result deleteIpset(Boolean force) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("force", force);
                                    return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset/" + this.name + "", parameters);
                                }

                                /**
                                 * Delete IPSet
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result deleteIpset() throws JSONException {
                                    return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset/" + this.name + "", null);
                                }

                                /**
                                 * List IPSet content
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result getIpset() throws JSONException {
                                    return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset/" + this.name + "", null);
                                }

                                /**
                                 * Add IP or Network to IPSet.
                                 *
                                 * @param cidr Network/IP specification in CIDR
                                 * format.
                                 * @param comment
                                 * @param nomatch
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result createIp(String cidr, String comment, Boolean nomatch) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("cidr", cidr);
                                    parameters.put("comment", comment);
                                    parameters.put("nomatch", nomatch);
                                    return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset/" + this.name + "", parameters);
                                }

                                /**
                                 * Add IP or Network to IPSet.
                                 *
                                 * @param cidr Network/IP specification in CIDR
                                 * format.
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result createIp(String cidr) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("cidr", cidr);
                                    return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset/" + this.name + "", parameters);
                                }

                            }

                            /**
                             * List IPSets
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result ipsetIndex() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset", null);
                            }

                            /**
                             * Create new IPSet
                             *
                             * @param name IP set name.
                             * @param comment
                             * @param digest Prevent changes if current
                             * configuration file has a different digest. This
                             * can be used to prevent concurrent modifications.
                             * @param rename Rename an existing IPSet. You can
                             * set 'rename' to the same value as 'name' to
                             * update the 'comment' of an existing IPSet.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createIpset(String name, String comment, String digest, String rename) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("name", name);
                                parameters.put("comment", comment);
                                parameters.put("digest", digest);
                                parameters.put("rename", rename);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset", parameters);
                            }

                            /**
                             * Create new IPSet
                             *
                             * @param name IP set name.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createIpset(String name) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("name", name);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/ipset", parameters);
                            }

                        }

                        public class PVEOptions {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEOptions(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Get VM firewall options.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getOptions() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/options", null);
                            }

                            /**
                             * Set Firewall options.
                             *
                             * @param delete A list of settings you want to
                             * delete.
                             * @param dhcp Enable DHCP.
                             * @param digest Prevent changes if current
                             * configuration file has a different digest. This
                             * can be used to prevent concurrent modifications.
                             * @param enable Enable/disable firewall rules.
                             * @param ipfilter Enable default IP filters. This
                             * is equivalent to adding an empty
                             * ipfilter-net&amp;lt;id&amp;gt; ipset for every
                             * interface. Such ipsets implicitly contain sane
                             * default restrictions such as restricting IPv6
                             * link local addresses to the one derived from the
                             * interface's MAC address. For containers the
                             * configured IP addresses will be implicitly added.
                             * @param log_level_in Log level for incoming
                             * traffic. Enum:
                             * emerg,alert,crit,err,warning,notice,info,debug,nolog
                             * @param log_level_out Log level for outgoing
                             * traffic. Enum:
                             * emerg,alert,crit,err,warning,notice,info,debug,nolog
                             * @param macfilter Enable/disable MAC address
                             * filter.
                             * @param ndp Enable NDP (Neighbor Discovery
                             * Protocol).
                             * @param policy_in Input policy. Enum:
                             * ACCEPT,REJECT,DROP
                             * @param policy_out Output policy. Enum:
                             * ACCEPT,REJECT,DROP
                             * @param radv Allow sending Router Advertisement.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result setOptions(String delete, Boolean dhcp, String digest, Boolean enable, Boolean ipfilter, String log_level_in, String log_level_out, Boolean macfilter, Boolean ndp, String policy_in, String policy_out, Boolean radv) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("delete", delete);
                                parameters.put("dhcp", dhcp);
                                parameters.put("digest", digest);
                                parameters.put("enable", enable);
                                parameters.put("ipfilter", ipfilter);
                                parameters.put("log_level_in", log_level_in);
                                parameters.put("log_level_out", log_level_out);
                                parameters.put("macfilter", macfilter);
                                parameters.put("ndp", ndp);
                                parameters.put("policy_in", policy_in);
                                parameters.put("policy_out", policy_out);
                                parameters.put("radv", radv);
                                return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/options", parameters);
                            }

                            /**
                             * Set Firewall options.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result setOptions() throws JSONException {
                                return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/options", null);
                            }

                        }

                        public class PVELog {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVELog(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Read firewall log
                             *
                             * @param limit
                             * @param since Display log since this UNIX epoch.
                             * @param start
                             * @param until Display log until this UNIX epoch.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result log(Integer limit, Integer since, Integer start, Integer until) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("limit", limit);
                                parameters.put("since", since);
                                parameters.put("start", start);
                                parameters.put("until", until);
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/log", parameters);
                            }

                            /**
                             * Read firewall log
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result log() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/log", null);
                            }

                        }

                        public class PVERefs {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVERefs(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Lists possible IPSet/Alias reference which are
                             * allowed in source/dest properties.
                             *
                             * @param type Only list references of specified
                             * type. Enum: alias,ipset
                             * @return Result
                             * @throws JSONException
                             */
                            public Result refs(String type) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("type", type);
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/refs", parameters);
                            }

                            /**
                             * Lists possible IPSet/Alias reference which are
                             * allowed in source/dest properties.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result refs() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall/refs", null);
                            }

                        }

                        /**
                         * Directory index.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result index() throws JSONException {
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/firewall", null);
                        }

                    }

                    public class PVEAgent {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEAgent(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        private PVEFsfreezeFreeze fsfreezeFreeze;

                        public PVEFsfreezeFreeze getFsfreezeFreeze() {
                            return fsfreezeFreeze == null ? (fsfreezeFreeze = new PVEFsfreezeFreeze(client, this.node, this.vmid)) : fsfreezeFreeze;
                        }
                        private PVEFsfreezeStatus fsfreezeStatus;

                        public PVEFsfreezeStatus getFsfreezeStatus() {
                            return fsfreezeStatus == null ? (fsfreezeStatus = new PVEFsfreezeStatus(client, this.node, this.vmid)) : fsfreezeStatus;
                        }
                        private PVEFsfreezeThaw fsfreezeThaw;

                        public PVEFsfreezeThaw getFsfreezeThaw() {
                            return fsfreezeThaw == null ? (fsfreezeThaw = new PVEFsfreezeThaw(client, this.node, this.vmid)) : fsfreezeThaw;
                        }
                        private PVEFstrim fstrim;

                        public PVEFstrim getFstrim() {
                            return fstrim == null ? (fstrim = new PVEFstrim(client, this.node, this.vmid)) : fstrim;
                        }
                        private PVEGetFsinfo getFsinfo;

                        public PVEGetFsinfo getGetFsinfo() {
                            return getFsinfo == null ? (getFsinfo = new PVEGetFsinfo(client, this.node, this.vmid)) : getFsinfo;
                        }
                        private PVEGetHostName getHostName;

                        public PVEGetHostName getGetHostName() {
                            return getHostName == null ? (getHostName = new PVEGetHostName(client, this.node, this.vmid)) : getHostName;
                        }
                        private PVEGetMemoryBlockInfo getMemoryBlockInfo;

                        public PVEGetMemoryBlockInfo getGetMemoryBlockInfo() {
                            return getMemoryBlockInfo == null ? (getMemoryBlockInfo = new PVEGetMemoryBlockInfo(client, this.node, this.vmid)) : getMemoryBlockInfo;
                        }
                        private PVEGetMemoryBlocks getMemoryBlocks;

                        public PVEGetMemoryBlocks getGetMemoryBlocks() {
                            return getMemoryBlocks == null ? (getMemoryBlocks = new PVEGetMemoryBlocks(client, this.node, this.vmid)) : getMemoryBlocks;
                        }
                        private PVEGetOsinfo getOsinfo;

                        public PVEGetOsinfo getGetOsinfo() {
                            return getOsinfo == null ? (getOsinfo = new PVEGetOsinfo(client, this.node, this.vmid)) : getOsinfo;
                        }
                        private PVEGetTime getTime;

                        public PVEGetTime getGetTime() {
                            return getTime == null ? (getTime = new PVEGetTime(client, this.node, this.vmid)) : getTime;
                        }
                        private PVEGetTimezone getTimezone;

                        public PVEGetTimezone getGetTimezone() {
                            return getTimezone == null ? (getTimezone = new PVEGetTimezone(client, this.node, this.vmid)) : getTimezone;
                        }
                        private PVEGetUsers getUsers;

                        public PVEGetUsers getGetUsers() {
                            return getUsers == null ? (getUsers = new PVEGetUsers(client, this.node, this.vmid)) : getUsers;
                        }
                        private PVEGetVcpus getVcpus;

                        public PVEGetVcpus getGetVcpus() {
                            return getVcpus == null ? (getVcpus = new PVEGetVcpus(client, this.node, this.vmid)) : getVcpus;
                        }
                        private PVEInfo info;

                        public PVEInfo getInfo() {
                            return info == null ? (info = new PVEInfo(client, this.node, this.vmid)) : info;
                        }
                        private PVENetworkGetInterfaces networkGetInterfaces;

                        public PVENetworkGetInterfaces getNetworkGetInterfaces() {
                            return networkGetInterfaces == null ? (networkGetInterfaces = new PVENetworkGetInterfaces(client, this.node, this.vmid)) : networkGetInterfaces;
                        }
                        private PVEPing ping;

                        public PVEPing getPing() {
                            return ping == null ? (ping = new PVEPing(client, this.node, this.vmid)) : ping;
                        }
                        private PVEShutdown shutdown;

                        public PVEShutdown getShutdown() {
                            return shutdown == null ? (shutdown = new PVEShutdown(client, this.node, this.vmid)) : shutdown;
                        }
                        private PVESuspendDisk suspendDisk;

                        public PVESuspendDisk getSuspendDisk() {
                            return suspendDisk == null ? (suspendDisk = new PVESuspendDisk(client, this.node, this.vmid)) : suspendDisk;
                        }
                        private PVESuspendHybrid suspendHybrid;

                        public PVESuspendHybrid getSuspendHybrid() {
                            return suspendHybrid == null ? (suspendHybrid = new PVESuspendHybrid(client, this.node, this.vmid)) : suspendHybrid;
                        }
                        private PVESuspendRam suspendRam;

                        public PVESuspendRam getSuspendRam() {
                            return suspendRam == null ? (suspendRam = new PVESuspendRam(client, this.node, this.vmid)) : suspendRam;
                        }
                        private PVESetUserPassword setUserPassword;

                        public PVESetUserPassword getSetUserPassword() {
                            return setUserPassword == null ? (setUserPassword = new PVESetUserPassword(client, this.node, this.vmid)) : setUserPassword;
                        }
                        private PVEExec exec;

                        public PVEExec getExec() {
                            return exec == null ? (exec = new PVEExec(client, this.node, this.vmid)) : exec;
                        }
                        private PVEExecStatus execStatus;

                        public PVEExecStatus getExecStatus() {
                            return execStatus == null ? (execStatus = new PVEExecStatus(client, this.node, this.vmid)) : execStatus;
                        }
                        private PVEFileRead fileRead;

                        public PVEFileRead getFileRead() {
                            return fileRead == null ? (fileRead = new PVEFileRead(client, this.node, this.vmid)) : fileRead;
                        }
                        private PVEFileWrite fileWrite;

                        public PVEFileWrite getFileWrite() {
                            return fileWrite == null ? (fileWrite = new PVEFileWrite(client, this.node, this.vmid)) : fileWrite;
                        }

                        public class PVEFsfreezeFreeze {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEFsfreezeFreeze(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute fsfreeze-freeze.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result fsfreezeFreeze() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/fsfreeze-freeze", null);
                            }

                        }

                        public class PVEFsfreezeStatus {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEFsfreezeStatus(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute fsfreeze-status.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result fsfreezeStatus() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/fsfreeze-status", null);
                            }

                        }

                        public class PVEFsfreezeThaw {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEFsfreezeThaw(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute fsfreeze-thaw.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result fsfreezeThaw() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/fsfreeze-thaw", null);
                            }

                        }

                        public class PVEFstrim {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEFstrim(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute fstrim.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result fstrim() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/fstrim", null);
                            }

                        }

                        public class PVEGetFsinfo {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEGetFsinfo(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute get-fsinfo.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getFsinfo() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/get-fsinfo", null);
                            }

                        }

                        public class PVEGetHostName {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEGetHostName(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute get-host-name.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getHostName() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/get-host-name", null);
                            }

                        }

                        public class PVEGetMemoryBlockInfo {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEGetMemoryBlockInfo(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute get-memory-block-info.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getMemoryBlockInfo() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/get-memory-block-info", null);
                            }

                        }

                        public class PVEGetMemoryBlocks {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEGetMemoryBlocks(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute get-memory-blocks.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getMemoryBlocks() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/get-memory-blocks", null);
                            }

                        }

                        public class PVEGetOsinfo {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEGetOsinfo(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute get-osinfo.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getOsinfo() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/get-osinfo", null);
                            }

                        }

                        public class PVEGetTime {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEGetTime(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute get-time.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getTime() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/get-time", null);
                            }

                        }

                        public class PVEGetTimezone {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEGetTimezone(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute get-timezone.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getTimezone() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/get-timezone", null);
                            }

                        }

                        public class PVEGetUsers {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEGetUsers(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute get-users.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getUsers() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/get-users", null);
                            }

                        }

                        public class PVEGetVcpus {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEGetVcpus(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute get-vcpus.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getVcpus() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/get-vcpus", null);
                            }

                        }

                        public class PVEInfo {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEInfo(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute info.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result info() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/info", null);
                            }

                        }

                        public class PVENetworkGetInterfaces {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVENetworkGetInterfaces(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute network-get-interfaces.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result networkGetInterfaces() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/network-get-interfaces", null);
                            }

                        }

                        public class PVEPing {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEPing(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute ping.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result ping() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/ping", null);
                            }

                        }

                        public class PVEShutdown {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEShutdown(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute shutdown.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result shutdown() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/shutdown", null);
                            }

                        }

                        public class PVESuspendDisk {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVESuspendDisk(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute suspend-disk.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result suspendDisk() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/suspend-disk", null);
                            }

                        }

                        public class PVESuspendHybrid {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVESuspendHybrid(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute suspend-hybrid.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result suspendHybrid() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/suspend-hybrid", null);
                            }

                        }

                        public class PVESuspendRam {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVESuspendRam(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Execute suspend-ram.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result suspendRam() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/suspend-ram", null);
                            }

                        }

                        public class PVESetUserPassword {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVESetUserPassword(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Sets the password for the given user to the given
                             * password
                             *
                             * @param password The new password.
                             * @param username The user to set the password for.
                             * @param crypted set to 1 if the password has
                             * already been passed through crypt()
                             * @return Result
                             * @throws JSONException
                             */
                            public Result setUserPassword(String password, String username, Boolean crypted) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("password", password);
                                parameters.put("username", username);
                                parameters.put("crypted", crypted);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/set-user-password", parameters);
                            }

                            /**
                             * Sets the password for the given user to the given
                             * password
                             *
                             * @param password The new password.
                             * @param username The user to set the password for.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result setUserPassword(String password, String username) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("password", password);
                                parameters.put("username", username);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/set-user-password", parameters);
                            }

                        }

                        public class PVEExec {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEExec(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Executes the given command in the vm via the
                             * guest-agent and returns an object with the pid.
                             *
                             * @param command The command as a list of program +
                             * arguments.
                             * @param input_data Data to pass as 'input-data' to
                             * the guest. Usually treated as STDIN to 'command'.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result exec(String command, String input_data) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("command", command);
                                parameters.put("input-data", input_data);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/exec", parameters);
                            }

                            /**
                             * Executes the given command in the vm via the
                             * guest-agent and returns an object with the pid.
                             *
                             * @param command The command as a list of program +
                             * arguments.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result exec(String command) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("command", command);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/exec", parameters);
                            }

                        }

                        public class PVEExecStatus {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEExecStatus(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Gets the status of the given pid started by the
                             * guest-agent
                             *
                             * @param pid The PID to query
                             * @return Result
                             * @throws JSONException
                             */
                            public Result execStatus(int pid) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("pid", pid);
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/exec-status", parameters);
                            }

                        }

                        public class PVEFileRead {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEFileRead(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Reads the given file via guest agent. Is limited
                             * to 16777216 bytes.
                             *
                             * @param file The path to the file
                             * @return Result
                             * @throws JSONException
                             */
                            public Result fileRead(String file) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("file", file);
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/file-read", parameters);
                            }

                        }

                        public class PVEFileWrite {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEFileWrite(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Writes the given file via guest agent.
                             *
                             * @param content The content to write into the
                             * file.
                             * @param file The path to the file.
                             * @param encode If set, the content will be encoded
                             * as base64 (required by QEMU).Otherwise the
                             * content needs to be encoded beforehand - defaults
                             * to true.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result fileWrite(String content, String file, Boolean encode) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("content", content);
                                parameters.put("file", file);
                                parameters.put("encode", encode);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/file-write", parameters);
                            }

                            /**
                             * Writes the given file via guest agent.
                             *
                             * @param content The content to write into the
                             * file.
                             * @param file The path to the file.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result fileWrite(String content, String file) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("content", content);
                                parameters.put("file", file);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent/file-write", parameters);
                            }

                        }

                        /**
                         * QEMU Guest Agent command index.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result index() throws JSONException {
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent", null);
                        }

                        /**
                         * Execute QEMU Guest Agent commands.
                         *
                         * @param command The QGA command. Enum:
                         * fsfreeze-freeze,fsfreeze-status,fsfreeze-thaw,fstrim,get-fsinfo,get-host-name,get-memory-block-info,get-memory-blocks,get-osinfo,get-time,get-timezone,get-users,get-vcpus,info,network-get-interfaces,ping,shutdown,suspend-disk,suspend-hybrid,suspend-ram
                         * @return Result
                         * @throws JSONException
                         */

                        public Result agent(String command) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("command", command);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/agent", parameters);
                        }

                    }

                    public class PVERrd {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVERrd(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Read VM RRD statistics (returns PNG)
                         *
                         * @param ds The list of datasources you want to
                         * display.
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @param cf The RRD consolidation function Enum:
                         * AVERAGE,MAX
                         * @return Result
                         * @throws JSONException
                         */
                        public Result rrd(String ds, String timeframe, String cf) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ds", ds);
                            parameters.put("timeframe", timeframe);
                            parameters.put("cf", cf);
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/rrd", parameters);
                        }

                        /**
                         * Read VM RRD statistics (returns PNG)
                         *
                         * @param ds The list of datasources you want to
                         * display.
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @return Result
                         * @throws JSONException
                         */

                        public Result rrd(String ds, String timeframe) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ds", ds);
                            parameters.put("timeframe", timeframe);
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/rrd", parameters);
                        }

                    }

                    public class PVERrddata {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVERrddata(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Read VM RRD statistics
                         *
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @param cf The RRD consolidation function Enum:
                         * AVERAGE,MAX
                         * @return Result
                         * @throws JSONException
                         */
                        public Result rrddata(String timeframe, String cf) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("timeframe", timeframe);
                            parameters.put("cf", cf);
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/rrddata", parameters);
                        }

                        /**
                         * Read VM RRD statistics
                         *
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @return Result
                         * @throws JSONException
                         */

                        public Result rrddata(String timeframe) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("timeframe", timeframe);
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/rrddata", parameters);
                        }

                    }

                    public class PVEConfig {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEConfig(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Get the virtual machine configuration with pending
                         * configuration changes applied. Set the 'current'
                         * parameter to get the current configuration instead.
                         *
                         * @param current Get current values (instead of pending
                         * values).
                         * @param snapshot Fetch config values from given
                         * snapshot.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vmConfig(Boolean current, String snapshot) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("current", current);
                            parameters.put("snapshot", snapshot);
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/config", parameters);
                        }

                        /**
                         * Get the virtual machine configuration with pending
                         * configuration changes applied. Set the 'current'
                         * parameter to get the current configuration instead.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result vmConfig() throws JSONException {
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/config", null);
                        }

                        /**
                         * Set virtual machine options (asynchrounous API).
                         *
                         * @param acpi Enable/disable ACPI.
                         * @param affinity List of host cores used to execute
                         * guest processes, for example: 0,5,8-11
                         * @param agent Enable/disable communication with the
                         * QEMU Guest Agent and its properties.
                         * @param arch Virtual processor architecture. Defaults
                         * to the host. Enum: x86_64,aarch64
                         * @param args Arbitrary arguments passed to kvm.
                         * @param audio0 Configure a audio device, useful in
                         * combination with QXL/Spice.
                         * @param autostart Automatic restart after crash
                         * (currently ignored).
                         * @param background_delay Time to wait for the task to
                         * finish. We return 'null' if the task finish within
                         * that time.
                         * @param balloon Amount of target RAM for the VM in
                         * MiB. Using zero disables the ballon driver.
                         * @param bios Select BIOS implementation. Enum:
                         * seabios,ovmf
                         * @param boot Specify guest boot order. Use the
                         * 'order=' sub-property as usage with no key or
                         * 'legacy=' is deprecated.
                         * @param bootdisk Enable booting from specified disk.
                         * Deprecated: Use 'boot: order=foo;bar' instead.
                         * @param cdrom This is an alias for option -ide2
                         * @param cicustom cloud-init: Specify custom files to
                         * replace the automatically generated ones at start.
                         * @param cipassword cloud-init: Password to assign the
                         * user. Using this is generally not recommended. Use
                         * ssh keys instead. Also note that older cloud-init
                         * versions do not support hashed passwords.
                         * @param citype Specifies the cloud-init configuration
                         * format. The default depends on the configured
                         * operating system type (`ostype`. We use the `nocloud`
                         * format for Linux, and `configdrive2` for windows.
                         * Enum: configdrive2,nocloud,opennebula
                         * @param ciupgrade cloud-init: do an automatic package
                         * upgrade after the first boot.
                         * @param ciuser cloud-init: User name to change ssh
                         * keys and password for instead of the image's
                         * configured default user.
                         * @param cores The number of cores per socket.
                         * @param cpu Emulated CPU type.
                         * @param cpulimit Limit of CPU usage.
                         * @param cpuunits CPU weight for a VM, will be clamped
                         * to [1, 10000] in cgroup v2.
                         * @param delete A list of settings you want to delete.
                         * @param description Description for the VM. Shown in
                         * the web-interface VM's summary. This is saved as
                         * comment inside the configuration file.
                         * @param digest Prevent changes if current
                         * configuration file has different SHA1 digest. This
                         * can be used to prevent concurrent modifications.
                         * @param efidisk0 Configure a disk for storing EFI
                         * vars. Use the special syntax STORAGE_ID:SIZE_IN_GiB
                         * to allocate a new volume. Note that SIZE_IN_GiB is
                         * ignored here and that the default EFI vars are copied
                         * to the volume instead. Use STORAGE_ID:0 and the
                         * 'import-from' parameter to import from an existing
                         * volume.
                         * @param force Force physical removal. Without this, we
                         * simple remove the disk from the config file and
                         * create an additional configuration entry called
                         * 'unused[n]', which contains the volume ID. Unlink of
                         * unused[n] always cause physical removal.
                         * @param freeze Freeze CPU at startup (use 'c' monitor
                         * command to start execution).
                         * @param hookscript Script that will be executed during
                         * various steps in the vms lifetime.
                         * @param hostpciN Map host PCI devices into guest.
                         * @param hotplug Selectively enable hotplug features.
                         * This is a comma separated list of hotplug features:
                         * 'network', 'disk', 'cpu', 'memory', 'usb' and
                         * 'cloudinit'. Use '0' to disable hotplug completely.
                         * Using '1' as value is an alias for the default
                         * `network,disk,usb`. USB hotplugging is possible for
                         * guests with machine version &amp;gt;= 7.1 and ostype
                         * l26 or windows &amp;gt; 7.
                         * @param hugepages Enable/disable hugepages memory.
                         * Enum: any,2,1024
                         * @param ideN Use volume as IDE hard disk or CD-ROM (n
                         * is 0 to 3). Use the special syntax
                         * STORAGE_ID:SIZE_IN_GiB to allocate a new volume. Use
                         * STORAGE_ID:0 and the 'import-from' parameter to
                         * import from an existing volume.
                         * @param ipconfigN cloud-init: Specify IP addresses and
                         * gateways for the corresponding interface. IP
                         * addresses use CIDR notation, gateways are optional
                         * but need an IP of the same type specified. The
                         * special string 'dhcp' can be used for IP addresses to
                         * use DHCP, in which case no explicit gateway should be
                         * provided. For IPv6 the special string 'auto' can be
                         * used to use stateless autoconfiguration. This
                         * requires cloud-init 19.4 or newer. If cloud-init is
                         * enabled and neither an IPv4 nor an IPv6 address is
                         * specified, it defaults to using dhcp on IPv4.
                         * @param ivshmem Inter-VM shared memory. Useful for
                         * direct communication between VMs, or to the host.
                         * @param keephugepages Use together with hugepages. If
                         * enabled, hugepages will not not be deleted after VM
                         * shutdown and can be used for subsequent starts.
                         * @param keyboard Keyboard layout for VNC server. This
                         * option is generally not required and is often better
                         * handled from within the guest OS. Enum:
                         * de,de-ch,da,en-gb,en-us,es,fi,fr,fr-be,fr-ca,fr-ch,hu,is,it,ja,lt,mk,nl,no,pl,pt,pt-br,sv,sl,tr
                         * @param kvm Enable/disable KVM hardware
                         * virtualization.
                         * @param localtime Set the real time clock (RTC) to
                         * local time. This is enabled by default if the
                         * `ostype` indicates a Microsoft Windows OS.
                         * @param lock_ Lock/unlock the VM. Enum:
                         * backup,clone,create,migrate,rollback,snapshot,snapshot-delete,suspending,suspended
                         * @param machine Specifies the QEMU machine type.
                         * @param memory Memory properties.
                         * @param migrate_downtime Set maximum tolerated
                         * downtime (in seconds) for migrations.
                         * @param migrate_speed Set maximum speed (in MB/s) for
                         * migrations. Value 0 is no limit.
                         * @param name Set a name for the VM. Only used on the
                         * configuration web interface.
                         * @param nameserver cloud-init: Sets DNS server IP
                         * address for a container. Create will automatically
                         * use the setting from the host if neither searchdomain
                         * nor nameserver are set.
                         * @param netN Specify network devices.
                         * @param numa Enable/disable NUMA.
                         * @param numaN NUMA topology.
                         * @param onboot Specifies whether a VM will be started
                         * during system bootup.
                         * @param ostype Specify guest operating system. Enum:
                         * other,wxp,w2k,w2k3,w2k8,wvista,win7,win8,win10,win11,l24,l26,solaris
                         * @param parallelN Map host parallel devices (n is 0 to
                         * 2).
                         * @param protection Sets the protection flag of the VM.
                         * This will disable the remove VM and remove disk
                         * operations.
                         * @param reboot Allow reboot. If set to '0' the VM exit
                         * on reboot.
                         * @param revert Revert a pending change.
                         * @param rng0 Configure a VirtIO-based Random Number
                         * Generator.
                         * @param sataN Use volume as SATA hard disk or CD-ROM
                         * (n is 0 to 5). Use the special syntax
                         * STORAGE_ID:SIZE_IN_GiB to allocate a new volume. Use
                         * STORAGE_ID:0 and the 'import-from' parameter to
                         * import from an existing volume.
                         * @param scsiN Use volume as SCSI hard disk or CD-ROM
                         * (n is 0 to 30). Use the special syntax
                         * STORAGE_ID:SIZE_IN_GiB to allocate a new volume. Use
                         * STORAGE_ID:0 and the 'import-from' parameter to
                         * import from an existing volume.
                         * @param scsihw SCSI controller model Enum:
                         * lsi,lsi53c810,virtio-scsi-pci,virtio-scsi-single,megasas,pvscsi
                         * @param searchdomain cloud-init: Sets DNS search
                         * domains for a container. Create will automatically
                         * use the setting from the host if neither searchdomain
                         * nor nameserver are set.
                         * @param serialN Create a serial device inside the VM
                         * (n is 0 to 3)
                         * @param shares Amount of memory shares for
                         * auto-ballooning. The larger the number is, the more
                         * memory this VM gets. Number is relative to weights of
                         * all other running VMs. Using zero disables
                         * auto-ballooning. Auto-ballooning is done by pvestatd.
                         * @param skiplock Ignore locks - only root is allowed
                         * to use this option.
                         * @param smbios1 Specify SMBIOS type 1 fields.
                         * @param smp The number of CPUs. Please use option
                         * -sockets instead.
                         * @param sockets The number of CPU sockets.
                         * @param spice_enhancements Configure additional
                         * enhancements for SPICE.
                         * @param sshkeys cloud-init: Setup public SSH keys (one
                         * key per line, OpenSSH format).
                         * @param startdate Set the initial date of the real
                         * time clock. Valid format for date are:'now' or
                         * '2006-06-17T16:01:21' or '2006-06-17'.
                         * @param startup Startup and shutdown behavior. Order
                         * is a non-negative number defining the general startup
                         * order. Shutdown in done with reverse ordering.
                         * Additionally you can set the 'up' or 'down' delay in
                         * seconds, which specifies a delay to wait before the
                         * next VM is started or stopped.
                         * @param tablet Enable/disable the USB tablet device.
                         * @param tags Tags of the VM. This is only meta
                         * information.
                         * @param tdf Enable/disable time drift fix.
                         * @param template Enable/disable Template.
                         * @param tpmstate0 Configure a Disk for storing TPM
                         * state. The format is fixed to 'raw'. Use the special
                         * syntax STORAGE_ID:SIZE_IN_GiB to allocate a new
                         * volume. Note that SIZE_IN_GiB is ignored here and 4
                         * MiB will be used instead. Use STORAGE_ID:0 and the
                         * 'import-from' parameter to import from an existing
                         * volume.
                         * @param unusedN Reference to unused volumes. This is
                         * used internally, and should not be modified manually.
                         * @param usbN Configure an USB device (n is 0 to 4, for
                         * machine version &amp;gt;= 7.1 and ostype l26 or
                         * windows &amp;gt; 7, n can be up to 14).
                         * @param vcpus Number of hotplugged vcpus.
                         * @param vga Configure the VGA hardware.
                         * @param virtioN Use volume as VIRTIO hard disk (n is 0
                         * to 15). Use the special syntax STORAGE_ID:SIZE_IN_GiB
                         * to allocate a new volume. Use STORAGE_ID:0 and the
                         * 'import-from' parameter to import from an existing
                         * volume.
                         * @param vmgenid Set VM Generation ID. Use '1' to
                         * autogenerate on create or update, pass '0' to disable
                         * explicitly.
                         * @param vmstatestorage Default storage for VM state
                         * volumes/files.
                         * @param watchdog Create a virtual hardware watchdog
                         * device.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateVmAsync(Boolean acpi, String affinity, String agent, String arch, String args, String audio0, Boolean autostart, Integer background_delay, Integer balloon, String bios, String boot, String bootdisk, String cdrom, String cicustom, String cipassword, String citype, Boolean ciupgrade, String ciuser, Integer cores, String cpu, Float cpulimit, Integer cpuunits, String delete, String description, String digest, String efidisk0, Boolean force, Boolean freeze, String hookscript, Map<Integer, String> hostpciN, String hotplug, String hugepages, Map<Integer, String> ideN, Map<Integer, String> ipconfigN, String ivshmem, Boolean keephugepages, String keyboard, Boolean kvm, Boolean localtime, String lock_, String machine, String memory, Float migrate_downtime, Integer migrate_speed, String name, String nameserver, Map<Integer, String> netN, Boolean numa, Map<Integer, String> numaN, Boolean onboot, String ostype, Map<Integer, String> parallelN, Boolean protection, Boolean reboot, String revert, String rng0, Map<Integer, String> sataN, Map<Integer, String> scsiN, String scsihw, String searchdomain, Map<Integer, String> serialN, Integer shares, Boolean skiplock, String smbios1, Integer smp, Integer sockets, String spice_enhancements, String sshkeys, String startdate, String startup, Boolean tablet, String tags, Boolean tdf, Boolean template, String tpmstate0, Map<Integer, String> unusedN, Map<Integer, String> usbN, Integer vcpus, String vga, Map<Integer, String> virtioN, String vmgenid, String vmstatestorage, String watchdog) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("acpi", acpi);
                            parameters.put("affinity", affinity);
                            parameters.put("agent", agent);
                            parameters.put("arch", arch);
                            parameters.put("args", args);
                            parameters.put("audio0", audio0);
                            parameters.put("autostart", autostart);
                            parameters.put("background_delay", background_delay);
                            parameters.put("balloon", balloon);
                            parameters.put("bios", bios);
                            parameters.put("boot", boot);
                            parameters.put("bootdisk", bootdisk);
                            parameters.put("cdrom", cdrom);
                            parameters.put("cicustom", cicustom);
                            parameters.put("cipassword", cipassword);
                            parameters.put("citype", citype);
                            parameters.put("ciupgrade", ciupgrade);
                            parameters.put("ciuser", ciuser);
                            parameters.put("cores", cores);
                            parameters.put("cpu", cpu);
                            parameters.put("cpulimit", cpulimit);
                            parameters.put("cpuunits", cpuunits);
                            parameters.put("delete", delete);
                            parameters.put("description", description);
                            parameters.put("digest", digest);
                            parameters.put("efidisk0", efidisk0);
                            parameters.put("force", force);
                            parameters.put("freeze", freeze);
                            parameters.put("hookscript", hookscript);
                            parameters.put("hotplug", hotplug);
                            parameters.put("hugepages", hugepages);
                            parameters.put("ivshmem", ivshmem);
                            parameters.put("keephugepages", keephugepages);
                            parameters.put("keyboard", keyboard);
                            parameters.put("kvm", kvm);
                            parameters.put("localtime", localtime);
                            parameters.put("lock", lock_);
                            parameters.put("machine", machine);
                            parameters.put("memory", memory);
                            parameters.put("migrate_downtime", migrate_downtime);
                            parameters.put("migrate_speed", migrate_speed);
                            parameters.put("name", name);
                            parameters.put("nameserver", nameserver);
                            parameters.put("numa", numa);
                            parameters.put("onboot", onboot);
                            parameters.put("ostype", ostype);
                            parameters.put("protection", protection);
                            parameters.put("reboot", reboot);
                            parameters.put("revert", revert);
                            parameters.put("rng0", rng0);
                            parameters.put("scsihw", scsihw);
                            parameters.put("searchdomain", searchdomain);
                            parameters.put("shares", shares);
                            parameters.put("skiplock", skiplock);
                            parameters.put("smbios1", smbios1);
                            parameters.put("smp", smp);
                            parameters.put("sockets", sockets);
                            parameters.put("spice_enhancements", spice_enhancements);
                            parameters.put("sshkeys", sshkeys);
                            parameters.put("startdate", startdate);
                            parameters.put("startup", startup);
                            parameters.put("tablet", tablet);
                            parameters.put("tags", tags);
                            parameters.put("tdf", tdf);
                            parameters.put("template", template);
                            parameters.put("tpmstate0", tpmstate0);
                            parameters.put("vcpus", vcpus);
                            parameters.put("vga", vga);
                            parameters.put("vmgenid", vmgenid);
                            parameters.put("vmstatestorage", vmstatestorage);
                            parameters.put("watchdog", watchdog);
                            addIndexedParameter(parameters, "hostpci", hostpciN);
                            addIndexedParameter(parameters, "ide", ideN);
                            addIndexedParameter(parameters, "ipconfig", ipconfigN);
                            addIndexedParameter(parameters, "net", netN);
                            addIndexedParameter(parameters, "numa", numaN);
                            addIndexedParameter(parameters, "parallel", parallelN);
                            addIndexedParameter(parameters, "sata", sataN);
                            addIndexedParameter(parameters, "scsi", scsiN);
                            addIndexedParameter(parameters, "serial", serialN);
                            addIndexedParameter(parameters, "unused", unusedN);
                            addIndexedParameter(parameters, "usb", usbN);
                            addIndexedParameter(parameters, "virtio", virtioN);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/config", parameters);
                        }

                        /**
                         * Set virtual machine options (asynchrounous API).
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateVmAsync() throws JSONException {
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/config", null);
                        }

                        /**
                         * Set virtual machine options (synchrounous API) - You
                         * should consider using the POST method instead for any
                         * actions involving hotplug or storage allocation.
                         *
                         * @param acpi Enable/disable ACPI.
                         * @param affinity List of host cores used to execute
                         * guest processes, for example: 0,5,8-11
                         * @param agent Enable/disable communication with the
                         * QEMU Guest Agent and its properties.
                         * @param arch Virtual processor architecture. Defaults
                         * to the host. Enum: x86_64,aarch64
                         * @param args Arbitrary arguments passed to kvm.
                         * @param audio0 Configure a audio device, useful in
                         * combination with QXL/Spice.
                         * @param autostart Automatic restart after crash
                         * (currently ignored).
                         * @param balloon Amount of target RAM for the VM in
                         * MiB. Using zero disables the ballon driver.
                         * @param bios Select BIOS implementation. Enum:
                         * seabios,ovmf
                         * @param boot Specify guest boot order. Use the
                         * 'order=' sub-property as usage with no key or
                         * 'legacy=' is deprecated.
                         * @param bootdisk Enable booting from specified disk.
                         * Deprecated: Use 'boot: order=foo;bar' instead.
                         * @param cdrom This is an alias for option -ide2
                         * @param cicustom cloud-init: Specify custom files to
                         * replace the automatically generated ones at start.
                         * @param cipassword cloud-init: Password to assign the
                         * user. Using this is generally not recommended. Use
                         * ssh keys instead. Also note that older cloud-init
                         * versions do not support hashed passwords.
                         * @param citype Specifies the cloud-init configuration
                         * format. The default depends on the configured
                         * operating system type (`ostype`. We use the `nocloud`
                         * format for Linux, and `configdrive2` for windows.
                         * Enum: configdrive2,nocloud,opennebula
                         * @param ciupgrade cloud-init: do an automatic package
                         * upgrade after the first boot.
                         * @param ciuser cloud-init: User name to change ssh
                         * keys and password for instead of the image's
                         * configured default user.
                         * @param cores The number of cores per socket.
                         * @param cpu Emulated CPU type.
                         * @param cpulimit Limit of CPU usage.
                         * @param cpuunits CPU weight for a VM, will be clamped
                         * to [1, 10000] in cgroup v2.
                         * @param delete A list of settings you want to delete.
                         * @param description Description for the VM. Shown in
                         * the web-interface VM's summary. This is saved as
                         * comment inside the configuration file.
                         * @param digest Prevent changes if current
                         * configuration file has different SHA1 digest. This
                         * can be used to prevent concurrent modifications.
                         * @param efidisk0 Configure a disk for storing EFI
                         * vars. Use the special syntax STORAGE_ID:SIZE_IN_GiB
                         * to allocate a new volume. Note that SIZE_IN_GiB is
                         * ignored here and that the default EFI vars are copied
                         * to the volume instead. Use STORAGE_ID:0 and the
                         * 'import-from' parameter to import from an existing
                         * volume.
                         * @param force Force physical removal. Without this, we
                         * simple remove the disk from the config file and
                         * create an additional configuration entry called
                         * 'unused[n]', which contains the volume ID. Unlink of
                         * unused[n] always cause physical removal.
                         * @param freeze Freeze CPU at startup (use 'c' monitor
                         * command to start execution).
                         * @param hookscript Script that will be executed during
                         * various steps in the vms lifetime.
                         * @param hostpciN Map host PCI devices into guest.
                         * @param hotplug Selectively enable hotplug features.
                         * This is a comma separated list of hotplug features:
                         * 'network', 'disk', 'cpu', 'memory', 'usb' and
                         * 'cloudinit'. Use '0' to disable hotplug completely.
                         * Using '1' as value is an alias for the default
                         * `network,disk,usb`. USB hotplugging is possible for
                         * guests with machine version &amp;gt;= 7.1 and ostype
                         * l26 or windows &amp;gt; 7.
                         * @param hugepages Enable/disable hugepages memory.
                         * Enum: any,2,1024
                         * @param ideN Use volume as IDE hard disk or CD-ROM (n
                         * is 0 to 3). Use the special syntax
                         * STORAGE_ID:SIZE_IN_GiB to allocate a new volume. Use
                         * STORAGE_ID:0 and the 'import-from' parameter to
                         * import from an existing volume.
                         * @param ipconfigN cloud-init: Specify IP addresses and
                         * gateways for the corresponding interface. IP
                         * addresses use CIDR notation, gateways are optional
                         * but need an IP of the same type specified. The
                         * special string 'dhcp' can be used for IP addresses to
                         * use DHCP, in which case no explicit gateway should be
                         * provided. For IPv6 the special string 'auto' can be
                         * used to use stateless autoconfiguration. This
                         * requires cloud-init 19.4 or newer. If cloud-init is
                         * enabled and neither an IPv4 nor an IPv6 address is
                         * specified, it defaults to using dhcp on IPv4.
                         * @param ivshmem Inter-VM shared memory. Useful for
                         * direct communication between VMs, or to the host.
                         * @param keephugepages Use together with hugepages. If
                         * enabled, hugepages will not not be deleted after VM
                         * shutdown and can be used for subsequent starts.
                         * @param keyboard Keyboard layout for VNC server. This
                         * option is generally not required and is often better
                         * handled from within the guest OS. Enum:
                         * de,de-ch,da,en-gb,en-us,es,fi,fr,fr-be,fr-ca,fr-ch,hu,is,it,ja,lt,mk,nl,no,pl,pt,pt-br,sv,sl,tr
                         * @param kvm Enable/disable KVM hardware
                         * virtualization.
                         * @param localtime Set the real time clock (RTC) to
                         * local time. This is enabled by default if the
                         * `ostype` indicates a Microsoft Windows OS.
                         * @param lock_ Lock/unlock the VM. Enum:
                         * backup,clone,create,migrate,rollback,snapshot,snapshot-delete,suspending,suspended
                         * @param machine Specifies the QEMU machine type.
                         * @param memory Memory properties.
                         * @param migrate_downtime Set maximum tolerated
                         * downtime (in seconds) for migrations.
                         * @param migrate_speed Set maximum speed (in MB/s) for
                         * migrations. Value 0 is no limit.
                         * @param name Set a name for the VM. Only used on the
                         * configuration web interface.
                         * @param nameserver cloud-init: Sets DNS server IP
                         * address for a container. Create will automatically
                         * use the setting from the host if neither searchdomain
                         * nor nameserver are set.
                         * @param netN Specify network devices.
                         * @param numa Enable/disable NUMA.
                         * @param numaN NUMA topology.
                         * @param onboot Specifies whether a VM will be started
                         * during system bootup.
                         * @param ostype Specify guest operating system. Enum:
                         * other,wxp,w2k,w2k3,w2k8,wvista,win7,win8,win10,win11,l24,l26,solaris
                         * @param parallelN Map host parallel devices (n is 0 to
                         * 2).
                         * @param protection Sets the protection flag of the VM.
                         * This will disable the remove VM and remove disk
                         * operations.
                         * @param reboot Allow reboot. If set to '0' the VM exit
                         * on reboot.
                         * @param revert Revert a pending change.
                         * @param rng0 Configure a VirtIO-based Random Number
                         * Generator.
                         * @param sataN Use volume as SATA hard disk or CD-ROM
                         * (n is 0 to 5). Use the special syntax
                         * STORAGE_ID:SIZE_IN_GiB to allocate a new volume. Use
                         * STORAGE_ID:0 and the 'import-from' parameter to
                         * import from an existing volume.
                         * @param scsiN Use volume as SCSI hard disk or CD-ROM
                         * (n is 0 to 30). Use the special syntax
                         * STORAGE_ID:SIZE_IN_GiB to allocate a new volume. Use
                         * STORAGE_ID:0 and the 'import-from' parameter to
                         * import from an existing volume.
                         * @param scsihw SCSI controller model Enum:
                         * lsi,lsi53c810,virtio-scsi-pci,virtio-scsi-single,megasas,pvscsi
                         * @param searchdomain cloud-init: Sets DNS search
                         * domains for a container. Create will automatically
                         * use the setting from the host if neither searchdomain
                         * nor nameserver are set.
                         * @param serialN Create a serial device inside the VM
                         * (n is 0 to 3)
                         * @param shares Amount of memory shares for
                         * auto-ballooning. The larger the number is, the more
                         * memory this VM gets. Number is relative to weights of
                         * all other running VMs. Using zero disables
                         * auto-ballooning. Auto-ballooning is done by pvestatd.
                         * @param skiplock Ignore locks - only root is allowed
                         * to use this option.
                         * @param smbios1 Specify SMBIOS type 1 fields.
                         * @param smp The number of CPUs. Please use option
                         * -sockets instead.
                         * @param sockets The number of CPU sockets.
                         * @param spice_enhancements Configure additional
                         * enhancements for SPICE.
                         * @param sshkeys cloud-init: Setup public SSH keys (one
                         * key per line, OpenSSH format).
                         * @param startdate Set the initial date of the real
                         * time clock. Valid format for date are:'now' or
                         * '2006-06-17T16:01:21' or '2006-06-17'.
                         * @param startup Startup and shutdown behavior. Order
                         * is a non-negative number defining the general startup
                         * order. Shutdown in done with reverse ordering.
                         * Additionally you can set the 'up' or 'down' delay in
                         * seconds, which specifies a delay to wait before the
                         * next VM is started or stopped.
                         * @param tablet Enable/disable the USB tablet device.
                         * @param tags Tags of the VM. This is only meta
                         * information.
                         * @param tdf Enable/disable time drift fix.
                         * @param template Enable/disable Template.
                         * @param tpmstate0 Configure a Disk for storing TPM
                         * state. The format is fixed to 'raw'. Use the special
                         * syntax STORAGE_ID:SIZE_IN_GiB to allocate a new
                         * volume. Note that SIZE_IN_GiB is ignored here and 4
                         * MiB will be used instead. Use STORAGE_ID:0 and the
                         * 'import-from' parameter to import from an existing
                         * volume.
                         * @param unusedN Reference to unused volumes. This is
                         * used internally, and should not be modified manually.
                         * @param usbN Configure an USB device (n is 0 to 4, for
                         * machine version &amp;gt;= 7.1 and ostype l26 or
                         * windows &amp;gt; 7, n can be up to 14).
                         * @param vcpus Number of hotplugged vcpus.
                         * @param vga Configure the VGA hardware.
                         * @param virtioN Use volume as VIRTIO hard disk (n is 0
                         * to 15). Use the special syntax STORAGE_ID:SIZE_IN_GiB
                         * to allocate a new volume. Use STORAGE_ID:0 and the
                         * 'import-from' parameter to import from an existing
                         * volume.
                         * @param vmgenid Set VM Generation ID. Use '1' to
                         * autogenerate on create or update, pass '0' to disable
                         * explicitly.
                         * @param vmstatestorage Default storage for VM state
                         * volumes/files.
                         * @param watchdog Create a virtual hardware watchdog
                         * device.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateVm(Boolean acpi, String affinity, String agent, String arch, String args, String audio0, Boolean autostart, Integer balloon, String bios, String boot, String bootdisk, String cdrom, String cicustom, String cipassword, String citype, Boolean ciupgrade, String ciuser, Integer cores, String cpu, Float cpulimit, Integer cpuunits, String delete, String description, String digest, String efidisk0, Boolean force, Boolean freeze, String hookscript, Map<Integer, String> hostpciN, String hotplug, String hugepages, Map<Integer, String> ideN, Map<Integer, String> ipconfigN, String ivshmem, Boolean keephugepages, String keyboard, Boolean kvm, Boolean localtime, String lock_, String machine, String memory, Float migrate_downtime, Integer migrate_speed, String name, String nameserver, Map<Integer, String> netN, Boolean numa, Map<Integer, String> numaN, Boolean onboot, String ostype, Map<Integer, String> parallelN, Boolean protection, Boolean reboot, String revert, String rng0, Map<Integer, String> sataN, Map<Integer, String> scsiN, String scsihw, String searchdomain, Map<Integer, String> serialN, Integer shares, Boolean skiplock, String smbios1, Integer smp, Integer sockets, String spice_enhancements, String sshkeys, String startdate, String startup, Boolean tablet, String tags, Boolean tdf, Boolean template, String tpmstate0, Map<Integer, String> unusedN, Map<Integer, String> usbN, Integer vcpus, String vga, Map<Integer, String> virtioN, String vmgenid, String vmstatestorage, String watchdog) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("acpi", acpi);
                            parameters.put("affinity", affinity);
                            parameters.put("agent", agent);
                            parameters.put("arch", arch);
                            parameters.put("args", args);
                            parameters.put("audio0", audio0);
                            parameters.put("autostart", autostart);
                            parameters.put("balloon", balloon);
                            parameters.put("bios", bios);
                            parameters.put("boot", boot);
                            parameters.put("bootdisk", bootdisk);
                            parameters.put("cdrom", cdrom);
                            parameters.put("cicustom", cicustom);
                            parameters.put("cipassword", cipassword);
                            parameters.put("citype", citype);
                            parameters.put("ciupgrade", ciupgrade);
                            parameters.put("ciuser", ciuser);
                            parameters.put("cores", cores);
                            parameters.put("cpu", cpu);
                            parameters.put("cpulimit", cpulimit);
                            parameters.put("cpuunits", cpuunits);
                            parameters.put("delete", delete);
                            parameters.put("description", description);
                            parameters.put("digest", digest);
                            parameters.put("efidisk0", efidisk0);
                            parameters.put("force", force);
                            parameters.put("freeze", freeze);
                            parameters.put("hookscript", hookscript);
                            parameters.put("hotplug", hotplug);
                            parameters.put("hugepages", hugepages);
                            parameters.put("ivshmem", ivshmem);
                            parameters.put("keephugepages", keephugepages);
                            parameters.put("keyboard", keyboard);
                            parameters.put("kvm", kvm);
                            parameters.put("localtime", localtime);
                            parameters.put("lock", lock_);
                            parameters.put("machine", machine);
                            parameters.put("memory", memory);
                            parameters.put("migrate_downtime", migrate_downtime);
                            parameters.put("migrate_speed", migrate_speed);
                            parameters.put("name", name);
                            parameters.put("nameserver", nameserver);
                            parameters.put("numa", numa);
                            parameters.put("onboot", onboot);
                            parameters.put("ostype", ostype);
                            parameters.put("protection", protection);
                            parameters.put("reboot", reboot);
                            parameters.put("revert", revert);
                            parameters.put("rng0", rng0);
                            parameters.put("scsihw", scsihw);
                            parameters.put("searchdomain", searchdomain);
                            parameters.put("shares", shares);
                            parameters.put("skiplock", skiplock);
                            parameters.put("smbios1", smbios1);
                            parameters.put("smp", smp);
                            parameters.put("sockets", sockets);
                            parameters.put("spice_enhancements", spice_enhancements);
                            parameters.put("sshkeys", sshkeys);
                            parameters.put("startdate", startdate);
                            parameters.put("startup", startup);
                            parameters.put("tablet", tablet);
                            parameters.put("tags", tags);
                            parameters.put("tdf", tdf);
                            parameters.put("template", template);
                            parameters.put("tpmstate0", tpmstate0);
                            parameters.put("vcpus", vcpus);
                            parameters.put("vga", vga);
                            parameters.put("vmgenid", vmgenid);
                            parameters.put("vmstatestorage", vmstatestorage);
                            parameters.put("watchdog", watchdog);
                            addIndexedParameter(parameters, "hostpci", hostpciN);
                            addIndexedParameter(parameters, "ide", ideN);
                            addIndexedParameter(parameters, "ipconfig", ipconfigN);
                            addIndexedParameter(parameters, "net", netN);
                            addIndexedParameter(parameters, "numa", numaN);
                            addIndexedParameter(parameters, "parallel", parallelN);
                            addIndexedParameter(parameters, "sata", sataN);
                            addIndexedParameter(parameters, "scsi", scsiN);
                            addIndexedParameter(parameters, "serial", serialN);
                            addIndexedParameter(parameters, "unused", unusedN);
                            addIndexedParameter(parameters, "usb", usbN);
                            addIndexedParameter(parameters, "virtio", virtioN);
                            return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/config", parameters);
                        }

                        /**
                         * Set virtual machine options (synchrounous API) - You
                         * should consider using the POST method instead for any
                         * actions involving hotplug or storage allocation.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateVm() throws JSONException {
                            return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/config", null);
                        }

                    }

                    public class PVEPending {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEPending(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Get the virtual machine configuration with both
                         * current and pending values.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vmPending() throws JSONException {
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/pending", null);
                        }

                    }

                    public class PVECloudinit {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVECloudinit(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        private PVEDump dump;

                        public PVEDump getDump() {
                            return dump == null ? (dump = new PVEDump(client, this.node, this.vmid)) : dump;
                        }

                        public class PVEDump {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEDump(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Get automatically generated cloudinit config.
                             *
                             * @param type Config type. Enum: user,network,meta
                             * @return Result
                             * @throws JSONException
                             */
                            public Result cloudinitGeneratedConfigDump(String type) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("type", type);
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/cloudinit/dump", parameters);
                            }

                        }

                        /**
                         * Get the cloudinit configuration with both current and
                         * pending values.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result cloudinitPending() throws JSONException {
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/cloudinit", null);
                        }

                        /**
                         * Regenerate and change cloudinit config drive.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result cloudinitUpdate() throws JSONException {
                            return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/cloudinit", null);
                        }

                    }

                    public class PVEUnlink {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEUnlink(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Unlink/delete disk images.
                         *
                         * @param idlist A list of disk IDs you want to delete.
                         * @param force Force physical removal. Without this, we
                         * simple remove the disk from the config file and
                         * create an additional configuration entry called
                         * 'unused[n]', which contains the volume ID. Unlink of
                         * unused[n] always cause physical removal.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result unlink(String idlist, Boolean force) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("idlist", idlist);
                            parameters.put("force", force);
                            return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/unlink", parameters);
                        }

                        /**
                         * Unlink/delete disk images.
                         *
                         * @param idlist A list of disk IDs you want to delete.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result unlink(String idlist) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("idlist", idlist);
                            return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/unlink", parameters);
                        }

                    }

                    public class PVEVncproxy {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEVncproxy(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Creates a TCP VNC proxy connections.
                         *
                         * @param generate_password Generates a random password
                         * to be used as ticket instead of the API ticket.
                         * @param websocket Prepare for websocket upgrade (only
                         * required when using serial terminal, otherwise
                         * upgrade is always possible).
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vncproxy(Boolean generate_password, Boolean websocket) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("generate-password", generate_password);
                            parameters.put("websocket", websocket);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/vncproxy", parameters);
                        }

                        /**
                         * Creates a TCP VNC proxy connections.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result vncproxy() throws JSONException {
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/vncproxy", null);
                        }

                    }

                    public class PVETermproxy {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVETermproxy(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Creates a TCP proxy connections.
                         *
                         * @param serial opens a serial terminal (defaults to
                         * display) Enum: serial0,serial1,serial2,serial3
                         * @return Result
                         * @throws JSONException
                         */
                        public Result termproxy(String serial) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("serial", serial);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/termproxy", parameters);
                        }

                        /**
                         * Creates a TCP proxy connections.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result termproxy() throws JSONException {
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/termproxy", null);
                        }

                    }

                    public class PVEVncwebsocket {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEVncwebsocket(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Opens a weksocket for VNC traffic.
                         *
                         * @param port Port number returned by previous vncproxy
                         * call.
                         * @param vncticket Ticket from previous call to
                         * vncproxy.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vncwebsocket(int port, String vncticket) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("port", port);
                            parameters.put("vncticket", vncticket);
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/vncwebsocket", parameters);
                        }

                    }

                    public class PVESpiceproxy {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVESpiceproxy(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Returns a SPICE configuration to connect to the VM.
                         *
                         * @param proxy SPICE proxy server. This can be used by
                         * the client to specify the proxy server. All nodes in
                         * a cluster runs 'spiceproxy', so it is up to the
                         * client to choose one. By default, we return the node
                         * where the VM is currently running. As reasonable
                         * setting is to use same node you use to connect to the
                         * API (This is window.location.hostname for the JS
                         * GUI).
                         * @return Result
                         * @throws JSONException
                         */
                        public Result spiceproxy(String proxy) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("proxy", proxy);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/spiceproxy", parameters);
                        }

                        /**
                         * Returns a SPICE configuration to connect to the VM.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result spiceproxy() throws JSONException {
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/spiceproxy", null);
                        }

                    }

                    public class PVEStatus {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEStatus(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        private PVECurrent current;

                        public PVECurrent getCurrent() {
                            return current == null ? (current = new PVECurrent(client, this.node, this.vmid)) : current;
                        }
                        private PVEStart start;

                        public PVEStart getStart() {
                            return start == null ? (start = new PVEStart(client, this.node, this.vmid)) : start;
                        }
                        private PVEStop stop;

                        public PVEStop getStop() {
                            return stop == null ? (stop = new PVEStop(client, this.node, this.vmid)) : stop;
                        }
                        private PVEReset reset;

                        public PVEReset getReset() {
                            return reset == null ? (reset = new PVEReset(client, this.node, this.vmid)) : reset;
                        }
                        private PVEShutdown shutdown;

                        public PVEShutdown getShutdown() {
                            return shutdown == null ? (shutdown = new PVEShutdown(client, this.node, this.vmid)) : shutdown;
                        }
                        private PVEReboot reboot;

                        public PVEReboot getReboot() {
                            return reboot == null ? (reboot = new PVEReboot(client, this.node, this.vmid)) : reboot;
                        }
                        private PVESuspend suspend;

                        public PVESuspend getSuspend() {
                            return suspend == null ? (suspend = new PVESuspend(client, this.node, this.vmid)) : suspend;
                        }
                        private PVEResume resume;

                        public PVEResume getResume() {
                            return resume == null ? (resume = new PVEResume(client, this.node, this.vmid)) : resume;
                        }

                        public class PVECurrent {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVECurrent(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Get virtual machine status.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmStatus() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/current", null);
                            }

                        }

                        public class PVEStart {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEStart(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Start virtual machine.
                             *
                             * @param force_cpu Override QEMU's -cpu argument
                             * with the given string.
                             * @param machine Specifies the QEMU machine type.
                             * @param migratedfrom The cluster node name.
                             * @param migration_network CIDR of the (sub)
                             * network that is used for migration.
                             * @param migration_type Migration traffic is
                             * encrypted using an SSH tunnel by default. On
                             * secure, completely private networks this can be
                             * disabled to increase performance. Enum:
                             * secure,insecure
                             * @param skiplock Ignore locks - only root is
                             * allowed to use this option.
                             * @param stateuri Some command save/restore state
                             * from this location.
                             * @param targetstorage Mapping from source to
                             * target storages. Providing only a single storage
                             * ID maps all source storages to that storage.
                             * Providing the special value '1' will map each
                             * source storage to itself.
                             * @param timeout Wait maximal timeout seconds.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmStart(String force_cpu, String machine, String migratedfrom, String migration_network, String migration_type, Boolean skiplock, String stateuri, String targetstorage, Integer timeout) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("force-cpu", force_cpu);
                                parameters.put("machine", machine);
                                parameters.put("migratedfrom", migratedfrom);
                                parameters.put("migration_network", migration_network);
                                parameters.put("migration_type", migration_type);
                                parameters.put("skiplock", skiplock);
                                parameters.put("stateuri", stateuri);
                                parameters.put("targetstorage", targetstorage);
                                parameters.put("timeout", timeout);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/start", parameters);
                            }

                            /**
                             * Start virtual machine.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result vmStart() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/start", null);
                            }

                        }

                        public class PVEStop {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEStop(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Stop virtual machine. The qemu process will exit
                             * immediately. Thisis akin to pulling the power
                             * plug of a running computer and may damage the VM
                             * data
                             *
                             * @param keepActive Do not deactivate storage
                             * volumes.
                             * @param migratedfrom The cluster node name.
                             * @param skiplock Ignore locks - only root is
                             * allowed to use this option.
                             * @param timeout Wait maximal timeout seconds.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmStop(Boolean keepActive, String migratedfrom, Boolean skiplock, Integer timeout) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("keepActive", keepActive);
                                parameters.put("migratedfrom", migratedfrom);
                                parameters.put("skiplock", skiplock);
                                parameters.put("timeout", timeout);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/stop", parameters);
                            }

                            /**
                             * Stop virtual machine. The qemu process will exit
                             * immediately. Thisis akin to pulling the power
                             * plug of a running computer and may damage the VM
                             * data
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result vmStop() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/stop", null);
                            }

                        }

                        public class PVEReset {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEReset(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Reset virtual machine.
                             *
                             * @param skiplock Ignore locks - only root is
                             * allowed to use this option.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmReset(Boolean skiplock) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("skiplock", skiplock);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/reset", parameters);
                            }

                            /**
                             * Reset virtual machine.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result vmReset() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/reset", null);
                            }

                        }

                        public class PVEShutdown {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEShutdown(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Shutdown virtual machine. This is similar to
                             * pressing the power button on a physical
                             * machine.This will send an ACPI event for the
                             * guest OS, which should then proceed to a clean
                             * shutdown.
                             *
                             * @param forceStop Make sure the VM stops.
                             * @param keepActive Do not deactivate storage
                             * volumes.
                             * @param skiplock Ignore locks - only root is
                             * allowed to use this option.
                             * @param timeout Wait maximal timeout seconds.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmShutdown(Boolean forceStop, Boolean keepActive, Boolean skiplock, Integer timeout) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("forceStop", forceStop);
                                parameters.put("keepActive", keepActive);
                                parameters.put("skiplock", skiplock);
                                parameters.put("timeout", timeout);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/shutdown", parameters);
                            }

                            /**
                             * Shutdown virtual machine. This is similar to
                             * pressing the power button on a physical
                             * machine.This will send an ACPI event for the
                             * guest OS, which should then proceed to a clean
                             * shutdown.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result vmShutdown() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/shutdown", null);
                            }

                        }

                        public class PVEReboot {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEReboot(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Reboot the VM by shutting it down, and starting
                             * it again. Applies pending changes.
                             *
                             * @param timeout Wait maximal timeout seconds for
                             * the shutdown.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmReboot(Integer timeout) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("timeout", timeout);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/reboot", parameters);
                            }

                            /**
                             * Reboot the VM by shutting it down, and starting
                             * it again. Applies pending changes.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result vmReboot() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/reboot", null);
                            }

                        }

                        public class PVESuspend {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVESuspend(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Suspend virtual machine.
                             *
                             * @param skiplock Ignore locks - only root is
                             * allowed to use this option.
                             * @param statestorage The storage for the VM state
                             * @param todisk If set, suspends the VM to disk.
                             * Will be resumed on next VM start.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmSuspend(Boolean skiplock, String statestorage, Boolean todisk) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("skiplock", skiplock);
                                parameters.put("statestorage", statestorage);
                                parameters.put("todisk", todisk);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/suspend", parameters);
                            }

                            /**
                             * Suspend virtual machine.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result vmSuspend() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/suspend", null);
                            }

                        }

                        public class PVEResume {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEResume(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Resume virtual machine.
                             *
                             * @param nocheck
                             * @param skiplock Ignore locks - only root is
                             * allowed to use this option.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmResume(Boolean nocheck, Boolean skiplock) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("nocheck", nocheck);
                                parameters.put("skiplock", skiplock);
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/resume", parameters);
                            }

                            /**
                             * Resume virtual machine.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result vmResume() throws JSONException {
                                return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/status/resume", null);
                            }

                        }

                        /**
                         * Directory index
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vmcmdidx() throws JSONException {
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/status", null);
                        }

                    }

                    public class PVESendkey {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVESendkey(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Send key event to virtual machine.
                         *
                         * @param key The key (qemu monitor encoding).
                         * @param skiplock Ignore locks - only root is allowed
                         * to use this option.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vmSendkey(String key, Boolean skiplock) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("key", key);
                            parameters.put("skiplock", skiplock);
                            return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/sendkey", parameters);
                        }

                        /**
                         * Send key event to virtual machine.
                         *
                         * @param key The key (qemu monitor encoding).
                         * @return Result
                         * @throws JSONException
                         */

                        public Result vmSendkey(String key) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("key", key);
                            return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/sendkey", parameters);
                        }

                    }

                    public class PVEFeature {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEFeature(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Check if feature for virtual machine is available.
                         *
                         * @param feature Feature to check. Enum:
                         * snapshot,clone,copy
                         * @param snapname The name of the snapshot.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vmFeature(String feature, String snapname) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("feature", feature);
                            parameters.put("snapname", snapname);
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/feature", parameters);
                        }

                        /**
                         * Check if feature for virtual machine is available.
                         *
                         * @param feature Feature to check. Enum:
                         * snapshot,clone,copy
                         * @return Result
                         * @throws JSONException
                         */

                        public Result vmFeature(String feature) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("feature", feature);
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/feature", parameters);
                        }

                    }

                    public class PVEClone {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEClone(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Create a copy of virtual machine/template.
                         *
                         * @param newid VMID for the clone.
                         * @param bwlimit Override I/O bandwidth limit (in
                         * KiB/s).
                         * @param description Description for the new VM.
                         * @param format Target format for file storage. Only
                         * valid for full clone. Enum: raw,qcow2,vmdk
                         * @param full Create a full copy of all disks. This is
                         * always done when you clone a normal VM. For VM
                         * templates, we try to create a linked clone by
                         * default.
                         * @param name Set a name for the new VM.
                         * @param pool Add the new VM to the specified pool.
                         * @param snapname The name of the snapshot.
                         * @param storage Target storage for full clone.
                         * @param target Target node. Only allowed if the
                         * original VM is on shared storage.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result cloneVm(int newid, Integer bwlimit, String description, String format, Boolean full, String name, String pool, String snapname, String storage, String target) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("newid", newid);
                            parameters.put("bwlimit", bwlimit);
                            parameters.put("description", description);
                            parameters.put("format", format);
                            parameters.put("full", full);
                            parameters.put("name", name);
                            parameters.put("pool", pool);
                            parameters.put("snapname", snapname);
                            parameters.put("storage", storage);
                            parameters.put("target", target);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/clone", parameters);
                        }

                        /**
                         * Create a copy of virtual machine/template.
                         *
                         * @param newid VMID for the clone.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result cloneVm(int newid) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("newid", newid);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/clone", parameters);
                        }

                    }

                    public class PVEMoveDisk {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEMoveDisk(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Move volume to different storage or to a different
                         * VM.
                         *
                         * @param disk The disk you want to move. Enum:
                         * ide0,ide1,ide2,ide3,scsi0,scsi1,scsi2,scsi3,scsi4,scsi5,scsi6,scsi7,scsi8,scsi9,scsi10,scsi11,scsi12,scsi13,scsi14,scsi15,scsi16,scsi17,scsi18,scsi19,scsi20,scsi21,scsi22,scsi23,scsi24,scsi25,scsi26,scsi27,scsi28,scsi29,scsi30,virtio0,virtio1,virtio2,virtio3,virtio4,virtio5,virtio6,virtio7,virtio8,virtio9,virtio10,virtio11,virtio12,virtio13,virtio14,virtio15,sata0,sata1,sata2,sata3,sata4,sata5,efidisk0,tpmstate0,unused0,unused1,unused2,unused3,unused4,unused5,unused6,unused7,unused8,unused9,unused10,unused11,unused12,unused13,unused14,unused15,unused16,unused17,unused18,unused19,unused20,unused21,unused22,unused23,unused24,unused25,unused26,unused27,unused28,unused29,unused30,unused31,unused32,unused33,unused34,unused35,unused36,unused37,unused38,unused39,unused40,unused41,unused42,unused43,unused44,unused45,unused46,unused47,unused48,unused49,unused50,unused51,unused52,unused53,unused54,unused55,unused56,unused57,unused58,unused59,unused60,unused61,unused62,unused63,unused64,unused65,unused66,unused67,unused68,unused69,unused70,unused71,unused72,unused73,unused74,unused75,unused76,unused77,unused78,unused79,unused80,unused81,unused82,unused83,unused84,unused85,unused86,unused87,unused88,unused89,unused90,unused91,unused92,unused93,unused94,unused95,unused96,unused97,unused98,unused99,unused100,unused101,unused102,unused103,unused104,unused105,unused106,unused107,unused108,unused109,unused110,unused111,unused112,unused113,unused114,unused115,unused116,unused117,unused118,unused119,unused120,unused121,unused122,unused123,unused124,unused125,unused126,unused127,unused128,unused129,unused130,unused131,unused132,unused133,unused134,unused135,unused136,unused137,unused138,unused139,unused140,unused141,unused142,unused143,unused144,unused145,unused146,unused147,unused148,unused149,unused150,unused151,unused152,unused153,unused154,unused155,unused156,unused157,unused158,unused159,unused160,unused161,unused162,unused163,unused164,unused165,unused166,unused167,unused168,unused169,unused170,unused171,unused172,unused173,unused174,unused175,unused176,unused177,unused178,unused179,unused180,unused181,unused182,unused183,unused184,unused185,unused186,unused187,unused188,unused189,unused190,unused191,unused192,unused193,unused194,unused195,unused196,unused197,unused198,unused199,unused200,unused201,unused202,unused203,unused204,unused205,unused206,unused207,unused208,unused209,unused210,unused211,unused212,unused213,unused214,unused215,unused216,unused217,unused218,unused219,unused220,unused221,unused222,unused223,unused224,unused225,unused226,unused227,unused228,unused229,unused230,unused231,unused232,unused233,unused234,unused235,unused236,unused237,unused238,unused239,unused240,unused241,unused242,unused243,unused244,unused245,unused246,unused247,unused248,unused249,unused250,unused251,unused252,unused253,unused254,unused255
                         * @param bwlimit Override I/O bandwidth limit (in
                         * KiB/s).
                         * @param delete Delete the original disk after
                         * successful copy. By default the original disk is kept
                         * as unused disk.
                         * @param digest Prevent changes if current
                         * configuration file has different SHA1" ." digest.
                         * This can be used to prevent concurrent modifications.
                         * @param format Target Format. Enum: raw,qcow2,vmdk
                         * @param storage Target storage.
                         * @param target_digest Prevent changes if the current
                         * config file of the target VM has a" ." different SHA1
                         * digest. This can be used to detect concurrent
                         * modifications.
                         * @param target_disk The config key the disk will be
                         * moved to on the target VM (for example, ide0 or
                         * scsi1). Default is the source disk key. Enum:
                         * ide0,ide1,ide2,ide3,scsi0,scsi1,scsi2,scsi3,scsi4,scsi5,scsi6,scsi7,scsi8,scsi9,scsi10,scsi11,scsi12,scsi13,scsi14,scsi15,scsi16,scsi17,scsi18,scsi19,scsi20,scsi21,scsi22,scsi23,scsi24,scsi25,scsi26,scsi27,scsi28,scsi29,scsi30,virtio0,virtio1,virtio2,virtio3,virtio4,virtio5,virtio6,virtio7,virtio8,virtio9,virtio10,virtio11,virtio12,virtio13,virtio14,virtio15,sata0,sata1,sata2,sata3,sata4,sata5,efidisk0,tpmstate0,unused0,unused1,unused2,unused3,unused4,unused5,unused6,unused7,unused8,unused9,unused10,unused11,unused12,unused13,unused14,unused15,unused16,unused17,unused18,unused19,unused20,unused21,unused22,unused23,unused24,unused25,unused26,unused27,unused28,unused29,unused30,unused31,unused32,unused33,unused34,unused35,unused36,unused37,unused38,unused39,unused40,unused41,unused42,unused43,unused44,unused45,unused46,unused47,unused48,unused49,unused50,unused51,unused52,unused53,unused54,unused55,unused56,unused57,unused58,unused59,unused60,unused61,unused62,unused63,unused64,unused65,unused66,unused67,unused68,unused69,unused70,unused71,unused72,unused73,unused74,unused75,unused76,unused77,unused78,unused79,unused80,unused81,unused82,unused83,unused84,unused85,unused86,unused87,unused88,unused89,unused90,unused91,unused92,unused93,unused94,unused95,unused96,unused97,unused98,unused99,unused100,unused101,unused102,unused103,unused104,unused105,unused106,unused107,unused108,unused109,unused110,unused111,unused112,unused113,unused114,unused115,unused116,unused117,unused118,unused119,unused120,unused121,unused122,unused123,unused124,unused125,unused126,unused127,unused128,unused129,unused130,unused131,unused132,unused133,unused134,unused135,unused136,unused137,unused138,unused139,unused140,unused141,unused142,unused143,unused144,unused145,unused146,unused147,unused148,unused149,unused150,unused151,unused152,unused153,unused154,unused155,unused156,unused157,unused158,unused159,unused160,unused161,unused162,unused163,unused164,unused165,unused166,unused167,unused168,unused169,unused170,unused171,unused172,unused173,unused174,unused175,unused176,unused177,unused178,unused179,unused180,unused181,unused182,unused183,unused184,unused185,unused186,unused187,unused188,unused189,unused190,unused191,unused192,unused193,unused194,unused195,unused196,unused197,unused198,unused199,unused200,unused201,unused202,unused203,unused204,unused205,unused206,unused207,unused208,unused209,unused210,unused211,unused212,unused213,unused214,unused215,unused216,unused217,unused218,unused219,unused220,unused221,unused222,unused223,unused224,unused225,unused226,unused227,unused228,unused229,unused230,unused231,unused232,unused233,unused234,unused235,unused236,unused237,unused238,unused239,unused240,unused241,unused242,unused243,unused244,unused245,unused246,unused247,unused248,unused249,unused250,unused251,unused252,unused253,unused254,unused255
                         * @param target_vmid The (unique) ID of the VM.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result moveVmDisk(String disk, Integer bwlimit, Boolean delete, String digest, String format, String storage, String target_digest, String target_disk, Integer target_vmid) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("disk", disk);
                            parameters.put("bwlimit", bwlimit);
                            parameters.put("delete", delete);
                            parameters.put("digest", digest);
                            parameters.put("format", format);
                            parameters.put("storage", storage);
                            parameters.put("target-digest", target_digest);
                            parameters.put("target-disk", target_disk);
                            parameters.put("target-vmid", target_vmid);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/move_disk", parameters);
                        }

                        /**
                         * Move volume to different storage or to a different
                         * VM.
                         *
                         * @param disk The disk you want to move. Enum:
                         * ide0,ide1,ide2,ide3,scsi0,scsi1,scsi2,scsi3,scsi4,scsi5,scsi6,scsi7,scsi8,scsi9,scsi10,scsi11,scsi12,scsi13,scsi14,scsi15,scsi16,scsi17,scsi18,scsi19,scsi20,scsi21,scsi22,scsi23,scsi24,scsi25,scsi26,scsi27,scsi28,scsi29,scsi30,virtio0,virtio1,virtio2,virtio3,virtio4,virtio5,virtio6,virtio7,virtio8,virtio9,virtio10,virtio11,virtio12,virtio13,virtio14,virtio15,sata0,sata1,sata2,sata3,sata4,sata5,efidisk0,tpmstate0,unused0,unused1,unused2,unused3,unused4,unused5,unused6,unused7,unused8,unused9,unused10,unused11,unused12,unused13,unused14,unused15,unused16,unused17,unused18,unused19,unused20,unused21,unused22,unused23,unused24,unused25,unused26,unused27,unused28,unused29,unused30,unused31,unused32,unused33,unused34,unused35,unused36,unused37,unused38,unused39,unused40,unused41,unused42,unused43,unused44,unused45,unused46,unused47,unused48,unused49,unused50,unused51,unused52,unused53,unused54,unused55,unused56,unused57,unused58,unused59,unused60,unused61,unused62,unused63,unused64,unused65,unused66,unused67,unused68,unused69,unused70,unused71,unused72,unused73,unused74,unused75,unused76,unused77,unused78,unused79,unused80,unused81,unused82,unused83,unused84,unused85,unused86,unused87,unused88,unused89,unused90,unused91,unused92,unused93,unused94,unused95,unused96,unused97,unused98,unused99,unused100,unused101,unused102,unused103,unused104,unused105,unused106,unused107,unused108,unused109,unused110,unused111,unused112,unused113,unused114,unused115,unused116,unused117,unused118,unused119,unused120,unused121,unused122,unused123,unused124,unused125,unused126,unused127,unused128,unused129,unused130,unused131,unused132,unused133,unused134,unused135,unused136,unused137,unused138,unused139,unused140,unused141,unused142,unused143,unused144,unused145,unused146,unused147,unused148,unused149,unused150,unused151,unused152,unused153,unused154,unused155,unused156,unused157,unused158,unused159,unused160,unused161,unused162,unused163,unused164,unused165,unused166,unused167,unused168,unused169,unused170,unused171,unused172,unused173,unused174,unused175,unused176,unused177,unused178,unused179,unused180,unused181,unused182,unused183,unused184,unused185,unused186,unused187,unused188,unused189,unused190,unused191,unused192,unused193,unused194,unused195,unused196,unused197,unused198,unused199,unused200,unused201,unused202,unused203,unused204,unused205,unused206,unused207,unused208,unused209,unused210,unused211,unused212,unused213,unused214,unused215,unused216,unused217,unused218,unused219,unused220,unused221,unused222,unused223,unused224,unused225,unused226,unused227,unused228,unused229,unused230,unused231,unused232,unused233,unused234,unused235,unused236,unused237,unused238,unused239,unused240,unused241,unused242,unused243,unused244,unused245,unused246,unused247,unused248,unused249,unused250,unused251,unused252,unused253,unused254,unused255
                         * @return Result
                         * @throws JSONException
                         */

                        public Result moveVmDisk(String disk) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("disk", disk);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/move_disk", parameters);
                        }

                    }

                    public class PVEMigrate {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEMigrate(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Get preconditions for migration.
                         *
                         * @param target Target node.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result migrateVmPrecondition(String target) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("target", target);
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/migrate", parameters);
                        }

                        /**
                         * Get preconditions for migration.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result migrateVmPrecondition() throws JSONException {
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/migrate", null);
                        }

                        /**
                         * Migrate virtual machine. Creates a new migration
                         * task.
                         *
                         * @param target Target node.
                         * @param bwlimit Override I/O bandwidth limit (in
                         * KiB/s).
                         * @param force Allow to migrate VMs which use local
                         * devices. Only root may use this option.
                         * @param migration_network CIDR of the (sub) network
                         * that is used for migration.
                         * @param migration_type Migration traffic is encrypted
                         * using an SSH tunnel by default. On secure, completely
                         * private networks this can be disabled to increase
                         * performance. Enum: secure,insecure
                         * @param online Use online/live migration if VM is
                         * running. Ignored if VM is stopped.
                         * @param targetstorage Mapping from source to target
                         * storages. Providing only a single storage ID maps all
                         * source storages to that storage. Providing the
                         * special value '1' will map each source storage to
                         * itself.
                         * @param with_local_disks Enable live storage migration
                         * for local disk
                         * @return Result
                         * @throws JSONException
                         */

                        public Result migrateVm(String target, Integer bwlimit, Boolean force, String migration_network, String migration_type, Boolean online, String targetstorage, Boolean with_local_disks) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("target", target);
                            parameters.put("bwlimit", bwlimit);
                            parameters.put("force", force);
                            parameters.put("migration_network", migration_network);
                            parameters.put("migration_type", migration_type);
                            parameters.put("online", online);
                            parameters.put("targetstorage", targetstorage);
                            parameters.put("with-local-disks", with_local_disks);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/migrate", parameters);
                        }

                        /**
                         * Migrate virtual machine. Creates a new migration
                         * task.
                         *
                         * @param target Target node.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result migrateVm(String target) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("target", target);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/migrate", parameters);
                        }

                    }

                    public class PVERemoteMigrate {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVERemoteMigrate(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Migrate virtual machine to a remote cluster. Creates
                         * a new migration task. EXPERIMENTAL feature!
                         *
                         * @param target_bridge Mapping from source to target
                         * bridges. Providing only a single bridge ID maps all
                         * source bridges to that bridge. Providing the special
                         * value '1' will map each source bridge to itself.
                         * @param target_endpoint Remote target endpoint
                         * @param target_storage Mapping from source to target
                         * storages. Providing only a single storage ID maps all
                         * source storages to that storage. Providing the
                         * special value '1' will map each source storage to
                         * itself.
                         * @param bwlimit Override I/O bandwidth limit (in
                         * KiB/s).
                         * @param delete Delete the original VM and related data
                         * after successful migration. By default the original
                         * VM is kept on the source cluster in a stopped state.
                         * @param online Use online/live migration if VM is
                         * running. Ignored if VM is stopped.
                         * @param target_vmid The (unique) ID of the VM.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result remoteMigrateVm(String target_bridge, String target_endpoint, String target_storage, Integer bwlimit, Boolean delete, Boolean online, Integer target_vmid) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("target-bridge", target_bridge);
                            parameters.put("target-endpoint", target_endpoint);
                            parameters.put("target-storage", target_storage);
                            parameters.put("bwlimit", bwlimit);
                            parameters.put("delete", delete);
                            parameters.put("online", online);
                            parameters.put("target-vmid", target_vmid);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/remote_migrate", parameters);
                        }

                        /**
                         * Migrate virtual machine to a remote cluster. Creates
                         * a new migration task. EXPERIMENTAL feature!
                         *
                         * @param target_bridge Mapping from source to target
                         * bridges. Providing only a single bridge ID maps all
                         * source bridges to that bridge. Providing the special
                         * value '1' will map each source bridge to itself.
                         * @param target_endpoint Remote target endpoint
                         * @param target_storage Mapping from source to target
                         * storages. Providing only a single storage ID maps all
                         * source storages to that storage. Providing the
                         * special value '1' will map each source storage to
                         * itself.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result remoteMigrateVm(String target_bridge, String target_endpoint, String target_storage) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("target-bridge", target_bridge);
                            parameters.put("target-endpoint", target_endpoint);
                            parameters.put("target-storage", target_storage);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/remote_migrate", parameters);
                        }

                    }

                    public class PVEMonitor {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEMonitor(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Execute QEMU monitor commands.
                         *
                         * @param command The monitor command.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result monitor(String command) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("command", command);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/monitor", parameters);
                        }

                    }

                    public class PVEResize {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEResize(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Extend volume size.
                         *
                         * @param disk The disk you want to resize. Enum:
                         * ide0,ide1,ide2,ide3,scsi0,scsi1,scsi2,scsi3,scsi4,scsi5,scsi6,scsi7,scsi8,scsi9,scsi10,scsi11,scsi12,scsi13,scsi14,scsi15,scsi16,scsi17,scsi18,scsi19,scsi20,scsi21,scsi22,scsi23,scsi24,scsi25,scsi26,scsi27,scsi28,scsi29,scsi30,virtio0,virtio1,virtio2,virtio3,virtio4,virtio5,virtio6,virtio7,virtio8,virtio9,virtio10,virtio11,virtio12,virtio13,virtio14,virtio15,sata0,sata1,sata2,sata3,sata4,sata5,efidisk0,tpmstate0
                         * @param size The new size. With the `+` sign the value
                         * is added to the actual size of the volume and without
                         * it, the value is taken as an absolute one. Shrinking
                         * disk size is not supported.
                         * @param digest Prevent changes if current
                         * configuration file has different SHA1 digest. This
                         * can be used to prevent concurrent modifications.
                         * @param skiplock Ignore locks - only root is allowed
                         * to use this option.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result resizeVm(String disk, String size, String digest, Boolean skiplock) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("disk", disk);
                            parameters.put("size", size);
                            parameters.put("digest", digest);
                            parameters.put("skiplock", skiplock);
                            return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/resize", parameters);
                        }

                        /**
                         * Extend volume size.
                         *
                         * @param disk The disk you want to resize. Enum:
                         * ide0,ide1,ide2,ide3,scsi0,scsi1,scsi2,scsi3,scsi4,scsi5,scsi6,scsi7,scsi8,scsi9,scsi10,scsi11,scsi12,scsi13,scsi14,scsi15,scsi16,scsi17,scsi18,scsi19,scsi20,scsi21,scsi22,scsi23,scsi24,scsi25,scsi26,scsi27,scsi28,scsi29,scsi30,virtio0,virtio1,virtio2,virtio3,virtio4,virtio5,virtio6,virtio7,virtio8,virtio9,virtio10,virtio11,virtio12,virtio13,virtio14,virtio15,sata0,sata1,sata2,sata3,sata4,sata5,efidisk0,tpmstate0
                         * @param size The new size. With the `+` sign the value
                         * is added to the actual size of the volume and without
                         * it, the value is taken as an absolute one. Shrinking
                         * disk size is not supported.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result resizeVm(String disk, String size) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("disk", disk);
                            parameters.put("size", size);
                            return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/resize", parameters);
                        }

                    }

                    public class PVESnapshot {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVESnapshot(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        public PVESnapnameItem get(Object snapname) {
                            return new PVESnapnameItem(client, this.node, this.vmid, snapname);
                        }

                        public class PVESnapnameItem {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;
                            private final Object snapname;

                            protected PVESnapnameItem(PveClient client, Object node, Object vmid, Object snapname) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                                this.snapname = snapname;
                            }

                            private PVEConfig config;

                            public PVEConfig getConfig() {
                                return config == null ? (config = new PVEConfig(client, this.node, this.vmid, this.snapname)) : config;
                            }
                            private PVERollback rollback;

                            public PVERollback getRollback() {
                                return rollback == null ? (rollback = new PVERollback(client, this.node, this.vmid, this.snapname)) : rollback;
                            }

                            public class PVEConfig {

                                private final PveClient client;
                                private final Object node;
                                private final Object vmid;
                                private final Object snapname;

                                protected PVEConfig(PveClient client, Object node, Object vmid, Object snapname) {
                                    this.client = client;
                                    this.node = node;
                                    this.vmid = vmid;
                                    this.snapname = snapname;
                                }

                                /**
                                 * Get snapshot configuration
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */
                                public Result getSnapshotConfig() throws JSONException {
                                    return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/snapshot/" + this.snapname + "/config", null);
                                }

                                /**
                                 * Update snapshot metadata.
                                 *
                                 * @param description A textual description or
                                 * comment.
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateSnapshotConfig(String description) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("description", description);
                                    return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/snapshot/" + this.snapname + "/config", parameters);
                                }

                                /**
                                 * Update snapshot metadata.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateSnapshotConfig() throws JSONException {
                                    return client.set("/nodes/" + this.node + "/qemu/" + this.vmid + "/snapshot/" + this.snapname + "/config", null);
                                }

                            }

                            public class PVERollback {

                                private final PveClient client;
                                private final Object node;
                                private final Object vmid;
                                private final Object snapname;

                                protected PVERollback(PveClient client, Object node, Object vmid, Object snapname) {
                                    this.client = client;
                                    this.node = node;
                                    this.vmid = vmid;
                                    this.snapname = snapname;
                                }

                                /**
                                 * Rollback VM state to specified snapshot.
                                 *
                                 * @param start Whether the VM should get
                                 * started after rolling back successfully.
                                 * (Note: VMs will be automatically started if
                                 * the snapshot includes RAM.)
                                 * @return Result
                                 * @throws JSONException
                                 */
                                public Result rollback(Boolean start) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("start", start);
                                    return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/snapshot/" + this.snapname + "/rollback", parameters);
                                }

                                /**
                                 * Rollback VM state to specified snapshot.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result rollback() throws JSONException {
                                    return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/snapshot/" + this.snapname + "/rollback", null);
                                }

                            }

                            /**
                             * Delete a VM snapshot.
                             *
                             * @param force For removal from config file, even
                             * if removing disk snapshots fails.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result delsnapshot(Boolean force) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("force", force);
                                return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "/snapshot/" + this.snapname + "", parameters);
                            }

                            /**
                             * Delete a VM snapshot.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result delsnapshot() throws JSONException {
                                return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "/snapshot/" + this.snapname + "", null);
                            }

                            /**
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result snapshotCmdIdx() throws JSONException {
                                return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/snapshot/" + this.snapname + "", null);
                            }

                        }

                        /**
                         * List all snapshots.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result snapshotList() throws JSONException {
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/snapshot", null);
                        }

                        /**
                         * Snapshot a VM.
                         *
                         * @param snapname The name of the snapshot.
                         * @param description A textual description or comment.
                         * @param vmstate Save the vmstate
                         * @return Result
                         * @throws JSONException
                         */

                        public Result snapshot(String snapname, String description, Boolean vmstate) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("snapname", snapname);
                            parameters.put("description", description);
                            parameters.put("vmstate", vmstate);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/snapshot", parameters);
                        }

                        /**
                         * Snapshot a VM.
                         *
                         * @param snapname The name of the snapshot.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result snapshot(String snapname) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("snapname", snapname);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/snapshot", parameters);
                        }

                    }

                    public class PVETemplate {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVETemplate(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Create a Template.
                         *
                         * @param disk If you want to convert only 1 disk to
                         * base image. Enum:
                         * ide0,ide1,ide2,ide3,scsi0,scsi1,scsi2,scsi3,scsi4,scsi5,scsi6,scsi7,scsi8,scsi9,scsi10,scsi11,scsi12,scsi13,scsi14,scsi15,scsi16,scsi17,scsi18,scsi19,scsi20,scsi21,scsi22,scsi23,scsi24,scsi25,scsi26,scsi27,scsi28,scsi29,scsi30,virtio0,virtio1,virtio2,virtio3,virtio4,virtio5,virtio6,virtio7,virtio8,virtio9,virtio10,virtio11,virtio12,virtio13,virtio14,virtio15,sata0,sata1,sata2,sata3,sata4,sata5,efidisk0,tpmstate0
                         * @return Result
                         * @throws JSONException
                         */
                        public Result template(String disk) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("disk", disk);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/template", parameters);
                        }

                        /**
                         * Create a Template.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result template() throws JSONException {
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/template", null);
                        }

                    }

                    public class PVEMtunnel {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEMtunnel(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Migration tunnel endpoint - only for internal use by
                         * VM migration.
                         *
                         * @param bridges List of network bridges to check
                         * availability. Will be checked again for actually used
                         * bridges during migration.
                         * @param storages List of storages to check permission
                         * and availability. Will be checked again for all
                         * actually used storages during migration.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result mtunnel(String bridges, String storages) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("bridges", bridges);
                            parameters.put("storages", storages);
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/mtunnel", parameters);
                        }

                        /**
                         * Migration tunnel endpoint - only for internal use by
                         * VM migration.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result mtunnel() throws JSONException {
                            return client.create("/nodes/" + this.node + "/qemu/" + this.vmid + "/mtunnel", null);
                        }

                    }

                    public class PVEMtunnelwebsocket {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEMtunnelwebsocket(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Migration tunnel endpoint for websocket upgrade -
                         * only for internal use by VM migration.
                         *
                         * @param socket unix socket to forward to
                         * @param ticket ticket return by initial 'mtunnel' API
                         * call, or retrieved via 'ticket' tunnel command
                         * @return Result
                         * @throws JSONException
                         */
                        public Result mtunnelwebsocket(String socket, String ticket) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("socket", socket);
                            parameters.put("ticket", ticket);
                            return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "/mtunnelwebsocket", parameters);
                        }

                    }

                    /**
                     * Destroy the VM and all used/owned volumes. Removes any VM
                     * specific permissions and firewall rules
                     *
                     * @param destroy_unreferenced_disks If set, destroy
                     * additionally all disks not referenced in the config but
                     * with a matching VMID from all enabled storages.
                     * @param purge Remove VMID from configurations, like backup
                     * &amp; replication jobs and HA.
                     * @param skiplock Ignore locks - only root is allowed to
                     * use this option.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result destroyVm(Boolean destroy_unreferenced_disks, Boolean purge, Boolean skiplock) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("destroy-unreferenced-disks", destroy_unreferenced_disks);
                        parameters.put("purge", purge);
                        parameters.put("skiplock", skiplock);
                        return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "", parameters);
                    }

                    /**
                     * Destroy the VM and all used/owned volumes. Removes any VM
                     * specific permissions and firewall rules
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result destroyVm() throws JSONException {
                        return client.delete("/nodes/" + this.node + "/qemu/" + this.vmid + "", null);
                    }

                    /**
                     * Directory index
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result vmdiridx() throws JSONException {
                        return client.get("/nodes/" + this.node + "/qemu/" + this.vmid + "", null);
                    }

                }

                /**
                 * Virtual machine index (per node).
                 *
                 * @param full Determine the full status of active VMs.
                 * @return Result
                 * @throws JSONException
                 */
                public Result vmlist(Boolean full) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("full", full);
                    return client.get("/nodes/" + this.node + "/qemu", parameters);
                }

                /**
                 * Virtual machine index (per node).
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result vmlist() throws JSONException {
                    return client.get("/nodes/" + this.node + "/qemu", null);
                }

                /**
                 * Create or restore a virtual machine.
                 *
                 * @param vmid The (unique) ID of the VM.
                 * @param acpi Enable/disable ACPI.
                 * @param affinity List of host cores used to execute guest
                 * processes, for example: 0,5,8-11
                 * @param agent Enable/disable communication with the QEMU Guest
                 * Agent and its properties.
                 * @param arch Virtual processor architecture. Defaults to the
                 * host. Enum: x86_64,aarch64
                 * @param archive The backup archive. Either the file system
                 * path to a .tar or .vma file (use '-' to pipe data from stdin)
                 * or a proxmox storage backup volume identifier.
                 * @param args Arbitrary arguments passed to kvm.
                 * @param audio0 Configure a audio device, useful in combination
                 * with QXL/Spice.
                 * @param autostart Automatic restart after crash (currently
                 * ignored).
                 * @param balloon Amount of target RAM for the VM in MiB. Using
                 * zero disables the ballon driver.
                 * @param bios Select BIOS implementation. Enum: seabios,ovmf
                 * @param boot Specify guest boot order. Use the 'order='
                 * sub-property as usage with no key or 'legacy=' is deprecated.
                 * @param bootdisk Enable booting from specified disk.
                 * Deprecated: Use 'boot: order=foo;bar' instead.
                 * @param bwlimit Override I/O bandwidth limit (in KiB/s).
                 * @param cdrom This is an alias for option -ide2
                 * @param cicustom cloud-init: Specify custom files to replace
                 * the automatically generated ones at start.
                 * @param cipassword cloud-init: Password to assign the user.
                 * Using this is generally not recommended. Use ssh keys
                 * instead. Also note that older cloud-init versions do not
                 * support hashed passwords.
                 * @param citype Specifies the cloud-init configuration format.
                 * The default depends on the configured operating system type
                 * (`ostype`. We use the `nocloud` format for Linux, and
                 * `configdrive2` for windows. Enum:
                 * configdrive2,nocloud,opennebula
                 * @param ciupgrade cloud-init: do an automatic package upgrade
                 * after the first boot.
                 * @param ciuser cloud-init: User name to change ssh keys and
                 * password for instead of the image's configured default user.
                 * @param cores The number of cores per socket.
                 * @param cpu Emulated CPU type.
                 * @param cpulimit Limit of CPU usage.
                 * @param cpuunits CPU weight for a VM, will be clamped to [1,
                 * 10000] in cgroup v2.
                 * @param description Description for the VM. Shown in the
                 * web-interface VM's summary. This is saved as comment inside
                 * the configuration file.
                 * @param efidisk0 Configure a disk for storing EFI vars. Use
                 * the special syntax STORAGE_ID:SIZE_IN_GiB to allocate a new
                 * volume. Note that SIZE_IN_GiB is ignored here and that the
                 * default EFI vars are copied to the volume instead. Use
                 * STORAGE_ID:0 and the 'import-from' parameter to import from
                 * an existing volume.
                 * @param force Allow to overwrite existing VM.
                 * @param freeze Freeze CPU at startup (use 'c' monitor command
                 * to start execution).
                 * @param hookscript Script that will be executed during various
                 * steps in the vms lifetime.
                 * @param hostpciN Map host PCI devices into guest.
                 * @param hotplug Selectively enable hotplug features. This is a
                 * comma separated list of hotplug features: 'network', 'disk',
                 * 'cpu', 'memory', 'usb' and 'cloudinit'. Use '0' to disable
                 * hotplug completely. Using '1' as value is an alias for the
                 * default `network,disk,usb`. USB hotplugging is possible for
                 * guests with machine version &amp;gt;= 7.1 and ostype l26 or
                 * windows &amp;gt; 7.
                 * @param hugepages Enable/disable hugepages memory. Enum:
                 * any,2,1024
                 * @param ideN Use volume as IDE hard disk or CD-ROM (n is 0 to
                 * 3). Use the special syntax STORAGE_ID:SIZE_IN_GiB to allocate
                 * a new volume. Use STORAGE_ID:0 and the 'import-from'
                 * parameter to import from an existing volume.
                 * @param ipconfigN cloud-init: Specify IP addresses and
                 * gateways for the corresponding interface. IP addresses use
                 * CIDR notation, gateways are optional but need an IP of the
                 * same type specified. The special string 'dhcp' can be used
                 * for IP addresses to use DHCP, in which case no explicit
                 * gateway should be provided. For IPv6 the special string
                 * 'auto' can be used to use stateless autoconfiguration. This
                 * requires cloud-init 19.4 or newer. If cloud-init is enabled
                 * and neither an IPv4 nor an IPv6 address is specified, it
                 * defaults to using dhcp on IPv4.
                 * @param ivshmem Inter-VM shared memory. Useful for direct
                 * communication between VMs, or to the host.
                 * @param keephugepages Use together with hugepages. If enabled,
                 * hugepages will not not be deleted after VM shutdown and can
                 * be used for subsequent starts.
                 * @param keyboard Keyboard layout for VNC server. This option
                 * is generally not required and is often better handled from
                 * within the guest OS. Enum:
                 * de,de-ch,da,en-gb,en-us,es,fi,fr,fr-be,fr-ca,fr-ch,hu,is,it,ja,lt,mk,nl,no,pl,pt,pt-br,sv,sl,tr
                 * @param kvm Enable/disable KVM hardware virtualization.
                 * @param live_restore Start the VM immediately from the backup
                 * and restore in background. PBS only.
                 * @param localtime Set the real time clock (RTC) to local time.
                 * This is enabled by default if the `ostype` indicates a
                 * Microsoft Windows OS.
                 * @param lock_ Lock/unlock the VM. Enum:
                 * backup,clone,create,migrate,rollback,snapshot,snapshot-delete,suspending,suspended
                 * @param machine Specifies the QEMU machine type.
                 * @param memory Memory properties.
                 * @param migrate_downtime Set maximum tolerated downtime (in
                 * seconds) for migrations.
                 * @param migrate_speed Set maximum speed (in MB/s) for
                 * migrations. Value 0 is no limit.
                 * @param name Set a name for the VM. Only used on the
                 * configuration web interface.
                 * @param nameserver cloud-init: Sets DNS server IP address for
                 * a container. Create will automatically use the setting from
                 * the host if neither searchdomain nor nameserver are set.
                 * @param netN Specify network devices.
                 * @param numa Enable/disable NUMA.
                 * @param numaN NUMA topology.
                 * @param onboot Specifies whether a VM will be started during
                 * system bootup.
                 * @param ostype Specify guest operating system. Enum:
                 * other,wxp,w2k,w2k3,w2k8,wvista,win7,win8,win10,win11,l24,l26,solaris
                 * @param parallelN Map host parallel devices (n is 0 to 2).
                 * @param pool Add the VM to the specified pool.
                 * @param protection Sets the protection flag of the VM. This
                 * will disable the remove VM and remove disk operations.
                 * @param reboot Allow reboot. If set to '0' the VM exit on
                 * reboot.
                 * @param rng0 Configure a VirtIO-based Random Number Generator.
                 * @param sataN Use volume as SATA hard disk or CD-ROM (n is 0
                 * to 5). Use the special syntax STORAGE_ID:SIZE_IN_GiB to
                 * allocate a new volume. Use STORAGE_ID:0 and the 'import-from'
                 * parameter to import from an existing volume.
                 * @param scsiN Use volume as SCSI hard disk or CD-ROM (n is 0
                 * to 30). Use the special syntax STORAGE_ID:SIZE_IN_GiB to
                 * allocate a new volume. Use STORAGE_ID:0 and the 'import-from'
                 * parameter to import from an existing volume.
                 * @param scsihw SCSI controller model Enum:
                 * lsi,lsi53c810,virtio-scsi-pci,virtio-scsi-single,megasas,pvscsi
                 * @param searchdomain cloud-init: Sets DNS search domains for a
                 * container. Create will automatically use the setting from the
                 * host if neither searchdomain nor nameserver are set.
                 * @param serialN Create a serial device inside the VM (n is 0
                 * to 3)
                 * @param shares Amount of memory shares for auto-ballooning.
                 * The larger the number is, the more memory this VM gets.
                 * Number is relative to weights of all other running VMs. Using
                 * zero disables auto-ballooning. Auto-ballooning is done by
                 * pvestatd.
                 * @param smbios1 Specify SMBIOS type 1 fields.
                 * @param smp The number of CPUs. Please use option -sockets
                 * instead.
                 * @param sockets The number of CPU sockets.
                 * @param spice_enhancements Configure additional enhancements
                 * for SPICE.
                 * @param sshkeys cloud-init: Setup public SSH keys (one key per
                 * line, OpenSSH format).
                 * @param start Start VM after it was created successfully.
                 * @param startdate Set the initial date of the real time clock.
                 * Valid format for date are:'now' or '2006-06-17T16:01:21' or
                 * '2006-06-17'.
                 * @param startup Startup and shutdown behavior. Order is a
                 * non-negative number defining the general startup order.
                 * Shutdown in done with reverse ordering. Additionally you can
                 * set the 'up' or 'down' delay in seconds, which specifies a
                 * delay to wait before the next VM is started or stopped.
                 * @param storage Default storage.
                 * @param tablet Enable/disable the USB tablet device.
                 * @param tags Tags of the VM. This is only meta information.
                 * @param tdf Enable/disable time drift fix.
                 * @param template Enable/disable Template.
                 * @param tpmstate0 Configure a Disk for storing TPM state. The
                 * format is fixed to 'raw'. Use the special syntax
                 * STORAGE_ID:SIZE_IN_GiB to allocate a new volume. Note that
                 * SIZE_IN_GiB is ignored here and 4 MiB will be used instead.
                 * Use STORAGE_ID:0 and the 'import-from' parameter to import
                 * from an existing volume.
                 * @param unique Assign a unique random ethernet address.
                 * @param unusedN Reference to unused volumes. This is used
                 * internally, and should not be modified manually.
                 * @param usbN Configure an USB device (n is 0 to 4, for machine
                 * version &amp;gt;= 7.1 and ostype l26 or windows &amp;gt; 7, n
                 * can be up to 14).
                 * @param vcpus Number of hotplugged vcpus.
                 * @param vga Configure the VGA hardware.
                 * @param virtioN Use volume as VIRTIO hard disk (n is 0 to 15).
                 * Use the special syntax STORAGE_ID:SIZE_IN_GiB to allocate a
                 * new volume. Use STORAGE_ID:0 and the 'import-from' parameter
                 * to import from an existing volume.
                 * @param vmgenid Set VM Generation ID. Use '1' to autogenerate
                 * on create or update, pass '0' to disable explicitly.
                 * @param vmstatestorage Default storage for VM state
                 * volumes/files.
                 * @param watchdog Create a virtual hardware watchdog device.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createVm(int vmid, Boolean acpi, String affinity, String agent, String arch, String archive, String args, String audio0, Boolean autostart, Integer balloon, String bios, String boot, String bootdisk, Integer bwlimit, String cdrom, String cicustom, String cipassword, String citype, Boolean ciupgrade, String ciuser, Integer cores, String cpu, Float cpulimit, Integer cpuunits, String description, String efidisk0, Boolean force, Boolean freeze, String hookscript, Map<Integer, String> hostpciN, String hotplug, String hugepages, Map<Integer, String> ideN, Map<Integer, String> ipconfigN, String ivshmem, Boolean keephugepages, String keyboard, Boolean kvm, Boolean live_restore, Boolean localtime, String lock_, String machine, String memory, Float migrate_downtime, Integer migrate_speed, String name, String nameserver, Map<Integer, String> netN, Boolean numa, Map<Integer, String> numaN, Boolean onboot, String ostype, Map<Integer, String> parallelN, String pool, Boolean protection, Boolean reboot, String rng0, Map<Integer, String> sataN, Map<Integer, String> scsiN, String scsihw, String searchdomain, Map<Integer, String> serialN, Integer shares, String smbios1, Integer smp, Integer sockets, String spice_enhancements, String sshkeys, Boolean start, String startdate, String startup, String storage, Boolean tablet, String tags, Boolean tdf, Boolean template, String tpmstate0, Boolean unique, Map<Integer, String> unusedN, Map<Integer, String> usbN, Integer vcpus, String vga, Map<Integer, String> virtioN, String vmgenid, String vmstatestorage, String watchdog) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("vmid", vmid);
                    parameters.put("acpi", acpi);
                    parameters.put("affinity", affinity);
                    parameters.put("agent", agent);
                    parameters.put("arch", arch);
                    parameters.put("archive", archive);
                    parameters.put("args", args);
                    parameters.put("audio0", audio0);
                    parameters.put("autostart", autostart);
                    parameters.put("balloon", balloon);
                    parameters.put("bios", bios);
                    parameters.put("boot", boot);
                    parameters.put("bootdisk", bootdisk);
                    parameters.put("bwlimit", bwlimit);
                    parameters.put("cdrom", cdrom);
                    parameters.put("cicustom", cicustom);
                    parameters.put("cipassword", cipassword);
                    parameters.put("citype", citype);
                    parameters.put("ciupgrade", ciupgrade);
                    parameters.put("ciuser", ciuser);
                    parameters.put("cores", cores);
                    parameters.put("cpu", cpu);
                    parameters.put("cpulimit", cpulimit);
                    parameters.put("cpuunits", cpuunits);
                    parameters.put("description", description);
                    parameters.put("efidisk0", efidisk0);
                    parameters.put("force", force);
                    parameters.put("freeze", freeze);
                    parameters.put("hookscript", hookscript);
                    parameters.put("hotplug", hotplug);
                    parameters.put("hugepages", hugepages);
                    parameters.put("ivshmem", ivshmem);
                    parameters.put("keephugepages", keephugepages);
                    parameters.put("keyboard", keyboard);
                    parameters.put("kvm", kvm);
                    parameters.put("live-restore", live_restore);
                    parameters.put("localtime", localtime);
                    parameters.put("lock", lock_);
                    parameters.put("machine", machine);
                    parameters.put("memory", memory);
                    parameters.put("migrate_downtime", migrate_downtime);
                    parameters.put("migrate_speed", migrate_speed);
                    parameters.put("name", name);
                    parameters.put("nameserver", nameserver);
                    parameters.put("numa", numa);
                    parameters.put("onboot", onboot);
                    parameters.put("ostype", ostype);
                    parameters.put("pool", pool);
                    parameters.put("protection", protection);
                    parameters.put("reboot", reboot);
                    parameters.put("rng0", rng0);
                    parameters.put("scsihw", scsihw);
                    parameters.put("searchdomain", searchdomain);
                    parameters.put("shares", shares);
                    parameters.put("smbios1", smbios1);
                    parameters.put("smp", smp);
                    parameters.put("sockets", sockets);
                    parameters.put("spice_enhancements", spice_enhancements);
                    parameters.put("sshkeys", sshkeys);
                    parameters.put("start", start);
                    parameters.put("startdate", startdate);
                    parameters.put("startup", startup);
                    parameters.put("storage", storage);
                    parameters.put("tablet", tablet);
                    parameters.put("tags", tags);
                    parameters.put("tdf", tdf);
                    parameters.put("template", template);
                    parameters.put("tpmstate0", tpmstate0);
                    parameters.put("unique", unique);
                    parameters.put("vcpus", vcpus);
                    parameters.put("vga", vga);
                    parameters.put("vmgenid", vmgenid);
                    parameters.put("vmstatestorage", vmstatestorage);
                    parameters.put("watchdog", watchdog);
                    addIndexedParameter(parameters, "hostpci", hostpciN);
                    addIndexedParameter(parameters, "ide", ideN);
                    addIndexedParameter(parameters, "ipconfig", ipconfigN);
                    addIndexedParameter(parameters, "net", netN);
                    addIndexedParameter(parameters, "numa", numaN);
                    addIndexedParameter(parameters, "parallel", parallelN);
                    addIndexedParameter(parameters, "sata", sataN);
                    addIndexedParameter(parameters, "scsi", scsiN);
                    addIndexedParameter(parameters, "serial", serialN);
                    addIndexedParameter(parameters, "unused", unusedN);
                    addIndexedParameter(parameters, "usb", usbN);
                    addIndexedParameter(parameters, "virtio", virtioN);
                    return client.create("/nodes/" + this.node + "/qemu", parameters);
                }

                /**
                 * Create or restore a virtual machine.
                 *
                 * @param vmid The (unique) ID of the VM.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createVm(int vmid) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("vmid", vmid);
                    return client.create("/nodes/" + this.node + "/qemu", parameters);
                }

            }

            public class PVELxc {

                private final PveClient client;
                private final Object node;

                protected PVELxc(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                public PVEVmidItem get(Object vmid) {
                    return new PVEVmidItem(client, this.node, vmid);
                }

                public class PVEVmidItem {

                    private final PveClient client;
                    private final Object node;
                    private final Object vmid;

                    protected PVEVmidItem(PveClient client, Object node, Object vmid) {
                        this.client = client;
                        this.node = node;
                        this.vmid = vmid;
                    }

                    private PVEConfig config;

                    public PVEConfig getConfig() {
                        return config == null ? (config = new PVEConfig(client, this.node, this.vmid)) : config;
                    }
                    private PVEStatus status;

                    public PVEStatus getStatus() {
                        return status == null ? (status = new PVEStatus(client, this.node, this.vmid)) : status;
                    }
                    private PVESnapshot snapshot;

                    public PVESnapshot getSnapshot() {
                        return snapshot == null ? (snapshot = new PVESnapshot(client, this.node, this.vmid)) : snapshot;
                    }
                    private PVEFirewall firewall;

                    public PVEFirewall getFirewall() {
                        return firewall == null ? (firewall = new PVEFirewall(client, this.node, this.vmid)) : firewall;
                    }
                    private PVERrd rrd;

                    public PVERrd getRrd() {
                        return rrd == null ? (rrd = new PVERrd(client, this.node, this.vmid)) : rrd;
                    }
                    private PVERrddata rrddata;

                    public PVERrddata getRrddata() {
                        return rrddata == null ? (rrddata = new PVERrddata(client, this.node, this.vmid)) : rrddata;
                    }
                    private PVEVncproxy vncproxy;

                    public PVEVncproxy getVncproxy() {
                        return vncproxy == null ? (vncproxy = new PVEVncproxy(client, this.node, this.vmid)) : vncproxy;
                    }
                    private PVETermproxy termproxy;

                    public PVETermproxy getTermproxy() {
                        return termproxy == null ? (termproxy = new PVETermproxy(client, this.node, this.vmid)) : termproxy;
                    }
                    private PVEVncwebsocket vncwebsocket;

                    public PVEVncwebsocket getVncwebsocket() {
                        return vncwebsocket == null ? (vncwebsocket = new PVEVncwebsocket(client, this.node, this.vmid)) : vncwebsocket;
                    }
                    private PVESpiceproxy spiceproxy;

                    public PVESpiceproxy getSpiceproxy() {
                        return spiceproxy == null ? (spiceproxy = new PVESpiceproxy(client, this.node, this.vmid)) : spiceproxy;
                    }
                    private PVERemoteMigrate remoteMigrate;

                    public PVERemoteMigrate getRemoteMigrate() {
                        return remoteMigrate == null ? (remoteMigrate = new PVERemoteMigrate(client, this.node, this.vmid)) : remoteMigrate;
                    }
                    private PVEMigrate migrate;

                    public PVEMigrate getMigrate() {
                        return migrate == null ? (migrate = new PVEMigrate(client, this.node, this.vmid)) : migrate;
                    }
                    private PVEFeature feature;

                    public PVEFeature getFeature() {
                        return feature == null ? (feature = new PVEFeature(client, this.node, this.vmid)) : feature;
                    }
                    private PVETemplate template;

                    public PVETemplate getTemplate() {
                        return template == null ? (template = new PVETemplate(client, this.node, this.vmid)) : template;
                    }
                    private PVEClone clone;

                    public PVEClone getClone() {
                        return clone == null ? (clone = new PVEClone(client, this.node, this.vmid)) : clone;
                    }
                    private PVEResize resize;

                    public PVEResize getResize() {
                        return resize == null ? (resize = new PVEResize(client, this.node, this.vmid)) : resize;
                    }
                    private PVEMoveVolume moveVolume;

                    public PVEMoveVolume getMoveVolume() {
                        return moveVolume == null ? (moveVolume = new PVEMoveVolume(client, this.node, this.vmid)) : moveVolume;
                    }
                    private PVEPending pending;

                    public PVEPending getPending() {
                        return pending == null ? (pending = new PVEPending(client, this.node, this.vmid)) : pending;
                    }
                    private PVEInterfaces interfaces;

                    public PVEInterfaces getInterfaces() {
                        return interfaces == null ? (interfaces = new PVEInterfaces(client, this.node, this.vmid)) : interfaces;
                    }
                    private PVEMtunnel mtunnel;

                    public PVEMtunnel getMtunnel() {
                        return mtunnel == null ? (mtunnel = new PVEMtunnel(client, this.node, this.vmid)) : mtunnel;
                    }
                    private PVEMtunnelwebsocket mtunnelwebsocket;

                    public PVEMtunnelwebsocket getMtunnelwebsocket() {
                        return mtunnelwebsocket == null ? (mtunnelwebsocket = new PVEMtunnelwebsocket(client, this.node, this.vmid)) : mtunnelwebsocket;
                    }

                    public class PVEConfig {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEConfig(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Get container configuration.
                         *
                         * @param current Get current values (instead of pending
                         * values).
                         * @param snapshot Fetch config values from given
                         * snapshot.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vmConfig(Boolean current, String snapshot) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("current", current);
                            parameters.put("snapshot", snapshot);
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/config", parameters);
                        }

                        /**
                         * Get container configuration.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result vmConfig() throws JSONException {
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/config", null);
                        }

                        /**
                         * Set container options.
                         *
                         * @param arch OS architecture type. Enum:
                         * amd64,i386,arm64,armhf,riscv32,riscv64
                         * @param cmode Console mode. By default, the console
                         * command tries to open a connection to one of the
                         * available tty devices. By setting cmode to 'console'
                         * it tries to attach to /dev/console instead. If you
                         * set cmode to 'shell', it simply invokes a shell
                         * inside the container (no login). Enum:
                         * shell,console,tty
                         * @param console Attach a console device (/dev/console)
                         * to the container.
                         * @param cores The number of cores assigned to the
                         * container. A container can use all available cores by
                         * default.
                         * @param cpulimit Limit of CPU usage. NOTE: If the
                         * computer has 2 CPUs, it has a total of '2' CPU time.
                         * Value '0' indicates no CPU limit.
                         * @param cpuunits CPU weight for a container, will be
                         * clamped to [1, 10000] in cgroup v2.
                         * @param debug Try to be more verbose. For now this
                         * only enables debug log-level on start.
                         * @param delete A list of settings you want to delete.
                         * @param description Description for the Container.
                         * Shown in the web-interface CT's summary. This is
                         * saved as comment inside the configuration file.
                         * @param devN Device to pass through to the container
                         * @param digest Prevent changes if current
                         * configuration file has different SHA1 digest. This
                         * can be used to prevent concurrent modifications.
                         * @param features Allow containers access to advanced
                         * features.
                         * @param hookscript Script that will be exectued during
                         * various steps in the containers lifetime.
                         * @param hostname Set a host name for the container.
                         * @param lock_ Lock/unlock the container. Enum:
                         * backup,create,destroyed,disk,fstrim,migrate,mounted,rollback,snapshot,snapshot-delete
                         * @param memory Amount of RAM for the container in MB.
                         * @param mpN Use volume as container mount point. Use
                         * the special syntax STORAGE_ID:SIZE_IN_GiB to allocate
                         * a new volume.
                         * @param nameserver Sets DNS server IP address for a
                         * container. Create will automatically use the setting
                         * from the host if you neither set searchdomain nor
                         * nameserver.
                         * @param netN Specifies network interfaces for the
                         * container.
                         * @param onboot Specifies whether a container will be
                         * started during system bootup.
                         * @param ostype OS type. This is used to setup
                         * configuration inside the container, and corresponds
                         * to lxc setup scripts in
                         * /usr/share/lxc/config/&amp;lt;ostype&amp;gt;.common.conf.
                         * Value 'unmanaged' can be used to skip and OS specific
                         * setup. Enum:
                         * debian,devuan,ubuntu,centos,fedora,opensuse,archlinux,alpine,gentoo,nixos,unmanaged
                         * @param protection Sets the protection flag of the
                         * container. This will prevent the CT or CT's disk
                         * remove/update operation.
                         * @param revert Revert a pending change.
                         * @param rootfs Use volume as container root.
                         * @param searchdomain Sets DNS search domains for a
                         * container. Create will automatically use the setting
                         * from the host if you neither set searchdomain nor
                         * nameserver.
                         * @param startup Startup and shutdown behavior. Order
                         * is a non-negative number defining the general startup
                         * order. Shutdown in done with reverse ordering.
                         * Additionally you can set the 'up' or 'down' delay in
                         * seconds, which specifies a delay to wait before the
                         * next VM is started or stopped.
                         * @param swap Amount of SWAP for the container in MB.
                         * @param tags Tags of the Container. This is only meta
                         * information.
                         * @param template Enable/disable Template.
                         * @param timezone Time zone to use in the container. If
                         * option isn't set, then nothing will be done. Can be
                         * set to 'host' to match the host time zone, or an
                         * arbitrary time zone option from
                         * /usr/share/zoneinfo/zone.tab
                         * @param tty Specify the number of tty available to the
                         * container
                         * @param unprivileged Makes the container run as
                         * unprivileged user. (Should not be modified manually.)
                         * @param unusedN Reference to unused volumes. This is
                         * used internally, and should not be modified manually.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateVm(String arch, String cmode, Boolean console, Integer cores, Float cpulimit, Integer cpuunits, Boolean debug, String delete, String description, Map<Integer, String> devN, String digest, String features, String hookscript, String hostname, String lock_, Integer memory, Map<Integer, String> mpN, String nameserver, Map<Integer, String> netN, Boolean onboot, String ostype, Boolean protection, String revert, String rootfs, String searchdomain, String startup, Integer swap, String tags, Boolean template, String timezone, Integer tty, Boolean unprivileged, Map<Integer, String> unusedN) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("arch", arch);
                            parameters.put("cmode", cmode);
                            parameters.put("console", console);
                            parameters.put("cores", cores);
                            parameters.put("cpulimit", cpulimit);
                            parameters.put("cpuunits", cpuunits);
                            parameters.put("debug", debug);
                            parameters.put("delete", delete);
                            parameters.put("description", description);
                            parameters.put("digest", digest);
                            parameters.put("features", features);
                            parameters.put("hookscript", hookscript);
                            parameters.put("hostname", hostname);
                            parameters.put("lock", lock_);
                            parameters.put("memory", memory);
                            parameters.put("nameserver", nameserver);
                            parameters.put("onboot", onboot);
                            parameters.put("ostype", ostype);
                            parameters.put("protection", protection);
                            parameters.put("revert", revert);
                            parameters.put("rootfs", rootfs);
                            parameters.put("searchdomain", searchdomain);
                            parameters.put("startup", startup);
                            parameters.put("swap", swap);
                            parameters.put("tags", tags);
                            parameters.put("template", template);
                            parameters.put("timezone", timezone);
                            parameters.put("tty", tty);
                            parameters.put("unprivileged", unprivileged);
                            addIndexedParameter(parameters, "dev", devN);
                            addIndexedParameter(parameters, "mp", mpN);
                            addIndexedParameter(parameters, "net", netN);
                            addIndexedParameter(parameters, "unused", unusedN);
                            return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/config", parameters);
                        }

                        /**
                         * Set container options.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateVm() throws JSONException {
                            return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/config", null);
                        }

                    }

                    public class PVEStatus {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEStatus(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        private PVECurrent current;

                        public PVECurrent getCurrent() {
                            return current == null ? (current = new PVECurrent(client, this.node, this.vmid)) : current;
                        }
                        private PVEStart start;

                        public PVEStart getStart() {
                            return start == null ? (start = new PVEStart(client, this.node, this.vmid)) : start;
                        }
                        private PVEStop stop;

                        public PVEStop getStop() {
                            return stop == null ? (stop = new PVEStop(client, this.node, this.vmid)) : stop;
                        }
                        private PVEShutdown shutdown;

                        public PVEShutdown getShutdown() {
                            return shutdown == null ? (shutdown = new PVEShutdown(client, this.node, this.vmid)) : shutdown;
                        }
                        private PVESuspend suspend;

                        public PVESuspend getSuspend() {
                            return suspend == null ? (suspend = new PVESuspend(client, this.node, this.vmid)) : suspend;
                        }
                        private PVEResume resume;

                        public PVEResume getResume() {
                            return resume == null ? (resume = new PVEResume(client, this.node, this.vmid)) : resume;
                        }
                        private PVEReboot reboot;

                        public PVEReboot getReboot() {
                            return reboot == null ? (reboot = new PVEReboot(client, this.node, this.vmid)) : reboot;
                        }

                        public class PVECurrent {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVECurrent(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Get virtual machine status.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmStatus() throws JSONException {
                                return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/status/current", null);
                            }

                        }

                        public class PVEStart {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEStart(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Start the container.
                             *
                             * @param debug If set, enables very verbose debug
                             * log-level on start.
                             * @param skiplock Ignore locks - only root is
                             * allowed to use this option.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmStart(Boolean debug, Boolean skiplock) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("debug", debug);
                                parameters.put("skiplock", skiplock);
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/status/start", parameters);
                            }

                            /**
                             * Start the container.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result vmStart() throws JSONException {
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/status/start", null);
                            }

                        }

                        public class PVEStop {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEStop(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Stop the container. This will abruptly stop all
                             * processes running in the container.
                             *
                             * @param skiplock Ignore locks - only root is
                             * allowed to use this option.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmStop(Boolean skiplock) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("skiplock", skiplock);
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/status/stop", parameters);
                            }

                            /**
                             * Stop the container. This will abruptly stop all
                             * processes running in the container.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result vmStop() throws JSONException {
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/status/stop", null);
                            }

                        }

                        public class PVEShutdown {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEShutdown(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Shutdown the container. This will trigger a clean
                             * shutdown of the container, see lxc-stop(1) for
                             * details.
                             *
                             * @param forceStop Make sure the Container stops.
                             * @param timeout Wait maximal timeout seconds.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmShutdown(Boolean forceStop, Integer timeout) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("forceStop", forceStop);
                                parameters.put("timeout", timeout);
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/status/shutdown", parameters);
                            }

                            /**
                             * Shutdown the container. This will trigger a clean
                             * shutdown of the container, see lxc-stop(1) for
                             * details.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result vmShutdown() throws JSONException {
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/status/shutdown", null);
                            }

                        }

                        public class PVESuspend {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVESuspend(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Suspend the container. This is experimental.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmSuspend() throws JSONException {
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/status/suspend", null);
                            }

                        }

                        public class PVEResume {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEResume(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Resume the container.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmResume() throws JSONException {
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/status/resume", null);
                            }

                        }

                        public class PVEReboot {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEReboot(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Reboot the container by shutting it down, and
                             * starting it again. Applies pending changes.
                             *
                             * @param timeout Wait maximal timeout seconds for
                             * the shutdown.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result vmReboot(Integer timeout) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("timeout", timeout);
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/status/reboot", parameters);
                            }

                            /**
                             * Reboot the container by shutting it down, and
                             * starting it again. Applies pending changes.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result vmReboot() throws JSONException {
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/status/reboot", null);
                            }

                        }

                        /**
                         * Directory index
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vmcmdidx() throws JSONException {
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/status", null);
                        }

                    }

                    public class PVESnapshot {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVESnapshot(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        public PVESnapnameItem get(Object snapname) {
                            return new PVESnapnameItem(client, this.node, this.vmid, snapname);
                        }

                        public class PVESnapnameItem {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;
                            private final Object snapname;

                            protected PVESnapnameItem(PveClient client, Object node, Object vmid, Object snapname) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                                this.snapname = snapname;
                            }

                            private PVERollback rollback;

                            public PVERollback getRollback() {
                                return rollback == null ? (rollback = new PVERollback(client, this.node, this.vmid, this.snapname)) : rollback;
                            }
                            private PVEConfig config;

                            public PVEConfig getConfig() {
                                return config == null ? (config = new PVEConfig(client, this.node, this.vmid, this.snapname)) : config;
                            }

                            public class PVERollback {

                                private final PveClient client;
                                private final Object node;
                                private final Object vmid;
                                private final Object snapname;

                                protected PVERollback(PveClient client, Object node, Object vmid, Object snapname) {
                                    this.client = client;
                                    this.node = node;
                                    this.vmid = vmid;
                                    this.snapname = snapname;
                                }

                                /**
                                 * Rollback LXC state to specified snapshot.
                                 *
                                 * @param start Whether the container should get
                                 * started after rolling back successfully
                                 * @return Result
                                 * @throws JSONException
                                 */
                                public Result rollback(Boolean start) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("start", start);
                                    return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/snapshot/" + this.snapname + "/rollback", parameters);
                                }

                                /**
                                 * Rollback LXC state to specified snapshot.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result rollback() throws JSONException {
                                    return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/snapshot/" + this.snapname + "/rollback", null);
                                }

                            }

                            public class PVEConfig {

                                private final PveClient client;
                                private final Object node;
                                private final Object vmid;
                                private final Object snapname;

                                protected PVEConfig(PveClient client, Object node, Object vmid, Object snapname) {
                                    this.client = client;
                                    this.node = node;
                                    this.vmid = vmid;
                                    this.snapname = snapname;
                                }

                                /**
                                 * Get snapshot configuration
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */
                                public Result getSnapshotConfig() throws JSONException {
                                    return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/snapshot/" + this.snapname + "/config", null);
                                }

                                /**
                                 * Update snapshot metadata.
                                 *
                                 * @param description A textual description or
                                 * comment.
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateSnapshotConfig(String description) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("description", description);
                                    return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/snapshot/" + this.snapname + "/config", parameters);
                                }

                                /**
                                 * Update snapshot metadata.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateSnapshotConfig() throws JSONException {
                                    return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/snapshot/" + this.snapname + "/config", null);
                                }

                            }

                            /**
                             * Delete a LXC snapshot.
                             *
                             * @param force For removal from config file, even
                             * if removing disk snapshots fails.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result delsnapshot(Boolean force) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("force", force);
                                return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "/snapshot/" + this.snapname + "", parameters);
                            }

                            /**
                             * Delete a LXC snapshot.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result delsnapshot() throws JSONException {
                                return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "/snapshot/" + this.snapname + "", null);
                            }

                            /**
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result snapshotCmdIdx() throws JSONException {
                                return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/snapshot/" + this.snapname + "", null);
                            }

                        }

                        /**
                         * List all snapshots.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result list() throws JSONException {
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/snapshot", null);
                        }

                        /**
                         * Snapshot a container.
                         *
                         * @param snapname The name of the snapshot.
                         * @param description A textual description or comment.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result snapshot(String snapname, String description) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("snapname", snapname);
                            parameters.put("description", description);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/snapshot", parameters);
                        }

                        /**
                         * Snapshot a container.
                         *
                         * @param snapname The name of the snapshot.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result snapshot(String snapname) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("snapname", snapname);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/snapshot", parameters);
                        }

                    }

                    public class PVEFirewall {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEFirewall(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        private PVERules rules;

                        public PVERules getRules() {
                            return rules == null ? (rules = new PVERules(client, this.node, this.vmid)) : rules;
                        }
                        private PVEAliases aliases;

                        public PVEAliases getAliases() {
                            return aliases == null ? (aliases = new PVEAliases(client, this.node, this.vmid)) : aliases;
                        }
                        private PVEIpset ipset;

                        public PVEIpset getIpset() {
                            return ipset == null ? (ipset = new PVEIpset(client, this.node, this.vmid)) : ipset;
                        }
                        private PVEOptions options;

                        public PVEOptions getOptions() {
                            return options == null ? (options = new PVEOptions(client, this.node, this.vmid)) : options;
                        }
                        private PVELog log;

                        public PVELog getLog() {
                            return log == null ? (log = new PVELog(client, this.node, this.vmid)) : log;
                        }
                        private PVERefs refs;

                        public PVERefs getRefs() {
                            return refs == null ? (refs = new PVERefs(client, this.node, this.vmid)) : refs;
                        }

                        public class PVERules {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVERules(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            public PVEPosItem get(Object pos) {
                                return new PVEPosItem(client, this.node, this.vmid, pos);
                            }

                            public class PVEPosItem {

                                private final PveClient client;
                                private final Object node;
                                private final Object vmid;
                                private final Object pos;

                                protected PVEPosItem(PveClient client, Object node, Object vmid, Object pos) {
                                    this.client = client;
                                    this.node = node;
                                    this.vmid = vmid;
                                    this.pos = pos;
                                }

                                /**
                                 * Delete rule.
                                 *
                                 * @param digest Prevent changes if current
                                 * configuration file has a different digest.
                                 * This can be used to prevent concurrent
                                 * modifications.
                                 * @return Result
                                 * @throws JSONException
                                 */
                                public Result deleteRule(String digest) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("digest", digest);
                                    return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/rules/" + this.pos + "", parameters);
                                }

                                /**
                                 * Delete rule.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result deleteRule() throws JSONException {
                                    return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/rules/" + this.pos + "", null);
                                }

                                /**
                                 * Get single rule data.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result getRule() throws JSONException {
                                    return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/rules/" + this.pos + "", null);
                                }

                                /**
                                 * Modify rule data.
                                 *
                                 * @param action Rule action ('ACCEPT', 'DROP',
                                 * 'REJECT') or security group name.
                                 * @param comment Descriptive comment.
                                 * @param delete A list of settings you want to
                                 * delete.
                                 * @param dest Restrict packet destination
                                 * address. This can refer to a single IP
                                 * address, an IP set ('+ipsetname') or an IP
                                 * alias definition. You can also specify an
                                 * address range like
                                 * '20.34.101.207-201.3.9.99', or a list of IP
                                 * addresses and networks (entries are separated
                                 * by comma). Please do not mix IPv4 and IPv6
                                 * addresses inside such lists.
                                 * @param digest Prevent changes if current
                                 * configuration file has a different digest.
                                 * This can be used to prevent concurrent
                                 * modifications.
                                 * @param dport Restrict TCP/UDP destination
                                 * port. You can use service names or simple
                                 * numbers (0-65535), as defined in
                                 * '/etc/services'. Port ranges can be specified
                                 * with '\d+:\d+', for example '80:85', and you
                                 * can use comma separated list to match several
                                 * ports or ranges.
                                 * @param enable Flag to enable/disable a rule.
                                 * @param icmp_type Specify icmp-type. Only
                                 * valid if proto equals 'icmp' or
                                 * 'icmpv6'/'ipv6-icmp'.
                                 * @param iface Network interface name. You have
                                 * to use network configuration key names for
                                 * VMs and containers ('net\d+'). Host related
                                 * rules can use arbitrary strings.
                                 * @param log Log level for firewall rule. Enum:
                                 * emerg,alert,crit,err,warning,notice,info,debug,nolog
                                 * @param macro Use predefined standard macro.
                                 * @param moveto Move rule to new position
                                 * &amp;lt;moveto&amp;gt;. Other arguments are
                                 * ignored.
                                 * @param proto IP protocol. You can use
                                 * protocol names ('tcp'/'udp') or simple
                                 * numbers, as defined in '/etc/protocols'.
                                 * @param source Restrict packet source address.
                                 * This can refer to a single IP address, an IP
                                 * set ('+ipsetname') or an IP alias definition.
                                 * You can also specify an address range like
                                 * '20.34.101.207-201.3.9.99', or a list of IP
                                 * addresses and networks (entries are separated
                                 * by comma). Please do not mix IPv4 and IPv6
                                 * addresses inside such lists.
                                 * @param sport Restrict TCP/UDP source port.
                                 * You can use service names or simple numbers
                                 * (0-65535), as defined in '/etc/services'.
                                 * Port ranges can be specified with '\d+:\d+',
                                 * for example '80:85', and you can use comma
                                 * separated list to match several ports or
                                 * ranges.
                                 * @param type Rule type. Enum: in,out,group
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateRule(String action, String comment, String delete, String dest, String digest, String dport, Integer enable, String icmp_type, String iface, String log, String macro, Integer moveto, String proto, String source, String sport, String type) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("action", action);
                                    parameters.put("comment", comment);
                                    parameters.put("delete", delete);
                                    parameters.put("dest", dest);
                                    parameters.put("digest", digest);
                                    parameters.put("dport", dport);
                                    parameters.put("enable", enable);
                                    parameters.put("icmp-type", icmp_type);
                                    parameters.put("iface", iface);
                                    parameters.put("log", log);
                                    parameters.put("macro", macro);
                                    parameters.put("moveto", moveto);
                                    parameters.put("proto", proto);
                                    parameters.put("source", source);
                                    parameters.put("sport", sport);
                                    parameters.put("type", type);
                                    return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/rules/" + this.pos + "", parameters);
                                }

                                /**
                                 * Modify rule data.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateRule() throws JSONException {
                                    return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/rules/" + this.pos + "", null);
                                }

                            }

                            /**
                             * List rules.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getRules() throws JSONException {
                                return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/rules", null);
                            }

                            /**
                             * Create new rule.
                             *
                             * @param action Rule action ('ACCEPT', 'DROP',
                             * 'REJECT') or security group name.
                             * @param type Rule type. Enum: in,out,group
                             * @param comment Descriptive comment.
                             * @param dest Restrict packet destination address.
                             * This can refer to a single IP address, an IP set
                             * ('+ipsetname') or an IP alias definition. You can
                             * also specify an address range like
                             * '20.34.101.207-201.3.9.99', or a list of IP
                             * addresses and networks (entries are separated by
                             * comma). Please do not mix IPv4 and IPv6 addresses
                             * inside such lists.
                             * @param digest Prevent changes if current
                             * configuration file has a different digest. This
                             * can be used to prevent concurrent modifications.
                             * @param dport Restrict TCP/UDP destination port.
                             * You can use service names or simple numbers
                             * (0-65535), as defined in '/etc/services'. Port
                             * ranges can be specified with '\d+:\d+', for
                             * example '80:85', and you can use comma separated
                             * list to match several ports or ranges.
                             * @param enable Flag to enable/disable a rule.
                             * @param icmp_type Specify icmp-type. Only valid if
                             * proto equals 'icmp' or 'icmpv6'/'ipv6-icmp'.
                             * @param iface Network interface name. You have to
                             * use network configuration key names for VMs and
                             * containers ('net\d+'). Host related rules can use
                             * arbitrary strings.
                             * @param log Log level for firewall rule. Enum:
                             * emerg,alert,crit,err,warning,notice,info,debug,nolog
                             * @param macro Use predefined standard macro.
                             * @param pos Update rule at position
                             * &amp;lt;pos&amp;gt;.
                             * @param proto IP protocol. You can use protocol
                             * names ('tcp'/'udp') or simple numbers, as defined
                             * in '/etc/protocols'.
                             * @param source Restrict packet source address.
                             * This can refer to a single IP address, an IP set
                             * ('+ipsetname') or an IP alias definition. You can
                             * also specify an address range like
                             * '20.34.101.207-201.3.9.99', or a list of IP
                             * addresses and networks (entries are separated by
                             * comma). Please do not mix IPv4 and IPv6 addresses
                             * inside such lists.
                             * @param sport Restrict TCP/UDP source port. You
                             * can use service names or simple numbers
                             * (0-65535), as defined in '/etc/services'. Port
                             * ranges can be specified with '\d+:\d+', for
                             * example '80:85', and you can use comma separated
                             * list to match several ports or ranges.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createRule(String action, String type, String comment, String dest, String digest, String dport, Integer enable, String icmp_type, String iface, String log, String macro, Integer pos, String proto, String source, String sport) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("action", action);
                                parameters.put("type", type);
                                parameters.put("comment", comment);
                                parameters.put("dest", dest);
                                parameters.put("digest", digest);
                                parameters.put("dport", dport);
                                parameters.put("enable", enable);
                                parameters.put("icmp-type", icmp_type);
                                parameters.put("iface", iface);
                                parameters.put("log", log);
                                parameters.put("macro", macro);
                                parameters.put("pos", pos);
                                parameters.put("proto", proto);
                                parameters.put("source", source);
                                parameters.put("sport", sport);
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/rules", parameters);
                            }

                            /**
                             * Create new rule.
                             *
                             * @param action Rule action ('ACCEPT', 'DROP',
                             * 'REJECT') or security group name.
                             * @param type Rule type. Enum: in,out,group
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createRule(String action, String type) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("action", action);
                                parameters.put("type", type);
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/rules", parameters);
                            }

                        }

                        public class PVEAliases {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEAliases(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            public PVENameItem get(Object name) {
                                return new PVENameItem(client, this.node, this.vmid, name);
                            }

                            public class PVENameItem {

                                private final PveClient client;
                                private final Object node;
                                private final Object vmid;
                                private final Object name;

                                protected PVENameItem(PveClient client, Object node, Object vmid, Object name) {
                                    this.client = client;
                                    this.node = node;
                                    this.vmid = vmid;
                                    this.name = name;
                                }

                                /**
                                 * Remove IP or Network alias.
                                 *
                                 * @param digest Prevent changes if current
                                 * configuration file has a different digest.
                                 * This can be used to prevent concurrent
                                 * modifications.
                                 * @return Result
                                 * @throws JSONException
                                 */
                                public Result removeAlias(String digest) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("digest", digest);
                                    return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/aliases/" + this.name + "", parameters);
                                }

                                /**
                                 * Remove IP or Network alias.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result removeAlias() throws JSONException {
                                    return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/aliases/" + this.name + "", null);
                                }

                                /**
                                 * Read alias.
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result readAlias() throws JSONException {
                                    return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/aliases/" + this.name + "", null);
                                }

                                /**
                                 * Update IP or Network alias.
                                 *
                                 * @param cidr Network/IP specification in CIDR
                                 * format.
                                 * @param comment
                                 * @param digest Prevent changes if current
                                 * configuration file has a different digest.
                                 * This can be used to prevent concurrent
                                 * modifications.
                                 * @param rename Rename an existing alias.
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateAlias(String cidr, String comment, String digest, String rename) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("cidr", cidr);
                                    parameters.put("comment", comment);
                                    parameters.put("digest", digest);
                                    parameters.put("rename", rename);
                                    return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/aliases/" + this.name + "", parameters);
                                }

                                /**
                                 * Update IP or Network alias.
                                 *
                                 * @param cidr Network/IP specification in CIDR
                                 * format.
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result updateAlias(String cidr) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("cidr", cidr);
                                    return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/aliases/" + this.name + "", parameters);
                                }

                            }

                            /**
                             * List aliases
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getAliases() throws JSONException {
                                return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/aliases", null);
                            }

                            /**
                             * Create IP or Network Alias.
                             *
                             * @param cidr Network/IP specification in CIDR
                             * format.
                             * @param name Alias name.
                             * @param comment
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createAlias(String cidr, String name, String comment) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("cidr", cidr);
                                parameters.put("name", name);
                                parameters.put("comment", comment);
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/aliases", parameters);
                            }

                            /**
                             * Create IP or Network Alias.
                             *
                             * @param cidr Network/IP specification in CIDR
                             * format.
                             * @param name Alias name.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createAlias(String cidr, String name) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("cidr", cidr);
                                parameters.put("name", name);
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/aliases", parameters);
                            }

                        }

                        public class PVEIpset {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEIpset(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            public PVENameItem get(Object name) {
                                return new PVENameItem(client, this.node, this.vmid, name);
                            }

                            public class PVENameItem {

                                private final PveClient client;
                                private final Object node;
                                private final Object vmid;
                                private final Object name;

                                protected PVENameItem(PveClient client, Object node, Object vmid, Object name) {
                                    this.client = client;
                                    this.node = node;
                                    this.vmid = vmid;
                                    this.name = name;
                                }

                                public PVECidrItem get(Object cidr) {
                                    return new PVECidrItem(client, this.node, this.vmid, this.name, cidr);
                                }

                                public class PVECidrItem {

                                    private final PveClient client;
                                    private final Object node;
                                    private final Object vmid;
                                    private final Object name;
                                    private final Object cidr;

                                    protected PVECidrItem(PveClient client, Object node, Object vmid, Object name, Object cidr) {
                                        this.client = client;
                                        this.node = node;
                                        this.vmid = vmid;
                                        this.name = name;
                                        this.cidr = cidr;
                                    }

                                    /**
                                     * Remove IP or Network from IPSet.
                                     *
                                     * @param digest Prevent changes if current
                                     * configuration file has a different
                                     * digest. This can be used to prevent
                                     * concurrent modifications.
                                     * @return Result
                                     * @throws JSONException
                                     */
                                    public Result removeIp(String digest) throws JSONException {
                                        Map<String, Object> parameters = new HashMap<>();
                                        parameters.put("digest", digest);
                                        return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset/" + this.name + "/" + this.cidr + "", parameters);
                                    }

                                    /**
                                     * Remove IP or Network from IPSet.
                                     *
                                     * @return Result
                                     * @throws JSONException
                                     */

                                    public Result removeIp() throws JSONException {
                                        return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset/" + this.name + "/" + this.cidr + "", null);
                                    }

                                    /**
                                     * Read IP or Network settings from IPSet.
                                     *
                                     * @return Result
                                     * @throws JSONException
                                     */

                                    public Result readIp() throws JSONException {
                                        return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset/" + this.name + "/" + this.cidr + "", null);
                                    }

                                    /**
                                     * Update IP or Network settings
                                     *
                                     * @param comment
                                     * @param digest Prevent changes if current
                                     * configuration file has a different
                                     * digest. This can be used to prevent
                                     * concurrent modifications.
                                     * @param nomatch
                                     * @return Result
                                     * @throws JSONException
                                     */

                                    public Result updateIp(String comment, String digest, Boolean nomatch) throws JSONException {
                                        Map<String, Object> parameters = new HashMap<>();
                                        parameters.put("comment", comment);
                                        parameters.put("digest", digest);
                                        parameters.put("nomatch", nomatch);
                                        return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset/" + this.name + "/" + this.cidr + "", parameters);
                                    }

                                    /**
                                     * Update IP or Network settings
                                     *
                                     * @return Result
                                     * @throws JSONException
                                     */

                                    public Result updateIp() throws JSONException {
                                        return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset/" + this.name + "/" + this.cidr + "", null);
                                    }

                                }

                                /**
                                 * Delete IPSet
                                 *
                                 * @param force Delete all members of the IPSet,
                                 * if there are any.
                                 * @return Result
                                 * @throws JSONException
                                 */
                                public Result deleteIpset(Boolean force) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("force", force);
                                    return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset/" + this.name + "", parameters);
                                }

                                /**
                                 * Delete IPSet
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result deleteIpset() throws JSONException {
                                    return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset/" + this.name + "", null);
                                }

                                /**
                                 * List IPSet content
                                 *
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result getIpset() throws JSONException {
                                    return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset/" + this.name + "", null);
                                }

                                /**
                                 * Add IP or Network to IPSet.
                                 *
                                 * @param cidr Network/IP specification in CIDR
                                 * format.
                                 * @param comment
                                 * @param nomatch
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result createIp(String cidr, String comment, Boolean nomatch) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("cidr", cidr);
                                    parameters.put("comment", comment);
                                    parameters.put("nomatch", nomatch);
                                    return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset/" + this.name + "", parameters);
                                }

                                /**
                                 * Add IP or Network to IPSet.
                                 *
                                 * @param cidr Network/IP specification in CIDR
                                 * format.
                                 * @return Result
                                 * @throws JSONException
                                 */

                                public Result createIp(String cidr) throws JSONException {
                                    Map<String, Object> parameters = new HashMap<>();
                                    parameters.put("cidr", cidr);
                                    return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset/" + this.name + "", parameters);
                                }

                            }

                            /**
                             * List IPSets
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result ipsetIndex() throws JSONException {
                                return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset", null);
                            }

                            /**
                             * Create new IPSet
                             *
                             * @param name IP set name.
                             * @param comment
                             * @param digest Prevent changes if current
                             * configuration file has a different digest. This
                             * can be used to prevent concurrent modifications.
                             * @param rename Rename an existing IPSet. You can
                             * set 'rename' to the same value as 'name' to
                             * update the 'comment' of an existing IPSet.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createIpset(String name, String comment, String digest, String rename) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("name", name);
                                parameters.put("comment", comment);
                                parameters.put("digest", digest);
                                parameters.put("rename", rename);
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset", parameters);
                            }

                            /**
                             * Create new IPSet
                             *
                             * @param name IP set name.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result createIpset(String name) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("name", name);
                                return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/ipset", parameters);
                            }

                        }

                        public class PVEOptions {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVEOptions(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Get VM firewall options.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getOptions() throws JSONException {
                                return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/options", null);
                            }

                            /**
                             * Set Firewall options.
                             *
                             * @param delete A list of settings you want to
                             * delete.
                             * @param dhcp Enable DHCP.
                             * @param digest Prevent changes if current
                             * configuration file has a different digest. This
                             * can be used to prevent concurrent modifications.
                             * @param enable Enable/disable firewall rules.
                             * @param ipfilter Enable default IP filters. This
                             * is equivalent to adding an empty
                             * ipfilter-net&amp;lt;id&amp;gt; ipset for every
                             * interface. Such ipsets implicitly contain sane
                             * default restrictions such as restricting IPv6
                             * link local addresses to the one derived from the
                             * interface's MAC address. For containers the
                             * configured IP addresses will be implicitly added.
                             * @param log_level_in Log level for incoming
                             * traffic. Enum:
                             * emerg,alert,crit,err,warning,notice,info,debug,nolog
                             * @param log_level_out Log level for outgoing
                             * traffic. Enum:
                             * emerg,alert,crit,err,warning,notice,info,debug,nolog
                             * @param macfilter Enable/disable MAC address
                             * filter.
                             * @param ndp Enable NDP (Neighbor Discovery
                             * Protocol).
                             * @param policy_in Input policy. Enum:
                             * ACCEPT,REJECT,DROP
                             * @param policy_out Output policy. Enum:
                             * ACCEPT,REJECT,DROP
                             * @param radv Allow sending Router Advertisement.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result setOptions(String delete, Boolean dhcp, String digest, Boolean enable, Boolean ipfilter, String log_level_in, String log_level_out, Boolean macfilter, Boolean ndp, String policy_in, String policy_out, Boolean radv) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("delete", delete);
                                parameters.put("dhcp", dhcp);
                                parameters.put("digest", digest);
                                parameters.put("enable", enable);
                                parameters.put("ipfilter", ipfilter);
                                parameters.put("log_level_in", log_level_in);
                                parameters.put("log_level_out", log_level_out);
                                parameters.put("macfilter", macfilter);
                                parameters.put("ndp", ndp);
                                parameters.put("policy_in", policy_in);
                                parameters.put("policy_out", policy_out);
                                parameters.put("radv", radv);
                                return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/options", parameters);
                            }

                            /**
                             * Set Firewall options.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result setOptions() throws JSONException {
                                return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/options", null);
                            }

                        }

                        public class PVELog {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVELog(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Read firewall log
                             *
                             * @param limit
                             * @param since Display log since this UNIX epoch.
                             * @param start
                             * @param until Display log until this UNIX epoch.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result log(Integer limit, Integer since, Integer start, Integer until) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("limit", limit);
                                parameters.put("since", since);
                                parameters.put("start", start);
                                parameters.put("until", until);
                                return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/log", parameters);
                            }

                            /**
                             * Read firewall log
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result log() throws JSONException {
                                return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/log", null);
                            }

                        }

                        public class PVERefs {

                            private final PveClient client;
                            private final Object node;
                            private final Object vmid;

                            protected PVERefs(PveClient client, Object node, Object vmid) {
                                this.client = client;
                                this.node = node;
                                this.vmid = vmid;
                            }

                            /**
                             * Lists possible IPSet/Alias reference which are
                             * allowed in source/dest properties.
                             *
                             * @param type Only list references of specified
                             * type. Enum: alias,ipset
                             * @return Result
                             * @throws JSONException
                             */
                            public Result refs(String type) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("type", type);
                                return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/refs", parameters);
                            }

                            /**
                             * Lists possible IPSet/Alias reference which are
                             * allowed in source/dest properties.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result refs() throws JSONException {
                                return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall/refs", null);
                            }

                        }

                        /**
                         * Directory index.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result index() throws JSONException {
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/firewall", null);
                        }

                    }

                    public class PVERrd {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVERrd(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Read VM RRD statistics (returns PNG)
                         *
                         * @param ds The list of datasources you want to
                         * display.
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @param cf The RRD consolidation function Enum:
                         * AVERAGE,MAX
                         * @return Result
                         * @throws JSONException
                         */
                        public Result rrd(String ds, String timeframe, String cf) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ds", ds);
                            parameters.put("timeframe", timeframe);
                            parameters.put("cf", cf);
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/rrd", parameters);
                        }

                        /**
                         * Read VM RRD statistics (returns PNG)
                         *
                         * @param ds The list of datasources you want to
                         * display.
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @return Result
                         * @throws JSONException
                         */

                        public Result rrd(String ds, String timeframe) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ds", ds);
                            parameters.put("timeframe", timeframe);
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/rrd", parameters);
                        }

                    }

                    public class PVERrddata {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVERrddata(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Read VM RRD statistics
                         *
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @param cf The RRD consolidation function Enum:
                         * AVERAGE,MAX
                         * @return Result
                         * @throws JSONException
                         */
                        public Result rrddata(String timeframe, String cf) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("timeframe", timeframe);
                            parameters.put("cf", cf);
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/rrddata", parameters);
                        }

                        /**
                         * Read VM RRD statistics
                         *
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @return Result
                         * @throws JSONException
                         */

                        public Result rrddata(String timeframe) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("timeframe", timeframe);
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/rrddata", parameters);
                        }

                    }

                    public class PVEVncproxy {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEVncproxy(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Creates a TCP VNC proxy connections.
                         *
                         * @param height sets the height of the console in
                         * pixels.
                         * @param websocket use websocket instead of standard
                         * VNC.
                         * @param width sets the width of the console in pixels.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vncproxy(Integer height, Boolean websocket, Integer width) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("height", height);
                            parameters.put("websocket", websocket);
                            parameters.put("width", width);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/vncproxy", parameters);
                        }

                        /**
                         * Creates a TCP VNC proxy connections.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result vncproxy() throws JSONException {
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/vncproxy", null);
                        }

                    }

                    public class PVETermproxy {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVETermproxy(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Creates a TCP proxy connection.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result termproxy() throws JSONException {
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/termproxy", null);
                        }

                    }

                    public class PVEVncwebsocket {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEVncwebsocket(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Opens a weksocket for VNC traffic.
                         *
                         * @param port Port number returned by previous vncproxy
                         * call.
                         * @param vncticket Ticket from previous call to
                         * vncproxy.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vncwebsocket(int port, String vncticket) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("port", port);
                            parameters.put("vncticket", vncticket);
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/vncwebsocket", parameters);
                        }

                    }

                    public class PVESpiceproxy {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVESpiceproxy(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Returns a SPICE configuration to connect to the CT.
                         *
                         * @param proxy SPICE proxy server. This can be used by
                         * the client to specify the proxy server. All nodes in
                         * a cluster runs 'spiceproxy', so it is up to the
                         * client to choose one. By default, we return the node
                         * where the VM is currently running. As reasonable
                         * setting is to use same node you use to connect to the
                         * API (This is window.location.hostname for the JS
                         * GUI).
                         * @return Result
                         * @throws JSONException
                         */
                        public Result spiceproxy(String proxy) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("proxy", proxy);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/spiceproxy", parameters);
                        }

                        /**
                         * Returns a SPICE configuration to connect to the CT.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result spiceproxy() throws JSONException {
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/spiceproxy", null);
                        }

                    }

                    public class PVERemoteMigrate {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVERemoteMigrate(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Migrate the container to another cluster. Creates a
                         * new migration task. EXPERIMENTAL feature!
                         *
                         * @param target_bridge Mapping from source to target
                         * bridges. Providing only a single bridge ID maps all
                         * source bridges to that bridge. Providing the special
                         * value '1' will map each source bridge to itself.
                         * @param target_endpoint Remote target endpoint
                         * @param target_storage Mapping from source to target
                         * storages. Providing only a single storage ID maps all
                         * source storages to that storage. Providing the
                         * special value '1' will map each source storage to
                         * itself.
                         * @param bwlimit Override I/O bandwidth limit (in
                         * KiB/s).
                         * @param delete Delete the original CT and related data
                         * after successful migration. By default the original
                         * CT is kept on the source cluster in a stopped state.
                         * @param online Use online/live migration.
                         * @param restart Use restart migration
                         * @param target_vmid The (unique) ID of the VM.
                         * @param timeout Timeout in seconds for shutdown for
                         * restart migration
                         * @return Result
                         * @throws JSONException
                         */
                        public Result remoteMigrateVm(String target_bridge, String target_endpoint, String target_storage, Float bwlimit, Boolean delete, Boolean online, Boolean restart, Integer target_vmid, Integer timeout) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("target-bridge", target_bridge);
                            parameters.put("target-endpoint", target_endpoint);
                            parameters.put("target-storage", target_storage);
                            parameters.put("bwlimit", bwlimit);
                            parameters.put("delete", delete);
                            parameters.put("online", online);
                            parameters.put("restart", restart);
                            parameters.put("target-vmid", target_vmid);
                            parameters.put("timeout", timeout);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/remote_migrate", parameters);
                        }

                        /**
                         * Migrate the container to another cluster. Creates a
                         * new migration task. EXPERIMENTAL feature!
                         *
                         * @param target_bridge Mapping from source to target
                         * bridges. Providing only a single bridge ID maps all
                         * source bridges to that bridge. Providing the special
                         * value '1' will map each source bridge to itself.
                         * @param target_endpoint Remote target endpoint
                         * @param target_storage Mapping from source to target
                         * storages. Providing only a single storage ID maps all
                         * source storages to that storage. Providing the
                         * special value '1' will map each source storage to
                         * itself.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result remoteMigrateVm(String target_bridge, String target_endpoint, String target_storage) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("target-bridge", target_bridge);
                            parameters.put("target-endpoint", target_endpoint);
                            parameters.put("target-storage", target_storage);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/remote_migrate", parameters);
                        }

                    }

                    public class PVEMigrate {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEMigrate(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Migrate the container to another node. Creates a new
                         * migration task.
                         *
                         * @param target Target node.
                         * @param bwlimit Override I/O bandwidth limit (in
                         * KiB/s).
                         * @param online Use online/live migration.
                         * @param restart Use restart migration
                         * @param target_storage Mapping from source to target
                         * storages. Providing only a single storage ID maps all
                         * source storages to that storage. Providing the
                         * special value '1' will map each source storage to
                         * itself.
                         * @param timeout Timeout in seconds for shutdown for
                         * restart migration
                         * @return Result
                         * @throws JSONException
                         */
                        public Result migrateVm(String target, Float bwlimit, Boolean online, Boolean restart, String target_storage, Integer timeout) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("target", target);
                            parameters.put("bwlimit", bwlimit);
                            parameters.put("online", online);
                            parameters.put("restart", restart);
                            parameters.put("target-storage", target_storage);
                            parameters.put("timeout", timeout);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/migrate", parameters);
                        }

                        /**
                         * Migrate the container to another node. Creates a new
                         * migration task.
                         *
                         * @param target Target node.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result migrateVm(String target) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("target", target);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/migrate", parameters);
                        }

                    }

                    public class PVEFeature {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEFeature(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Check if feature for virtual machine is available.
                         *
                         * @param feature Feature to check. Enum:
                         * snapshot,clone,copy
                         * @param snapname The name of the snapshot.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vmFeature(String feature, String snapname) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("feature", feature);
                            parameters.put("snapname", snapname);
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/feature", parameters);
                        }

                        /**
                         * Check if feature for virtual machine is available.
                         *
                         * @param feature Feature to check. Enum:
                         * snapshot,clone,copy
                         * @return Result
                         * @throws JSONException
                         */

                        public Result vmFeature(String feature) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("feature", feature);
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/feature", parameters);
                        }

                    }

                    public class PVETemplate {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVETemplate(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Create a Template.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result template() throws JSONException {
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/template", null);
                        }

                    }

                    public class PVEClone {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEClone(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Create a container clone/copy
                         *
                         * @param newid VMID for the clone.
                         * @param bwlimit Override I/O bandwidth limit (in
                         * KiB/s).
                         * @param description Description for the new CT.
                         * @param full Create a full copy of all disks. This is
                         * always done when you clone a normal CT. For CT
                         * templates, we try to create a linked clone by
                         * default.
                         * @param hostname Set a hostname for the new CT.
                         * @param pool Add the new CT to the specified pool.
                         * @param snapname The name of the snapshot.
                         * @param storage Target storage for full clone.
                         * @param target Target node. Only allowed if the
                         * original VM is on shared storage.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result cloneVm(int newid, Float bwlimit, String description, Boolean full, String hostname, String pool, String snapname, String storage, String target) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("newid", newid);
                            parameters.put("bwlimit", bwlimit);
                            parameters.put("description", description);
                            parameters.put("full", full);
                            parameters.put("hostname", hostname);
                            parameters.put("pool", pool);
                            parameters.put("snapname", snapname);
                            parameters.put("storage", storage);
                            parameters.put("target", target);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/clone", parameters);
                        }

                        /**
                         * Create a container clone/copy
                         *
                         * @param newid VMID for the clone.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result cloneVm(int newid) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("newid", newid);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/clone", parameters);
                        }

                    }

                    public class PVEResize {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEResize(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Resize a container mount point.
                         *
                         * @param disk The disk you want to resize. Enum:
                         * rootfs,mp0,mp1,mp2,mp3,mp4,mp5,mp6,mp7,mp8,mp9,mp10,mp11,mp12,mp13,mp14,mp15,mp16,mp17,mp18,mp19,mp20,mp21,mp22,mp23,mp24,mp25,mp26,mp27,mp28,mp29,mp30,mp31,mp32,mp33,mp34,mp35,mp36,mp37,mp38,mp39,mp40,mp41,mp42,mp43,mp44,mp45,mp46,mp47,mp48,mp49,mp50,mp51,mp52,mp53,mp54,mp55,mp56,mp57,mp58,mp59,mp60,mp61,mp62,mp63,mp64,mp65,mp66,mp67,mp68,mp69,mp70,mp71,mp72,mp73,mp74,mp75,mp76,mp77,mp78,mp79,mp80,mp81,mp82,mp83,mp84,mp85,mp86,mp87,mp88,mp89,mp90,mp91,mp92,mp93,mp94,mp95,mp96,mp97,mp98,mp99,mp100,mp101,mp102,mp103,mp104,mp105,mp106,mp107,mp108,mp109,mp110,mp111,mp112,mp113,mp114,mp115,mp116,mp117,mp118,mp119,mp120,mp121,mp122,mp123,mp124,mp125,mp126,mp127,mp128,mp129,mp130,mp131,mp132,mp133,mp134,mp135,mp136,mp137,mp138,mp139,mp140,mp141,mp142,mp143,mp144,mp145,mp146,mp147,mp148,mp149,mp150,mp151,mp152,mp153,mp154,mp155,mp156,mp157,mp158,mp159,mp160,mp161,mp162,mp163,mp164,mp165,mp166,mp167,mp168,mp169,mp170,mp171,mp172,mp173,mp174,mp175,mp176,mp177,mp178,mp179,mp180,mp181,mp182,mp183,mp184,mp185,mp186,mp187,mp188,mp189,mp190,mp191,mp192,mp193,mp194,mp195,mp196,mp197,mp198,mp199,mp200,mp201,mp202,mp203,mp204,mp205,mp206,mp207,mp208,mp209,mp210,mp211,mp212,mp213,mp214,mp215,mp216,mp217,mp218,mp219,mp220,mp221,mp222,mp223,mp224,mp225,mp226,mp227,mp228,mp229,mp230,mp231,mp232,mp233,mp234,mp235,mp236,mp237,mp238,mp239,mp240,mp241,mp242,mp243,mp244,mp245,mp246,mp247,mp248,mp249,mp250,mp251,mp252,mp253,mp254,mp255
                         * @param size The new size. With the '+' sign the value
                         * is added to the actual size of the volume and without
                         * it, the value is taken as an absolute one. Shrinking
                         * disk size is not supported.
                         * @param digest Prevent changes if current
                         * configuration file has different SHA1 digest. This
                         * can be used to prevent concurrent modifications.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result resizeVm(String disk, String size, String digest) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("disk", disk);
                            parameters.put("size", size);
                            parameters.put("digest", digest);
                            return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/resize", parameters);
                        }

                        /**
                         * Resize a container mount point.
                         *
                         * @param disk The disk you want to resize. Enum:
                         * rootfs,mp0,mp1,mp2,mp3,mp4,mp5,mp6,mp7,mp8,mp9,mp10,mp11,mp12,mp13,mp14,mp15,mp16,mp17,mp18,mp19,mp20,mp21,mp22,mp23,mp24,mp25,mp26,mp27,mp28,mp29,mp30,mp31,mp32,mp33,mp34,mp35,mp36,mp37,mp38,mp39,mp40,mp41,mp42,mp43,mp44,mp45,mp46,mp47,mp48,mp49,mp50,mp51,mp52,mp53,mp54,mp55,mp56,mp57,mp58,mp59,mp60,mp61,mp62,mp63,mp64,mp65,mp66,mp67,mp68,mp69,mp70,mp71,mp72,mp73,mp74,mp75,mp76,mp77,mp78,mp79,mp80,mp81,mp82,mp83,mp84,mp85,mp86,mp87,mp88,mp89,mp90,mp91,mp92,mp93,mp94,mp95,mp96,mp97,mp98,mp99,mp100,mp101,mp102,mp103,mp104,mp105,mp106,mp107,mp108,mp109,mp110,mp111,mp112,mp113,mp114,mp115,mp116,mp117,mp118,mp119,mp120,mp121,mp122,mp123,mp124,mp125,mp126,mp127,mp128,mp129,mp130,mp131,mp132,mp133,mp134,mp135,mp136,mp137,mp138,mp139,mp140,mp141,mp142,mp143,mp144,mp145,mp146,mp147,mp148,mp149,mp150,mp151,mp152,mp153,mp154,mp155,mp156,mp157,mp158,mp159,mp160,mp161,mp162,mp163,mp164,mp165,mp166,mp167,mp168,mp169,mp170,mp171,mp172,mp173,mp174,mp175,mp176,mp177,mp178,mp179,mp180,mp181,mp182,mp183,mp184,mp185,mp186,mp187,mp188,mp189,mp190,mp191,mp192,mp193,mp194,mp195,mp196,mp197,mp198,mp199,mp200,mp201,mp202,mp203,mp204,mp205,mp206,mp207,mp208,mp209,mp210,mp211,mp212,mp213,mp214,mp215,mp216,mp217,mp218,mp219,mp220,mp221,mp222,mp223,mp224,mp225,mp226,mp227,mp228,mp229,mp230,mp231,mp232,mp233,mp234,mp235,mp236,mp237,mp238,mp239,mp240,mp241,mp242,mp243,mp244,mp245,mp246,mp247,mp248,mp249,mp250,mp251,mp252,mp253,mp254,mp255
                         * @param size The new size. With the '+' sign the value
                         * is added to the actual size of the volume and without
                         * it, the value is taken as an absolute one. Shrinking
                         * disk size is not supported.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result resizeVm(String disk, String size) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("disk", disk);
                            parameters.put("size", size);
                            return client.set("/nodes/" + this.node + "/lxc/" + this.vmid + "/resize", parameters);
                        }

                    }

                    public class PVEMoveVolume {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEMoveVolume(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Move a rootfs-/mp-volume to a different storage or to
                         * a different container.
                         *
                         * @param volume Volume which will be moved. Enum:
                         * rootfs,mp0,mp1,mp2,mp3,mp4,mp5,mp6,mp7,mp8,mp9,mp10,mp11,mp12,mp13,mp14,mp15,mp16,mp17,mp18,mp19,mp20,mp21,mp22,mp23,mp24,mp25,mp26,mp27,mp28,mp29,mp30,mp31,mp32,mp33,mp34,mp35,mp36,mp37,mp38,mp39,mp40,mp41,mp42,mp43,mp44,mp45,mp46,mp47,mp48,mp49,mp50,mp51,mp52,mp53,mp54,mp55,mp56,mp57,mp58,mp59,mp60,mp61,mp62,mp63,mp64,mp65,mp66,mp67,mp68,mp69,mp70,mp71,mp72,mp73,mp74,mp75,mp76,mp77,mp78,mp79,mp80,mp81,mp82,mp83,mp84,mp85,mp86,mp87,mp88,mp89,mp90,mp91,mp92,mp93,mp94,mp95,mp96,mp97,mp98,mp99,mp100,mp101,mp102,mp103,mp104,mp105,mp106,mp107,mp108,mp109,mp110,mp111,mp112,mp113,mp114,mp115,mp116,mp117,mp118,mp119,mp120,mp121,mp122,mp123,mp124,mp125,mp126,mp127,mp128,mp129,mp130,mp131,mp132,mp133,mp134,mp135,mp136,mp137,mp138,mp139,mp140,mp141,mp142,mp143,mp144,mp145,mp146,mp147,mp148,mp149,mp150,mp151,mp152,mp153,mp154,mp155,mp156,mp157,mp158,mp159,mp160,mp161,mp162,mp163,mp164,mp165,mp166,mp167,mp168,mp169,mp170,mp171,mp172,mp173,mp174,mp175,mp176,mp177,mp178,mp179,mp180,mp181,mp182,mp183,mp184,mp185,mp186,mp187,mp188,mp189,mp190,mp191,mp192,mp193,mp194,mp195,mp196,mp197,mp198,mp199,mp200,mp201,mp202,mp203,mp204,mp205,mp206,mp207,mp208,mp209,mp210,mp211,mp212,mp213,mp214,mp215,mp216,mp217,mp218,mp219,mp220,mp221,mp222,mp223,mp224,mp225,mp226,mp227,mp228,mp229,mp230,mp231,mp232,mp233,mp234,mp235,mp236,mp237,mp238,mp239,mp240,mp241,mp242,mp243,mp244,mp245,mp246,mp247,mp248,mp249,mp250,mp251,mp252,mp253,mp254,mp255,unused0,unused1,unused2,unused3,unused4,unused5,unused6,unused7,unused8,unused9,unused10,unused11,unused12,unused13,unused14,unused15,unused16,unused17,unused18,unused19,unused20,unused21,unused22,unused23,unused24,unused25,unused26,unused27,unused28,unused29,unused30,unused31,unused32,unused33,unused34,unused35,unused36,unused37,unused38,unused39,unused40,unused41,unused42,unused43,unused44,unused45,unused46,unused47,unused48,unused49,unused50,unused51,unused52,unused53,unused54,unused55,unused56,unused57,unused58,unused59,unused60,unused61,unused62,unused63,unused64,unused65,unused66,unused67,unused68,unused69,unused70,unused71,unused72,unused73,unused74,unused75,unused76,unused77,unused78,unused79,unused80,unused81,unused82,unused83,unused84,unused85,unused86,unused87,unused88,unused89,unused90,unused91,unused92,unused93,unused94,unused95,unused96,unused97,unused98,unused99,unused100,unused101,unused102,unused103,unused104,unused105,unused106,unused107,unused108,unused109,unused110,unused111,unused112,unused113,unused114,unused115,unused116,unused117,unused118,unused119,unused120,unused121,unused122,unused123,unused124,unused125,unused126,unused127,unused128,unused129,unused130,unused131,unused132,unused133,unused134,unused135,unused136,unused137,unused138,unused139,unused140,unused141,unused142,unused143,unused144,unused145,unused146,unused147,unused148,unused149,unused150,unused151,unused152,unused153,unused154,unused155,unused156,unused157,unused158,unused159,unused160,unused161,unused162,unused163,unused164,unused165,unused166,unused167,unused168,unused169,unused170,unused171,unused172,unused173,unused174,unused175,unused176,unused177,unused178,unused179,unused180,unused181,unused182,unused183,unused184,unused185,unused186,unused187,unused188,unused189,unused190,unused191,unused192,unused193,unused194,unused195,unused196,unused197,unused198,unused199,unused200,unused201,unused202,unused203,unused204,unused205,unused206,unused207,unused208,unused209,unused210,unused211,unused212,unused213,unused214,unused215,unused216,unused217,unused218,unused219,unused220,unused221,unused222,unused223,unused224,unused225,unused226,unused227,unused228,unused229,unused230,unused231,unused232,unused233,unused234,unused235,unused236,unused237,unused238,unused239,unused240,unused241,unused242,unused243,unused244,unused245,unused246,unused247,unused248,unused249,unused250,unused251,unused252,unused253,unused254,unused255
                         * @param bwlimit Override I/O bandwidth limit (in
                         * KiB/s).
                         * @param delete Delete the original volume after
                         * successful copy. By default the original is kept as
                         * an unused volume entry.
                         * @param digest Prevent changes if current
                         * configuration file has different SHA1 " . "digest.
                         * This can be used to prevent concurrent modifications.
                         * @param storage Target Storage.
                         * @param target_digest Prevent changes if current
                         * configuration file of the target " . "container has a
                         * different SHA1 digest. This can be used to prevent "
                         * . "concurrent modifications.
                         * @param target_vmid The (unique) ID of the VM.
                         * @param target_volume The config key the volume will
                         * be moved to. Default is the source volume key. Enum:
                         * rootfs,mp0,mp1,mp2,mp3,mp4,mp5,mp6,mp7,mp8,mp9,mp10,mp11,mp12,mp13,mp14,mp15,mp16,mp17,mp18,mp19,mp20,mp21,mp22,mp23,mp24,mp25,mp26,mp27,mp28,mp29,mp30,mp31,mp32,mp33,mp34,mp35,mp36,mp37,mp38,mp39,mp40,mp41,mp42,mp43,mp44,mp45,mp46,mp47,mp48,mp49,mp50,mp51,mp52,mp53,mp54,mp55,mp56,mp57,mp58,mp59,mp60,mp61,mp62,mp63,mp64,mp65,mp66,mp67,mp68,mp69,mp70,mp71,mp72,mp73,mp74,mp75,mp76,mp77,mp78,mp79,mp80,mp81,mp82,mp83,mp84,mp85,mp86,mp87,mp88,mp89,mp90,mp91,mp92,mp93,mp94,mp95,mp96,mp97,mp98,mp99,mp100,mp101,mp102,mp103,mp104,mp105,mp106,mp107,mp108,mp109,mp110,mp111,mp112,mp113,mp114,mp115,mp116,mp117,mp118,mp119,mp120,mp121,mp122,mp123,mp124,mp125,mp126,mp127,mp128,mp129,mp130,mp131,mp132,mp133,mp134,mp135,mp136,mp137,mp138,mp139,mp140,mp141,mp142,mp143,mp144,mp145,mp146,mp147,mp148,mp149,mp150,mp151,mp152,mp153,mp154,mp155,mp156,mp157,mp158,mp159,mp160,mp161,mp162,mp163,mp164,mp165,mp166,mp167,mp168,mp169,mp170,mp171,mp172,mp173,mp174,mp175,mp176,mp177,mp178,mp179,mp180,mp181,mp182,mp183,mp184,mp185,mp186,mp187,mp188,mp189,mp190,mp191,mp192,mp193,mp194,mp195,mp196,mp197,mp198,mp199,mp200,mp201,mp202,mp203,mp204,mp205,mp206,mp207,mp208,mp209,mp210,mp211,mp212,mp213,mp214,mp215,mp216,mp217,mp218,mp219,mp220,mp221,mp222,mp223,mp224,mp225,mp226,mp227,mp228,mp229,mp230,mp231,mp232,mp233,mp234,mp235,mp236,mp237,mp238,mp239,mp240,mp241,mp242,mp243,mp244,mp245,mp246,mp247,mp248,mp249,mp250,mp251,mp252,mp253,mp254,mp255,unused0,unused1,unused2,unused3,unused4,unused5,unused6,unused7,unused8,unused9,unused10,unused11,unused12,unused13,unused14,unused15,unused16,unused17,unused18,unused19,unused20,unused21,unused22,unused23,unused24,unused25,unused26,unused27,unused28,unused29,unused30,unused31,unused32,unused33,unused34,unused35,unused36,unused37,unused38,unused39,unused40,unused41,unused42,unused43,unused44,unused45,unused46,unused47,unused48,unused49,unused50,unused51,unused52,unused53,unused54,unused55,unused56,unused57,unused58,unused59,unused60,unused61,unused62,unused63,unused64,unused65,unused66,unused67,unused68,unused69,unused70,unused71,unused72,unused73,unused74,unused75,unused76,unused77,unused78,unused79,unused80,unused81,unused82,unused83,unused84,unused85,unused86,unused87,unused88,unused89,unused90,unused91,unused92,unused93,unused94,unused95,unused96,unused97,unused98,unused99,unused100,unused101,unused102,unused103,unused104,unused105,unused106,unused107,unused108,unused109,unused110,unused111,unused112,unused113,unused114,unused115,unused116,unused117,unused118,unused119,unused120,unused121,unused122,unused123,unused124,unused125,unused126,unused127,unused128,unused129,unused130,unused131,unused132,unused133,unused134,unused135,unused136,unused137,unused138,unused139,unused140,unused141,unused142,unused143,unused144,unused145,unused146,unused147,unused148,unused149,unused150,unused151,unused152,unused153,unused154,unused155,unused156,unused157,unused158,unused159,unused160,unused161,unused162,unused163,unused164,unused165,unused166,unused167,unused168,unused169,unused170,unused171,unused172,unused173,unused174,unused175,unused176,unused177,unused178,unused179,unused180,unused181,unused182,unused183,unused184,unused185,unused186,unused187,unused188,unused189,unused190,unused191,unused192,unused193,unused194,unused195,unused196,unused197,unused198,unused199,unused200,unused201,unused202,unused203,unused204,unused205,unused206,unused207,unused208,unused209,unused210,unused211,unused212,unused213,unused214,unused215,unused216,unused217,unused218,unused219,unused220,unused221,unused222,unused223,unused224,unused225,unused226,unused227,unused228,unused229,unused230,unused231,unused232,unused233,unused234,unused235,unused236,unused237,unused238,unused239,unused240,unused241,unused242,unused243,unused244,unused245,unused246,unused247,unused248,unused249,unused250,unused251,unused252,unused253,unused254,unused255
                         * @return Result
                         * @throws JSONException
                         */
                        public Result moveVolume(String volume, Float bwlimit, Boolean delete, String digest, String storage, String target_digest, Integer target_vmid, String target_volume) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("volume", volume);
                            parameters.put("bwlimit", bwlimit);
                            parameters.put("delete", delete);
                            parameters.put("digest", digest);
                            parameters.put("storage", storage);
                            parameters.put("target-digest", target_digest);
                            parameters.put("target-vmid", target_vmid);
                            parameters.put("target-volume", target_volume);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/move_volume", parameters);
                        }

                        /**
                         * Move a rootfs-/mp-volume to a different storage or to
                         * a different container.
                         *
                         * @param volume Volume which will be moved. Enum:
                         * rootfs,mp0,mp1,mp2,mp3,mp4,mp5,mp6,mp7,mp8,mp9,mp10,mp11,mp12,mp13,mp14,mp15,mp16,mp17,mp18,mp19,mp20,mp21,mp22,mp23,mp24,mp25,mp26,mp27,mp28,mp29,mp30,mp31,mp32,mp33,mp34,mp35,mp36,mp37,mp38,mp39,mp40,mp41,mp42,mp43,mp44,mp45,mp46,mp47,mp48,mp49,mp50,mp51,mp52,mp53,mp54,mp55,mp56,mp57,mp58,mp59,mp60,mp61,mp62,mp63,mp64,mp65,mp66,mp67,mp68,mp69,mp70,mp71,mp72,mp73,mp74,mp75,mp76,mp77,mp78,mp79,mp80,mp81,mp82,mp83,mp84,mp85,mp86,mp87,mp88,mp89,mp90,mp91,mp92,mp93,mp94,mp95,mp96,mp97,mp98,mp99,mp100,mp101,mp102,mp103,mp104,mp105,mp106,mp107,mp108,mp109,mp110,mp111,mp112,mp113,mp114,mp115,mp116,mp117,mp118,mp119,mp120,mp121,mp122,mp123,mp124,mp125,mp126,mp127,mp128,mp129,mp130,mp131,mp132,mp133,mp134,mp135,mp136,mp137,mp138,mp139,mp140,mp141,mp142,mp143,mp144,mp145,mp146,mp147,mp148,mp149,mp150,mp151,mp152,mp153,mp154,mp155,mp156,mp157,mp158,mp159,mp160,mp161,mp162,mp163,mp164,mp165,mp166,mp167,mp168,mp169,mp170,mp171,mp172,mp173,mp174,mp175,mp176,mp177,mp178,mp179,mp180,mp181,mp182,mp183,mp184,mp185,mp186,mp187,mp188,mp189,mp190,mp191,mp192,mp193,mp194,mp195,mp196,mp197,mp198,mp199,mp200,mp201,mp202,mp203,mp204,mp205,mp206,mp207,mp208,mp209,mp210,mp211,mp212,mp213,mp214,mp215,mp216,mp217,mp218,mp219,mp220,mp221,mp222,mp223,mp224,mp225,mp226,mp227,mp228,mp229,mp230,mp231,mp232,mp233,mp234,mp235,mp236,mp237,mp238,mp239,mp240,mp241,mp242,mp243,mp244,mp245,mp246,mp247,mp248,mp249,mp250,mp251,mp252,mp253,mp254,mp255,unused0,unused1,unused2,unused3,unused4,unused5,unused6,unused7,unused8,unused9,unused10,unused11,unused12,unused13,unused14,unused15,unused16,unused17,unused18,unused19,unused20,unused21,unused22,unused23,unused24,unused25,unused26,unused27,unused28,unused29,unused30,unused31,unused32,unused33,unused34,unused35,unused36,unused37,unused38,unused39,unused40,unused41,unused42,unused43,unused44,unused45,unused46,unused47,unused48,unused49,unused50,unused51,unused52,unused53,unused54,unused55,unused56,unused57,unused58,unused59,unused60,unused61,unused62,unused63,unused64,unused65,unused66,unused67,unused68,unused69,unused70,unused71,unused72,unused73,unused74,unused75,unused76,unused77,unused78,unused79,unused80,unused81,unused82,unused83,unused84,unused85,unused86,unused87,unused88,unused89,unused90,unused91,unused92,unused93,unused94,unused95,unused96,unused97,unused98,unused99,unused100,unused101,unused102,unused103,unused104,unused105,unused106,unused107,unused108,unused109,unused110,unused111,unused112,unused113,unused114,unused115,unused116,unused117,unused118,unused119,unused120,unused121,unused122,unused123,unused124,unused125,unused126,unused127,unused128,unused129,unused130,unused131,unused132,unused133,unused134,unused135,unused136,unused137,unused138,unused139,unused140,unused141,unused142,unused143,unused144,unused145,unused146,unused147,unused148,unused149,unused150,unused151,unused152,unused153,unused154,unused155,unused156,unused157,unused158,unused159,unused160,unused161,unused162,unused163,unused164,unused165,unused166,unused167,unused168,unused169,unused170,unused171,unused172,unused173,unused174,unused175,unused176,unused177,unused178,unused179,unused180,unused181,unused182,unused183,unused184,unused185,unused186,unused187,unused188,unused189,unused190,unused191,unused192,unused193,unused194,unused195,unused196,unused197,unused198,unused199,unused200,unused201,unused202,unused203,unused204,unused205,unused206,unused207,unused208,unused209,unused210,unused211,unused212,unused213,unused214,unused215,unused216,unused217,unused218,unused219,unused220,unused221,unused222,unused223,unused224,unused225,unused226,unused227,unused228,unused229,unused230,unused231,unused232,unused233,unused234,unused235,unused236,unused237,unused238,unused239,unused240,unused241,unused242,unused243,unused244,unused245,unused246,unused247,unused248,unused249,unused250,unused251,unused252,unused253,unused254,unused255
                         * @return Result
                         * @throws JSONException
                         */

                        public Result moveVolume(String volume) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("volume", volume);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/move_volume", parameters);
                        }

                    }

                    public class PVEPending {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEPending(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Get container configuration, including pending
                         * changes.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result vmPending() throws JSONException {
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/pending", null);
                        }

                    }

                    public class PVEInterfaces {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEInterfaces(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Get IP addresses of the specified container
                         * interface.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result ip() throws JSONException {
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/interfaces", null);
                        }

                    }

                    public class PVEMtunnel {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEMtunnel(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Migration tunnel endpoint - only for internal use by
                         * CT migration.
                         *
                         * @param bridges List of network bridges to check
                         * availability. Will be checked again for actually used
                         * bridges during migration.
                         * @param storages List of storages to check permission
                         * and availability. Will be checked again for all
                         * actually used storages during migration.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result mtunnel(String bridges, String storages) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("bridges", bridges);
                            parameters.put("storages", storages);
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/mtunnel", parameters);
                        }

                        /**
                         * Migration tunnel endpoint - only for internal use by
                         * CT migration.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result mtunnel() throws JSONException {
                            return client.create("/nodes/" + this.node + "/lxc/" + this.vmid + "/mtunnel", null);
                        }

                    }

                    public class PVEMtunnelwebsocket {

                        private final PveClient client;
                        private final Object node;
                        private final Object vmid;

                        protected PVEMtunnelwebsocket(PveClient client, Object node, Object vmid) {
                            this.client = client;
                            this.node = node;
                            this.vmid = vmid;
                        }

                        /**
                         * Migration tunnel endpoint for websocket upgrade -
                         * only for internal use by VM migration.
                         *
                         * @param socket unix socket to forward to
                         * @param ticket ticket return by initial 'mtunnel' API
                         * call, or retrieved via 'ticket' tunnel command
                         * @return Result
                         * @throws JSONException
                         */
                        public Result mtunnelwebsocket(String socket, String ticket) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("socket", socket);
                            parameters.put("ticket", ticket);
                            return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "/mtunnelwebsocket", parameters);
                        }

                    }

                    /**
                     * Destroy the container (also delete all uses files).
                     *
                     * @param destroy_unreferenced_disks If set, destroy
                     * additionally all disks with the VMID from all enabled
                     * storages which are not referenced in the config.
                     * @param force Force destroy, even if running.
                     * @param purge Remove container from all related
                     * configurations. For example, backup jobs, replication
                     * jobs or HA. Related ACLs and Firewall entries will
                     * *always* be removed.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result destroyVm(Boolean destroy_unreferenced_disks, Boolean force, Boolean purge) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("destroy-unreferenced-disks", destroy_unreferenced_disks);
                        parameters.put("force", force);
                        parameters.put("purge", purge);
                        return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "", parameters);
                    }

                    /**
                     * Destroy the container (also delete all uses files).
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result destroyVm() throws JSONException {
                        return client.delete("/nodes/" + this.node + "/lxc/" + this.vmid + "", null);
                    }

                    /**
                     * Directory index
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result vmdiridx() throws JSONException {
                        return client.get("/nodes/" + this.node + "/lxc/" + this.vmid + "", null);
                    }

                }

                /**
                 * LXC container index (per node).
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result vmlist() throws JSONException {
                    return client.get("/nodes/" + this.node + "/lxc", null);
                }

                /**
                 * Create or restore a container.
                 *
                 * @param ostemplate The OS template or backup file.
                 * @param vmid The (unique) ID of the VM.
                 * @param arch OS architecture type. Enum:
                 * amd64,i386,arm64,armhf,riscv32,riscv64
                 * @param bwlimit Override I/O bandwidth limit (in KiB/s).
                 * @param cmode Console mode. By default, the console command
                 * tries to open a connection to one of the available tty
                 * devices. By setting cmode to 'console' it tries to attach to
                 * /dev/console instead. If you set cmode to 'shell', it simply
                 * invokes a shell inside the container (no login). Enum:
                 * shell,console,tty
                 * @param console Attach a console device (/dev/console) to the
                 * container.
                 * @param cores The number of cores assigned to the container. A
                 * container can use all available cores by default.
                 * @param cpulimit Limit of CPU usage. NOTE: If the computer has
                 * 2 CPUs, it has a total of '2' CPU time. Value '0' indicates
                 * no CPU limit.
                 * @param cpuunits CPU weight for a container, will be clamped
                 * to [1, 10000] in cgroup v2.
                 * @param debug Try to be more verbose. For now this only
                 * enables debug log-level on start.
                 * @param description Description for the Container. Shown in
                 * the web-interface CT's summary. This is saved as comment
                 * inside the configuration file.
                 * @param devN Device to pass through to the container
                 * @param features Allow containers access to advanced features.
                 * @param force Allow to overwrite existing container.
                 * @param hookscript Script that will be exectued during various
                 * steps in the containers lifetime.
                 * @param hostname Set a host name for the container.
                 * @param ignore_unpack_errors Ignore errors when extracting the
                 * template.
                 * @param lock_ Lock/unlock the container. Enum:
                 * backup,create,destroyed,disk,fstrim,migrate,mounted,rollback,snapshot,snapshot-delete
                 * @param memory Amount of RAM for the container in MB.
                 * @param mpN Use volume as container mount point. Use the
                 * special syntax STORAGE_ID:SIZE_IN_GiB to allocate a new
                 * volume.
                 * @param nameserver Sets DNS server IP address for a container.
                 * Create will automatically use the setting from the host if
                 * you neither set searchdomain nor nameserver.
                 * @param netN Specifies network interfaces for the container.
                 * @param onboot Specifies whether a container will be started
                 * during system bootup.
                 * @param ostype OS type. This is used to setup configuration
                 * inside the container, and corresponds to lxc setup scripts in
                 * /usr/share/lxc/config/&amp;lt;ostype&amp;gt;.common.conf.
                 * Value 'unmanaged' can be used to skip and OS specific setup.
                 * Enum:
                 * debian,devuan,ubuntu,centos,fedora,opensuse,archlinux,alpine,gentoo,nixos,unmanaged
                 * @param password Sets root password inside container.
                 * @param pool Add the VM to the specified pool.
                 * @param protection Sets the protection flag of the container.
                 * This will prevent the CT or CT's disk remove/update
                 * operation.
                 * @param restore Mark this as restore task.
                 * @param rootfs Use volume as container root.
                 * @param searchdomain Sets DNS search domains for a container.
                 * Create will automatically use the setting from the host if
                 * you neither set searchdomain nor nameserver.
                 * @param ssh_public_keys Setup public SSH keys (one key per
                 * line, OpenSSH format).
                 * @param start Start the CT after its creation finished
                 * successfully.
                 * @param startup Startup and shutdown behavior. Order is a
                 * non-negative number defining the general startup order.
                 * Shutdown in done with reverse ordering. Additionally you can
                 * set the 'up' or 'down' delay in seconds, which specifies a
                 * delay to wait before the next VM is started or stopped.
                 * @param storage Default Storage.
                 * @param swap Amount of SWAP for the container in MB.
                 * @param tags Tags of the Container. This is only meta
                 * information.
                 * @param template Enable/disable Template.
                 * @param timezone Time zone to use in the container. If option
                 * isn't set, then nothing will be done. Can be set to 'host' to
                 * match the host time zone, or an arbitrary time zone option
                 * from /usr/share/zoneinfo/zone.tab
                 * @param tty Specify the number of tty available to the
                 * container
                 * @param unique Assign a unique random ethernet address.
                 * @param unprivileged Makes the container run as unprivileged
                 * user. (Should not be modified manually.)
                 * @param unusedN Reference to unused volumes. This is used
                 * internally, and should not be modified manually.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createVm(String ostemplate, int vmid, String arch, Float bwlimit, String cmode, Boolean console, Integer cores, Float cpulimit, Integer cpuunits, Boolean debug, String description, Map<Integer, String> devN, String features, Boolean force, String hookscript, String hostname, Boolean ignore_unpack_errors, String lock_, Integer memory, Map<Integer, String> mpN, String nameserver, Map<Integer, String> netN, Boolean onboot, String ostype, String password, String pool, Boolean protection, Boolean restore, String rootfs, String searchdomain, String ssh_public_keys, Boolean start, String startup, String storage, Integer swap, String tags, Boolean template, String timezone, Integer tty, Boolean unique, Boolean unprivileged, Map<Integer, String> unusedN) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("ostemplate", ostemplate);
                    parameters.put("vmid", vmid);
                    parameters.put("arch", arch);
                    parameters.put("bwlimit", bwlimit);
                    parameters.put("cmode", cmode);
                    parameters.put("console", console);
                    parameters.put("cores", cores);
                    parameters.put("cpulimit", cpulimit);
                    parameters.put("cpuunits", cpuunits);
                    parameters.put("debug", debug);
                    parameters.put("description", description);
                    parameters.put("features", features);
                    parameters.put("force", force);
                    parameters.put("hookscript", hookscript);
                    parameters.put("hostname", hostname);
                    parameters.put("ignore-unpack-errors", ignore_unpack_errors);
                    parameters.put("lock", lock_);
                    parameters.put("memory", memory);
                    parameters.put("nameserver", nameserver);
                    parameters.put("onboot", onboot);
                    parameters.put("ostype", ostype);
                    parameters.put("password", password);
                    parameters.put("pool", pool);
                    parameters.put("protection", protection);
                    parameters.put("restore", restore);
                    parameters.put("rootfs", rootfs);
                    parameters.put("searchdomain", searchdomain);
                    parameters.put("ssh-public-keys", ssh_public_keys);
                    parameters.put("start", start);
                    parameters.put("startup", startup);
                    parameters.put("storage", storage);
                    parameters.put("swap", swap);
                    parameters.put("tags", tags);
                    parameters.put("template", template);
                    parameters.put("timezone", timezone);
                    parameters.put("tty", tty);
                    parameters.put("unique", unique);
                    parameters.put("unprivileged", unprivileged);
                    addIndexedParameter(parameters, "dev", devN);
                    addIndexedParameter(parameters, "mp", mpN);
                    addIndexedParameter(parameters, "net", netN);
                    addIndexedParameter(parameters, "unused", unusedN);
                    return client.create("/nodes/" + this.node + "/lxc", parameters);
                }

                /**
                 * Create or restore a container.
                 *
                 * @param ostemplate The OS template or backup file.
                 * @param vmid The (unique) ID of the VM.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createVm(String ostemplate, int vmid) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("ostemplate", ostemplate);
                    parameters.put("vmid", vmid);
                    return client.create("/nodes/" + this.node + "/lxc", parameters);
                }

            }

            public class PVECeph {

                private final PveClient client;
                private final Object node;

                protected PVECeph(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                private PVECfg cfg;

                public PVECfg getCfg() {
                    return cfg == null ? (cfg = new PVECfg(client, this.node)) : cfg;
                }
                private PVEOsd osd;

                public PVEOsd getOsd() {
                    return osd == null ? (osd = new PVEOsd(client, this.node)) : osd;
                }
                private PVEMds mds;

                public PVEMds getMds() {
                    return mds == null ? (mds = new PVEMds(client, this.node)) : mds;
                }
                private PVEMgr mgr;

                public PVEMgr getMgr() {
                    return mgr == null ? (mgr = new PVEMgr(client, this.node)) : mgr;
                }
                private PVEMon mon;

                public PVEMon getMon() {
                    return mon == null ? (mon = new PVEMon(client, this.node)) : mon;
                }
                private PVEFs fs;

                public PVEFs getFs() {
                    return fs == null ? (fs = new PVEFs(client, this.node)) : fs;
                }
                private PVEPool pool;

                public PVEPool getPool() {
                    return pool == null ? (pool = new PVEPool(client, this.node)) : pool;
                }
                private PVEInit init;

                public PVEInit getInit() {
                    return init == null ? (init = new PVEInit(client, this.node)) : init;
                }
                private PVEStop stop;

                public PVEStop getStop() {
                    return stop == null ? (stop = new PVEStop(client, this.node)) : stop;
                }
                private PVEStart start;

                public PVEStart getStart() {
                    return start == null ? (start = new PVEStart(client, this.node)) : start;
                }
                private PVERestart restart;

                public PVERestart getRestart() {
                    return restart == null ? (restart = new PVERestart(client, this.node)) : restart;
                }
                private PVEStatus status;

                public PVEStatus getStatus() {
                    return status == null ? (status = new PVEStatus(client, this.node)) : status;
                }
                private PVECrush crush;

                public PVECrush getCrush() {
                    return crush == null ? (crush = new PVECrush(client, this.node)) : crush;
                }
                private PVELog log;

                public PVELog getLog() {
                    return log == null ? (log = new PVELog(client, this.node)) : log;
                }
                private PVERules rules;

                public PVERules getRules() {
                    return rules == null ? (rules = new PVERules(client, this.node)) : rules;
                }
                private PVECmdSafety cmdSafety;

                public PVECmdSafety getCmdSafety() {
                    return cmdSafety == null ? (cmdSafety = new PVECmdSafety(client, this.node)) : cmdSafety;
                }

                public class PVECfg {

                    private final PveClient client;
                    private final Object node;

                    protected PVECfg(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    private PVERaw raw;

                    public PVERaw getRaw() {
                        return raw == null ? (raw = new PVERaw(client, this.node)) : raw;
                    }
                    private PVEDb db;

                    public PVEDb getDb() {
                        return db == null ? (db = new PVEDb(client, this.node)) : db;
                    }
                    private PVEValue value;

                    public PVEValue getValue() {
                        return value == null ? (value = new PVEValue(client, this.node)) : value;
                    }

                    public class PVERaw {

                        private final PveClient client;
                        private final Object node;

                        protected PVERaw(PveClient client, Object node) {
                            this.client = client;
                            this.node = node;
                        }

                        /**
                         * Get the Ceph configuration file.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result raw() throws JSONException {
                            return client.get("/nodes/" + this.node + "/ceph/cfg/raw", null);
                        }

                    }

                    public class PVEDb {

                        private final PveClient client;
                        private final Object node;

                        protected PVEDb(PveClient client, Object node) {
                            this.client = client;
                            this.node = node;
                        }

                        /**
                         * Get the Ceph configuration database.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result db() throws JSONException {
                            return client.get("/nodes/" + this.node + "/ceph/cfg/db", null);
                        }

                    }

                    public class PVEValue {

                        private final PveClient client;
                        private final Object node;

                        protected PVEValue(PveClient client, Object node) {
                            this.client = client;
                            this.node = node;
                        }

                        /**
                         * Get configured values from either the config file or
                         * config DB.
                         *
                         * @param config_keys List of
                         * &amp;lt;section&amp;gt;:&amp;lt;config key&amp;gt;
                         * items.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result value(String config_keys) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("config-keys", config_keys);
                            return client.get("/nodes/" + this.node + "/ceph/cfg/value", parameters);
                        }

                    }

                    /**
                     * Directory index.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/ceph/cfg", null);
                    }

                }

                public class PVEOsd {

                    private final PveClient client;
                    private final Object node;

                    protected PVEOsd(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVEOsdidItem get(Object osdid) {
                        return new PVEOsdidItem(client, this.node, osdid);
                    }

                    public class PVEOsdidItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object osdid;

                        protected PVEOsdidItem(PveClient client, Object node, Object osdid) {
                            this.client = client;
                            this.node = node;
                            this.osdid = osdid;
                        }

                        private PVEMetadata metadata;

                        public PVEMetadata getMetadata() {
                            return metadata == null ? (metadata = new PVEMetadata(client, this.node, this.osdid)) : metadata;
                        }
                        private PVELvInfo lvInfo;

                        public PVELvInfo getLvInfo() {
                            return lvInfo == null ? (lvInfo = new PVELvInfo(client, this.node, this.osdid)) : lvInfo;
                        }
                        private PVEIn in;

                        public PVEIn getIn() {
                            return in == null ? (in = new PVEIn(client, this.node, this.osdid)) : in;
                        }
                        private PVEOut out;

                        public PVEOut getOut() {
                            return out == null ? (out = new PVEOut(client, this.node, this.osdid)) : out;
                        }
                        private PVEScrub scrub;

                        public PVEScrub getScrub() {
                            return scrub == null ? (scrub = new PVEScrub(client, this.node, this.osdid)) : scrub;
                        }

                        public class PVEMetadata {

                            private final PveClient client;
                            private final Object node;
                            private final Object osdid;

                            protected PVEMetadata(PveClient client, Object node, Object osdid) {
                                this.client = client;
                                this.node = node;
                                this.osdid = osdid;
                            }

                            /**
                             * Get OSD details
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result osddetails() throws JSONException {
                                return client.get("/nodes/" + this.node + "/ceph/osd/" + this.osdid + "/metadata", null);
                            }

                        }

                        public class PVELvInfo {

                            private final PveClient client;
                            private final Object node;
                            private final Object osdid;

                            protected PVELvInfo(PveClient client, Object node, Object osdid) {
                                this.client = client;
                                this.node = node;
                                this.osdid = osdid;
                            }

                            /**
                             * Get OSD volume details
                             *
                             * @param type OSD device type Enum: block,db,wal
                             * @return Result
                             * @throws JSONException
                             */
                            public Result osdvolume(String type) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("type", type);
                                return client.get("/nodes/" + this.node + "/ceph/osd/" + this.osdid + "/lv-info", parameters);
                            }

                            /**
                             * Get OSD volume details
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result osdvolume() throws JSONException {
                                return client.get("/nodes/" + this.node + "/ceph/osd/" + this.osdid + "/lv-info", null);
                            }

                        }

                        public class PVEIn {

                            private final PveClient client;
                            private final Object node;
                            private final Object osdid;

                            protected PVEIn(PveClient client, Object node, Object osdid) {
                                this.client = client;
                                this.node = node;
                                this.osdid = osdid;
                            }

                            /**
                             * ceph osd in
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result in() throws JSONException {
                                return client.create("/nodes/" + this.node + "/ceph/osd/" + this.osdid + "/in", null);
                            }

                        }

                        public class PVEOut {

                            private final PveClient client;
                            private final Object node;
                            private final Object osdid;

                            protected PVEOut(PveClient client, Object node, Object osdid) {
                                this.client = client;
                                this.node = node;
                                this.osdid = osdid;
                            }

                            /**
                             * ceph osd out
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result out() throws JSONException {
                                return client.create("/nodes/" + this.node + "/ceph/osd/" + this.osdid + "/out", null);
                            }

                        }

                        public class PVEScrub {

                            private final PveClient client;
                            private final Object node;
                            private final Object osdid;

                            protected PVEScrub(PveClient client, Object node, Object osdid) {
                                this.client = client;
                                this.node = node;
                                this.osdid = osdid;
                            }

                            /**
                             * Instruct the OSD to scrub.
                             *
                             * @param deep If set, instructs a deep scrub
                             * instead of a normal one.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result scrub(Boolean deep) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("deep", deep);
                                return client.create("/nodes/" + this.node + "/ceph/osd/" + this.osdid + "/scrub", parameters);
                            }

                            /**
                             * Instruct the OSD to scrub.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result scrub() throws JSONException {
                                return client.create("/nodes/" + this.node + "/ceph/osd/" + this.osdid + "/scrub", null);
                            }

                        }

                        /**
                         * Destroy OSD
                         *
                         * @param cleanup If set, we remove partition table
                         * entries.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result destroyosd(Boolean cleanup) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("cleanup", cleanup);
                            return client.delete("/nodes/" + this.node + "/ceph/osd/" + this.osdid + "", parameters);
                        }

                        /**
                         * Destroy OSD
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result destroyosd() throws JSONException {
                            return client.delete("/nodes/" + this.node + "/ceph/osd/" + this.osdid + "", null);
                        }

                        /**
                         * OSD index.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result osdindex() throws JSONException {
                            return client.get("/nodes/" + this.node + "/ceph/osd/" + this.osdid + "", null);
                        }

                    }

                    /**
                     * Get Ceph osd list/tree.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/ceph/osd", null);
                    }

                    /**
                     * Create OSD
                     *
                     * @param dev Block device name.
                     * @param crush_device_class Set the device class of the OSD
                     * in crush.
                     * @param db_dev Block device name for block.db.
                     * @param db_dev_size Size in GiB for block.db.
                     * @param encrypted Enables encryption of the OSD.
                     * @param osds_per_device OSD services per physical device.
                     * Only useful for fast NVMe devices" ." to utilize their
                     * performance better.
                     * @param wal_dev Block device name for block.wal.
                     * @param wal_dev_size Size in GiB for block.wal.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createosd(String dev, String crush_device_class, String db_dev, Float db_dev_size, Boolean encrypted, Integer osds_per_device, String wal_dev, Float wal_dev_size) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("dev", dev);
                        parameters.put("crush-device-class", crush_device_class);
                        parameters.put("db_dev", db_dev);
                        parameters.put("db_dev_size", db_dev_size);
                        parameters.put("encrypted", encrypted);
                        parameters.put("osds-per-device", osds_per_device);
                        parameters.put("wal_dev", wal_dev);
                        parameters.put("wal_dev_size", wal_dev_size);
                        return client.create("/nodes/" + this.node + "/ceph/osd", parameters);
                    }

                    /**
                     * Create OSD
                     *
                     * @param dev Block device name.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createosd(String dev) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("dev", dev);
                        return client.create("/nodes/" + this.node + "/ceph/osd", parameters);
                    }

                }

                public class PVEMds {

                    private final PveClient client;
                    private final Object node;

                    protected PVEMds(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVENameItem get(Object name) {
                        return new PVENameItem(client, this.node, name);
                    }

                    public class PVENameItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object name;

                        protected PVENameItem(PveClient client, Object node, Object name) {
                            this.client = client;
                            this.node = node;
                            this.name = name;
                        }

                        /**
                         * Destroy Ceph Metadata Server
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result destroymds() throws JSONException {
                            return client.delete("/nodes/" + this.node + "/ceph/mds/" + this.name + "", null);
                        }

                        /**
                         * Create Ceph Metadata Server (MDS)
                         *
                         * @param hotstandby Determines whether a ceph-mds
                         * daemon should poll and replay the log of an active
                         * MDS. Faster switch on MDS failure, but needs more
                         * idle resources.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result createmds(Boolean hotstandby) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("hotstandby", hotstandby);
                            return client.create("/nodes/" + this.node + "/ceph/mds/" + this.name + "", parameters);
                        }

                        /**
                         * Create Ceph Metadata Server (MDS)
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result createmds() throws JSONException {
                            return client.create("/nodes/" + this.node + "/ceph/mds/" + this.name + "", null);
                        }

                    }

                    /**
                     * MDS directory index.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/ceph/mds", null);
                    }

                }

                public class PVEMgr {

                    private final PveClient client;
                    private final Object node;

                    protected PVEMgr(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVEIdItem get(Object id) {
                        return new PVEIdItem(client, this.node, id);
                    }

                    public class PVEIdItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object id;

                        protected PVEIdItem(PveClient client, Object node, Object id) {
                            this.client = client;
                            this.node = node;
                            this.id = id;
                        }

                        /**
                         * Destroy Ceph Manager.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result destroymgr() throws JSONException {
                            return client.delete("/nodes/" + this.node + "/ceph/mgr/" + this.id + "", null);
                        }

                        /**
                         * Create Ceph Manager
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result createmgr() throws JSONException {
                            return client.create("/nodes/" + this.node + "/ceph/mgr/" + this.id + "", null);
                        }

                    }

                    /**
                     * MGR directory index.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/ceph/mgr", null);
                    }

                }

                public class PVEMon {

                    private final PveClient client;
                    private final Object node;

                    protected PVEMon(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVEMonidItem get(Object monid) {
                        return new PVEMonidItem(client, this.node, monid);
                    }

                    public class PVEMonidItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object monid;

                        protected PVEMonidItem(PveClient client, Object node, Object monid) {
                            this.client = client;
                            this.node = node;
                            this.monid = monid;
                        }

                        /**
                         * Destroy Ceph Monitor and Manager.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result destroymon() throws JSONException {
                            return client.delete("/nodes/" + this.node + "/ceph/mon/" + this.monid + "", null);
                        }

                        /**
                         * Create Ceph Monitor and Manager
                         *
                         * @param mon_address Overwrites autodetected monitor IP
                         * address(es). Must be in the public network(s) of
                         * Ceph.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result createmon(String mon_address) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("mon-address", mon_address);
                            return client.create("/nodes/" + this.node + "/ceph/mon/" + this.monid + "", parameters);
                        }

                        /**
                         * Create Ceph Monitor and Manager
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result createmon() throws JSONException {
                            return client.create("/nodes/" + this.node + "/ceph/mon/" + this.monid + "", null);
                        }

                    }

                    /**
                     * Get Ceph monitor list.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result listmon() throws JSONException {
                        return client.get("/nodes/" + this.node + "/ceph/mon", null);
                    }

                }

                public class PVEFs {

                    private final PveClient client;
                    private final Object node;

                    protected PVEFs(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVENameItem get(Object name) {
                        return new PVENameItem(client, this.node, name);
                    }

                    public class PVENameItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object name;

                        protected PVENameItem(PveClient client, Object node, Object name) {
                            this.client = client;
                            this.node = node;
                            this.name = name;
                        }

                        /**
                         * Create a Ceph filesystem
                         *
                         * @param add_storage Configure the created CephFS as
                         * storage for this cluster.
                         * @param pg_num Number of placement groups for the
                         * backing data pool. The metadata pool will use a
                         * quarter of this.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result createfs(Boolean add_storage, Integer pg_num) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("add-storage", add_storage);
                            parameters.put("pg_num", pg_num);
                            return client.create("/nodes/" + this.node + "/ceph/fs/" + this.name + "", parameters);
                        }

                        /**
                         * Create a Ceph filesystem
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result createfs() throws JSONException {
                            return client.create("/nodes/" + this.node + "/ceph/fs/" + this.name + "", null);
                        }

                    }

                    /**
                     * Directory index.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/ceph/fs", null);
                    }

                }

                public class PVEPool {

                    private final PveClient client;
                    private final Object node;

                    protected PVEPool(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVENameItem get(Object name) {
                        return new PVENameItem(client, this.node, name);
                    }

                    public class PVENameItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object name;

                        protected PVENameItem(PveClient client, Object node, Object name) {
                            this.client = client;
                            this.node = node;
                            this.name = name;
                        }

                        private PVEStatus status;

                        public PVEStatus getStatus() {
                            return status == null ? (status = new PVEStatus(client, this.node, this.name)) : status;
                        }

                        public class PVEStatus {

                            private final PveClient client;
                            private final Object node;
                            private final Object name;

                            protected PVEStatus(PveClient client, Object node, Object name) {
                                this.client = client;
                                this.node = node;
                                this.name = name;
                            }

                            /**
                             * Show the current pool status.
                             *
                             * @param verbose If enabled, will display
                             * additional data(eg. statistics).
                             * @return Result
                             * @throws JSONException
                             */
                            public Result getpool(Boolean verbose) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("verbose", verbose);
                                return client.get("/nodes/" + this.node + "/ceph/pool/" + this.name + "/status", parameters);
                            }

                            /**
                             * Show the current pool status.
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result getpool() throws JSONException {
                                return client.get("/nodes/" + this.node + "/ceph/pool/" + this.name + "/status", null);
                            }

                        }

                        /**
                         * Destroy pool
                         *
                         * @param force If true, destroys pool even if in use
                         * @param remove_ecprofile Remove the erasure code
                         * profile. Defaults to true, if applicable.
                         * @param remove_storages Remove all pveceph-managed
                         * storages configured for this pool
                         * @return Result
                         * @throws JSONException
                         */
                        public Result destroypool(Boolean force, Boolean remove_ecprofile, Boolean remove_storages) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("force", force);
                            parameters.put("remove_ecprofile", remove_ecprofile);
                            parameters.put("remove_storages", remove_storages);
                            return client.delete("/nodes/" + this.node + "/ceph/pool/" + this.name + "", parameters);
                        }

                        /**
                         * Destroy pool
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result destroypool() throws JSONException {
                            return client.delete("/nodes/" + this.node + "/ceph/pool/" + this.name + "", null);
                        }

                        /**
                         * Pool index.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result poolindex() throws JSONException {
                            return client.get("/nodes/" + this.node + "/ceph/pool/" + this.name + "", null);
                        }

                        /**
                         * Change POOL settings
                         *
                         * @param application The application of the pool. Enum:
                         * rbd,cephfs,rgw
                         * @param crush_rule The rule to use for mapping object
                         * placement in the cluster.
                         * @param min_size Minimum number of replicas per object
                         * @param pg_autoscale_mode The automatic PG scaling
                         * mode of the pool. Enum: on,off,warn
                         * @param pg_num Number of placement groups.
                         * @param pg_num_min Minimal number of placement groups.
                         * @param size Number of replicas per object
                         * @param target_size The estimated target size of the
                         * pool for the PG autoscaler.
                         * @param target_size_ratio The estimated target ratio
                         * of the pool for the PG autoscaler.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result setpool(String application, String crush_rule, Integer min_size, String pg_autoscale_mode, Integer pg_num, Integer pg_num_min, Integer size, String target_size, Float target_size_ratio) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("application", application);
                            parameters.put("crush_rule", crush_rule);
                            parameters.put("min_size", min_size);
                            parameters.put("pg_autoscale_mode", pg_autoscale_mode);
                            parameters.put("pg_num", pg_num);
                            parameters.put("pg_num_min", pg_num_min);
                            parameters.put("size", size);
                            parameters.put("target_size", target_size);
                            parameters.put("target_size_ratio", target_size_ratio);
                            return client.set("/nodes/" + this.node + "/ceph/pool/" + this.name + "", parameters);
                        }

                        /**
                         * Change POOL settings
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result setpool() throws JSONException {
                            return client.set("/nodes/" + this.node + "/ceph/pool/" + this.name + "", null);
                        }

                    }

                    /**
                     * List all pools and their settings (which are settable by
                     * the POST/PUT endpoints).
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result lspools() throws JSONException {
                        return client.get("/nodes/" + this.node + "/ceph/pool", null);
                    }

                    /**
                     * Create Ceph pool
                     *
                     * @param name The name of the pool. It must be unique.
                     * @param add_storages Configure VM and CT storage using the
                     * new pool.
                     * @param application The application of the pool. Enum:
                     * rbd,cephfs,rgw
                     * @param crush_rule The rule to use for mapping object
                     * placement in the cluster.
                     * @param erasure_coding Create an erasure coded pool for
                     * RBD with an accompaning replicated pool for metadata
                     * storage. With EC, the common ceph options 'size',
                     * 'min_size' and 'crush_rule' parameters will be applied to
                     * the metadata pool.
                     * @param min_size Minimum number of replicas per object
                     * @param pg_autoscale_mode The automatic PG scaling mode of
                     * the pool. Enum: on,off,warn
                     * @param pg_num Number of placement groups.
                     * @param pg_num_min Minimal number of placement groups.
                     * @param size Number of replicas per object
                     * @param target_size The estimated target size of the pool
                     * for the PG autoscaler.
                     * @param target_size_ratio The estimated target ratio of
                     * the pool for the PG autoscaler.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createpool(String name, Boolean add_storages, String application, String crush_rule, String erasure_coding, Integer min_size, String pg_autoscale_mode, Integer pg_num, Integer pg_num_min, Integer size, String target_size, Float target_size_ratio) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("name", name);
                        parameters.put("add_storages", add_storages);
                        parameters.put("application", application);
                        parameters.put("crush_rule", crush_rule);
                        parameters.put("erasure-coding", erasure_coding);
                        parameters.put("min_size", min_size);
                        parameters.put("pg_autoscale_mode", pg_autoscale_mode);
                        parameters.put("pg_num", pg_num);
                        parameters.put("pg_num_min", pg_num_min);
                        parameters.put("size", size);
                        parameters.put("target_size", target_size);
                        parameters.put("target_size_ratio", target_size_ratio);
                        return client.create("/nodes/" + this.node + "/ceph/pool", parameters);
                    }

                    /**
                     * Create Ceph pool
                     *
                     * @param name The name of the pool. It must be unique.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createpool(String name) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("name", name);
                        return client.create("/nodes/" + this.node + "/ceph/pool", parameters);
                    }

                }

                public class PVEInit {

                    private final PveClient client;
                    private final Object node;

                    protected PVEInit(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Create initial ceph default configuration and setup
                     * symlinks.
                     *
                     * @param cluster_network Declare a separate cluster
                     * network, OSDs will routeheartbeat, object replication and
                     * recovery traffic over it
                     * @param disable_cephx Disable cephx authentication.
                     * WARNING: cephx is a security feature protecting against
                     * man-in-the-middle attacks. Only consider disabling cephx
                     * if your network is private!
                     * @param min_size Minimum number of available replicas per
                     * object to allow I/O
                     * @param network Use specific network for all ceph related
                     * traffic
                     * @param pg_bits Placement group bits, used to specify the
                     * default number of placement groups. Depreacted. This
                     * setting was deprecated in recent Ceph versions.
                     * @param size Targeted number of replicas per object
                     * @return Result
                     * @throws JSONException
                     */
                    public Result init(String cluster_network, Boolean disable_cephx, Integer min_size, String network, Integer pg_bits, Integer size) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("cluster-network", cluster_network);
                        parameters.put("disable_cephx", disable_cephx);
                        parameters.put("min_size", min_size);
                        parameters.put("network", network);
                        parameters.put("pg_bits", pg_bits);
                        parameters.put("size", size);
                        return client.create("/nodes/" + this.node + "/ceph/init", parameters);
                    }

                    /**
                     * Create initial ceph default configuration and setup
                     * symlinks.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result init() throws JSONException {
                        return client.create("/nodes/" + this.node + "/ceph/init", null);
                    }

                }

                public class PVEStop {

                    private final PveClient client;
                    private final Object node;

                    protected PVEStop(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Stop ceph services.
                     *
                     * @param service Ceph service name.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result stop(String service) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("service", service);
                        return client.create("/nodes/" + this.node + "/ceph/stop", parameters);
                    }

                    /**
                     * Stop ceph services.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result stop() throws JSONException {
                        return client.create("/nodes/" + this.node + "/ceph/stop", null);
                    }

                }

                public class PVEStart {

                    private final PveClient client;
                    private final Object node;

                    protected PVEStart(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Start ceph services.
                     *
                     * @param service Ceph service name.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result start(String service) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("service", service);
                        return client.create("/nodes/" + this.node + "/ceph/start", parameters);
                    }

                    /**
                     * Start ceph services.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result start() throws JSONException {
                        return client.create("/nodes/" + this.node + "/ceph/start", null);
                    }

                }

                public class PVERestart {

                    private final PveClient client;
                    private final Object node;

                    protected PVERestart(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Restart ceph services.
                     *
                     * @param service Ceph service name.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result restart(String service) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("service", service);
                        return client.create("/nodes/" + this.node + "/ceph/restart", parameters);
                    }

                    /**
                     * Restart ceph services.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result restart() throws JSONException {
                        return client.create("/nodes/" + this.node + "/ceph/restart", null);
                    }

                }

                public class PVEStatus {

                    private final PveClient client;
                    private final Object node;

                    protected PVEStatus(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Get ceph status.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result status() throws JSONException {
                        return client.get("/nodes/" + this.node + "/ceph/status", null);
                    }

                }

                public class PVECrush {

                    private final PveClient client;
                    private final Object node;

                    protected PVECrush(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Get OSD crush map
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result crush() throws JSONException {
                        return client.get("/nodes/" + this.node + "/ceph/crush", null);
                    }

                }

                public class PVELog {

                    private final PveClient client;
                    private final Object node;

                    protected PVELog(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Read ceph log
                     *
                     * @param limit
                     * @param start
                     * @return Result
                     * @throws JSONException
                     */
                    public Result log(Integer limit, Integer start) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("limit", limit);
                        parameters.put("start", start);
                        return client.get("/nodes/" + this.node + "/ceph/log", parameters);
                    }

                    /**
                     * Read ceph log
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result log() throws JSONException {
                        return client.get("/nodes/" + this.node + "/ceph/log", null);
                    }

                }

                public class PVERules {

                    private final PveClient client;
                    private final Object node;

                    protected PVERules(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * List ceph rules.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result rules() throws JSONException {
                        return client.get("/nodes/" + this.node + "/ceph/rules", null);
                    }

                }

                public class PVECmdSafety {

                    private final PveClient client;
                    private final Object node;

                    protected PVECmdSafety(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Heuristical check if it is safe to perform an action.
                     *
                     * @param action Action to check Enum: stop,destroy
                     * @param id ID of the service
                     * @param service Service type Enum: osd,mon,mds
                     * @return Result
                     * @throws JSONException
                     */
                    public Result cmdSafety(String action, String id, String service) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("action", action);
                        parameters.put("id", id);
                        parameters.put("service", service);
                        return client.get("/nodes/" + this.node + "/ceph/cmd-safety", parameters);
                    }

                }

                /**
                 * Directory index.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result index() throws JSONException {
                    return client.get("/nodes/" + this.node + "/ceph", null);
                }

            }

            public class PVEVzdump {

                private final PveClient client;
                private final Object node;

                protected PVEVzdump(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                private PVEDefaults defaults;

                public PVEDefaults getDefaults() {
                    return defaults == null ? (defaults = new PVEDefaults(client, this.node)) : defaults;
                }
                private PVEExtractconfig extractconfig;

                public PVEExtractconfig getExtractconfig() {
                    return extractconfig == null ? (extractconfig = new PVEExtractconfig(client, this.node)) : extractconfig;
                }

                public class PVEDefaults {

                    private final PveClient client;
                    private final Object node;

                    protected PVEDefaults(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Get the currently configured vzdump defaults.
                     *
                     * @param storage The storage identifier.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result defaults(String storage) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("storage", storage);
                        return client.get("/nodes/" + this.node + "/vzdump/defaults", parameters);
                    }

                    /**
                     * Get the currently configured vzdump defaults.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result defaults() throws JSONException {
                        return client.get("/nodes/" + this.node + "/vzdump/defaults", null);
                    }

                }

                public class PVEExtractconfig {

                    private final PveClient client;
                    private final Object node;

                    protected PVEExtractconfig(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Extract configuration from vzdump backup archive.
                     *
                     * @param volume Volume identifier
                     * @return Result
                     * @throws JSONException
                     */
                    public Result extractconfig(String volume) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("volume", volume);
                        return client.get("/nodes/" + this.node + "/vzdump/extractconfig", parameters);
                    }

                }

                /**
                 * Create backup.
                 *
                 * @param all Backup all known guest systems on this host.
                 * @param bwlimit Limit I/O bandwidth (in KiB/s).
                 * @param compress Compress dump file. Enum: 0,1,gzip,lzo,zstd
                 * @param dumpdir Store resulting files to specified directory.
                 * @param exclude Exclude specified guest systems (assumes
                 * --all)
                 * @param exclude_path Exclude certain files/directories (shell
                 * globs). Paths starting with '/' are anchored to the
                 * container's root, other paths match relative to each
                 * subdirectory.
                 * @param ionice Set IO priority when using the BFQ scheduler.
                 * For snapshot and suspend mode backups of VMs, this only
                 * affects the compressor. A value of 8 means the idle priority
                 * is used, otherwise the best-effort priority is used with the
                 * specified value.
                 * @param lockwait Maximal time to wait for the global lock
                 * (minutes).
                 * @param mailnotification Deprecated: use 'notification-policy'
                 * instead. Enum: always,failure
                 * @param mailto Comma-separated list of email addresses or
                 * users that should receive email notifications. Has no effect
                 * if the 'notification-target' option is set at the same time.
                 * @param maxfiles Deprecated: use 'prune-backups' instead.
                 * Maximal number of backup files per guest system.
                 * @param mode Backup mode. Enum: snapshot,suspend,stop
                 * @param notes_template Template string for generating notes
                 * for the backup(s). It can contain variables which will be
                 * replaced by their values. Currently supported are
                 * {{cluster}}, {{guestname}}, {{node}}, and {{vmid}}, but more
                 * might be added in the future. Needs to be a single line,
                 * newline and backslash need to be escaped as '\n' and '\\'
                 * respectively.
                 * @param notification_policy Specify when to send a
                 * notification Enum: always,failure,never
                 * @param notification_target Determine the target to which
                 * notifications should be sent. Can either be a notification
                 * endpoint or a notification group. This option takes
                 * precedence over 'mailto', meaning that if both are set, the
                 * 'mailto' option will be ignored.
                 * @param performance Other performance-related settings.
                 * @param pigz Use pigz instead of gzip when N&amp;gt;0. N=1
                 * uses half of cores, N&amp;gt;1 uses N as thread count.
                 * @param pool Backup all known guest systems included in the
                 * specified pool.
                 * @param protected_ If true, mark backup(s) as protected.
                 * @param prune_backups Use these retention options instead of
                 * those from the storage configuration.
                 * @param quiet Be quiet.
                 * @param remove Prune older backups according to
                 * 'prune-backups'.
                 * @param script Use specified hook script.
                 * @param stdexcludes Exclude temporary files and logs.
                 * @param stdout Write tar to stdout, not to a file.
                 * @param stop Stop running backup jobs on this host.
                 * @param stopwait Maximal time to wait until a guest system is
                 * stopped (minutes).
                 * @param storage Store resulting file to this storage.
                 * @param tmpdir Store temporary files to specified directory.
                 * @param vmid The ID of the guest system you want to backup.
                 * @param zstd Zstd threads. N=0 uses half of the available
                 * cores, N&amp;gt;0 uses N as thread count.
                 * @return Result
                 * @throws JSONException
                 */
                public Result vzdump(Boolean all, Integer bwlimit, String compress, String dumpdir, String exclude, String exclude_path, Integer ionice, Integer lockwait, String mailnotification, String mailto, Integer maxfiles, String mode, String notes_template, String notification_policy, String notification_target, String performance, Integer pigz, String pool, Boolean protected_, String prune_backups, Boolean quiet, Boolean remove, String script, Boolean stdexcludes, Boolean stdout, Boolean stop, Integer stopwait, String storage, String tmpdir, String vmid, Integer zstd) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("all", all);
                    parameters.put("bwlimit", bwlimit);
                    parameters.put("compress", compress);
                    parameters.put("dumpdir", dumpdir);
                    parameters.put("exclude", exclude);
                    parameters.put("exclude-path", exclude_path);
                    parameters.put("ionice", ionice);
                    parameters.put("lockwait", lockwait);
                    parameters.put("mailnotification", mailnotification);
                    parameters.put("mailto", mailto);
                    parameters.put("maxfiles", maxfiles);
                    parameters.put("mode", mode);
                    parameters.put("notes-template", notes_template);
                    parameters.put("notification-policy", notification_policy);
                    parameters.put("notification-target", notification_target);
                    parameters.put("performance", performance);
                    parameters.put("pigz", pigz);
                    parameters.put("pool", pool);
                    parameters.put("protected", protected_);
                    parameters.put("prune-backups", prune_backups);
                    parameters.put("quiet", quiet);
                    parameters.put("remove", remove);
                    parameters.put("script", script);
                    parameters.put("stdexcludes", stdexcludes);
                    parameters.put("stdout", stdout);
                    parameters.put("stop", stop);
                    parameters.put("stopwait", stopwait);
                    parameters.put("storage", storage);
                    parameters.put("tmpdir", tmpdir);
                    parameters.put("vmid", vmid);
                    parameters.put("zstd", zstd);
                    return client.create("/nodes/" + this.node + "/vzdump", parameters);
                }

                /**
                 * Create backup.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result vzdump() throws JSONException {
                    return client.create("/nodes/" + this.node + "/vzdump", null);
                }

            }

            public class PVEServices {

                private final PveClient client;
                private final Object node;

                protected PVEServices(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                public PVEServiceItem get(Object service) {
                    return new PVEServiceItem(client, this.node, service);
                }

                public class PVEServiceItem {

                    private final PveClient client;
                    private final Object node;
                    private final Object service;

                    protected PVEServiceItem(PveClient client, Object node, Object service) {
                        this.client = client;
                        this.node = node;
                        this.service = service;
                    }

                    private PVEState state;

                    public PVEState getState() {
                        return state == null ? (state = new PVEState(client, this.node, this.service)) : state;
                    }
                    private PVEStart start;

                    public PVEStart getStart() {
                        return start == null ? (start = new PVEStart(client, this.node, this.service)) : start;
                    }
                    private PVEStop stop;

                    public PVEStop getStop() {
                        return stop == null ? (stop = new PVEStop(client, this.node, this.service)) : stop;
                    }
                    private PVERestart restart;

                    public PVERestart getRestart() {
                        return restart == null ? (restart = new PVERestart(client, this.node, this.service)) : restart;
                    }
                    private PVEReload reload;

                    public PVEReload getReload() {
                        return reload == null ? (reload = new PVEReload(client, this.node, this.service)) : reload;
                    }

                    public class PVEState {

                        private final PveClient client;
                        private final Object node;
                        private final Object service;

                        protected PVEState(PveClient client, Object node, Object service) {
                            this.client = client;
                            this.node = node;
                            this.service = service;
                        }

                        /**
                         * Read service properties
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result serviceState() throws JSONException {
                            return client.get("/nodes/" + this.node + "/services/" + this.service + "/state", null);
                        }

                    }

                    public class PVEStart {

                        private final PveClient client;
                        private final Object node;
                        private final Object service;

                        protected PVEStart(PveClient client, Object node, Object service) {
                            this.client = client;
                            this.node = node;
                            this.service = service;
                        }

                        /**
                         * Start service.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result serviceStart() throws JSONException {
                            return client.create("/nodes/" + this.node + "/services/" + this.service + "/start", null);
                        }

                    }

                    public class PVEStop {

                        private final PveClient client;
                        private final Object node;
                        private final Object service;

                        protected PVEStop(PveClient client, Object node, Object service) {
                            this.client = client;
                            this.node = node;
                            this.service = service;
                        }

                        /**
                         * Stop service.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result serviceStop() throws JSONException {
                            return client.create("/nodes/" + this.node + "/services/" + this.service + "/stop", null);
                        }

                    }

                    public class PVERestart {

                        private final PveClient client;
                        private final Object node;
                        private final Object service;

                        protected PVERestart(PveClient client, Object node, Object service) {
                            this.client = client;
                            this.node = node;
                            this.service = service;
                        }

                        /**
                         * Hard restart service. Use reload if you want to
                         * reduce interruptions.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result serviceRestart() throws JSONException {
                            return client.create("/nodes/" + this.node + "/services/" + this.service + "/restart", null);
                        }

                    }

                    public class PVEReload {

                        private final PveClient client;
                        private final Object node;
                        private final Object service;

                        protected PVEReload(PveClient client, Object node, Object service) {
                            this.client = client;
                            this.node = node;
                            this.service = service;
                        }

                        /**
                         * Reload service. Falls back to restart if service
                         * cannot be reloaded.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result serviceReload() throws JSONException {
                            return client.create("/nodes/" + this.node + "/services/" + this.service + "/reload", null);
                        }

                    }

                    /**
                     * Directory index
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result srvcmdidx() throws JSONException {
                        return client.get("/nodes/" + this.node + "/services/" + this.service + "", null);
                    }

                }

                /**
                 * Service list.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result index() throws JSONException {
                    return client.get("/nodes/" + this.node + "/services", null);
                }

            }

            public class PVESubscription {

                private final PveClient client;
                private final Object node;

                protected PVESubscription(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Delete subscription key of this node.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result delete() throws JSONException {
                    return client.delete("/nodes/" + this.node + "/subscription", null);
                }

                /**
                 * Read subscription info.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result get() throws JSONException {
                    return client.get("/nodes/" + this.node + "/subscription", null);
                }

                /**
                 * Update subscription info.
                 *
                 * @param force Always connect to server, even if local cache is
                 * still valid.
                 * @return Result
                 * @throws JSONException
                 */

                public Result update(Boolean force) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("force", force);
                    return client.create("/nodes/" + this.node + "/subscription", parameters);
                }

                /**
                 * Update subscription info.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result update() throws JSONException {
                    return client.create("/nodes/" + this.node + "/subscription", null);
                }

                /**
                 * Set subscription key.
                 *
                 * @param key Proxmox VE subscription key
                 * @return Result
                 * @throws JSONException
                 */

                public Result set(String key) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("key", key);
                    return client.set("/nodes/" + this.node + "/subscription", parameters);
                }

            }

            public class PVENetwork {

                private final PveClient client;
                private final Object node;

                protected PVENetwork(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                public PVEIfaceItem get(Object iface) {
                    return new PVEIfaceItem(client, this.node, iface);
                }

                public class PVEIfaceItem {

                    private final PveClient client;
                    private final Object node;
                    private final Object iface;

                    protected PVEIfaceItem(PveClient client, Object node, Object iface) {
                        this.client = client;
                        this.node = node;
                        this.iface = iface;
                    }

                    /**
                     * Delete network device configuration
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result deleteNetwork() throws JSONException {
                        return client.delete("/nodes/" + this.node + "/network/" + this.iface + "", null);
                    }

                    /**
                     * Read network device configuration
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result networkConfig() throws JSONException {
                        return client.get("/nodes/" + this.node + "/network/" + this.iface + "", null);
                    }

                    /**
                     * Update network device configuration
                     *
                     * @param type Network interface type Enum:
                     * bridge,bond,eth,alias,vlan,OVSBridge,OVSBond,OVSPort,OVSIntPort,unknown
                     * @param address IP address.
                     * @param address6 IP address.
                     * @param autostart Automatically start interface on boot.
                     * @param bond_primary Specify the primary interface for
                     * active-backup bond.
                     * @param bond_mode Bonding mode. Enum:
                     * balance-rr,active-backup,balance-xor,broadcast,802.3ad,balance-tlb,balance-alb,balance-slb,lacp-balance-slb,lacp-balance-tcp
                     * @param bond_xmit_hash_policy Selects the transmit hash
                     * policy to use for slave selection in balance-xor and
                     * 802.3ad modes. Enum: layer2,layer2+3,layer3+4
                     * @param bridge_ports Specify the interfaces you want to
                     * add to your bridge.
                     * @param bridge_vlan_aware Enable bridge vlan support.
                     * @param cidr IPv4 CIDR.
                     * @param cidr6 IPv6 CIDR.
                     * @param comments Comments
                     * @param comments6 Comments
                     * @param delete A list of settings you want to delete.
                     * @param gateway Default gateway address.
                     * @param gateway6 Default ipv6 gateway address.
                     * @param mtu MTU.
                     * @param netmask Network mask.
                     * @param netmask6 Network mask.
                     * @param ovs_bonds Specify the interfaces used by the
                     * bonding device.
                     * @param ovs_bridge The OVS bridge associated with a OVS
                     * port. This is required when you create an OVS port.
                     * @param ovs_options OVS interface options.
                     * @param ovs_ports Specify the interfaces you want to add
                     * to your bridge.
                     * @param ovs_tag Specify a VLan tag (used by OVSPort,
                     * OVSIntPort, OVSBond)
                     * @param slaves Specify the interfaces used by the bonding
                     * device.
                     * @param vlan_id vlan-id for a custom named vlan interface
                     * (ifupdown2 only).
                     * @param vlan_raw_device Specify the raw interface for the
                     * vlan interface.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateNetwork(String type, String address, String address6, Boolean autostart, String bond_primary, String bond_mode, String bond_xmit_hash_policy, String bridge_ports, Boolean bridge_vlan_aware, String cidr, String cidr6, String comments, String comments6, String delete, String gateway, String gateway6, Integer mtu, String netmask, Integer netmask6, String ovs_bonds, String ovs_bridge, String ovs_options, String ovs_ports, Integer ovs_tag, String slaves, Integer vlan_id, String vlan_raw_device) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("type", type);
                        parameters.put("address", address);
                        parameters.put("address6", address6);
                        parameters.put("autostart", autostart);
                        parameters.put("bond-primary", bond_primary);
                        parameters.put("bond_mode", bond_mode);
                        parameters.put("bond_xmit_hash_policy", bond_xmit_hash_policy);
                        parameters.put("bridge_ports", bridge_ports);
                        parameters.put("bridge_vlan_aware", bridge_vlan_aware);
                        parameters.put("cidr", cidr);
                        parameters.put("cidr6", cidr6);
                        parameters.put("comments", comments);
                        parameters.put("comments6", comments6);
                        parameters.put("delete", delete);
                        parameters.put("gateway", gateway);
                        parameters.put("gateway6", gateway6);
                        parameters.put("mtu", mtu);
                        parameters.put("netmask", netmask);
                        parameters.put("netmask6", netmask6);
                        parameters.put("ovs_bonds", ovs_bonds);
                        parameters.put("ovs_bridge", ovs_bridge);
                        parameters.put("ovs_options", ovs_options);
                        parameters.put("ovs_ports", ovs_ports);
                        parameters.put("ovs_tag", ovs_tag);
                        parameters.put("slaves", slaves);
                        parameters.put("vlan-id", vlan_id);
                        parameters.put("vlan-raw-device", vlan_raw_device);
                        return client.set("/nodes/" + this.node + "/network/" + this.iface + "", parameters);
                    }

                    /**
                     * Update network device configuration
                     *
                     * @param type Network interface type Enum:
                     * bridge,bond,eth,alias,vlan,OVSBridge,OVSBond,OVSPort,OVSIntPort,unknown
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateNetwork(String type) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("type", type);
                        return client.set("/nodes/" + this.node + "/network/" + this.iface + "", parameters);
                    }

                }

                /**
                 * Revert network configuration changes.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result revertNetworkChanges() throws JSONException {
                    return client.delete("/nodes/" + this.node + "/network", null);
                }

                /**
                 * List available networks
                 *
                 * @param type Only list specific interface types. Enum:
                 * bridge,bond,eth,alias,vlan,OVSBridge,OVSBond,OVSPort,OVSIntPort,any_bridge,any_local_bridge
                 * @return Result
                 * @throws JSONException
                 */

                public Result index(String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("type", type);
                    return client.get("/nodes/" + this.node + "/network", parameters);
                }

                /**
                 * List available networks
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result index() throws JSONException {
                    return client.get("/nodes/" + this.node + "/network", null);
                }

                /**
                 * Create network device configuration
                 *
                 * @param iface Network interface name.
                 * @param type Network interface type Enum:
                 * bridge,bond,eth,alias,vlan,OVSBridge,OVSBond,OVSPort,OVSIntPort,unknown
                 * @param address IP address.
                 * @param address6 IP address.
                 * @param autostart Automatically start interface on boot.
                 * @param bond_primary Specify the primary interface for
                 * active-backup bond.
                 * @param bond_mode Bonding mode. Enum:
                 * balance-rr,active-backup,balance-xor,broadcast,802.3ad,balance-tlb,balance-alb,balance-slb,lacp-balance-slb,lacp-balance-tcp
                 * @param bond_xmit_hash_policy Selects the transmit hash policy
                 * to use for slave selection in balance-xor and 802.3ad modes.
                 * Enum: layer2,layer2+3,layer3+4
                 * @param bridge_ports Specify the interfaces you want to add to
                 * your bridge.
                 * @param bridge_vlan_aware Enable bridge vlan support.
                 * @param cidr IPv4 CIDR.
                 * @param cidr6 IPv6 CIDR.
                 * @param comments Comments
                 * @param comments6 Comments
                 * @param gateway Default gateway address.
                 * @param gateway6 Default ipv6 gateway address.
                 * @param mtu MTU.
                 * @param netmask Network mask.
                 * @param netmask6 Network mask.
                 * @param ovs_bonds Specify the interfaces used by the bonding
                 * device.
                 * @param ovs_bridge The OVS bridge associated with a OVS port.
                 * This is required when you create an OVS port.
                 * @param ovs_options OVS interface options.
                 * @param ovs_ports Specify the interfaces you want to add to
                 * your bridge.
                 * @param ovs_tag Specify a VLan tag (used by OVSPort,
                 * OVSIntPort, OVSBond)
                 * @param slaves Specify the interfaces used by the bonding
                 * device.
                 * @param vlan_id vlan-id for a custom named vlan interface
                 * (ifupdown2 only).
                 * @param vlan_raw_device Specify the raw interface for the vlan
                 * interface.
                 * @return Result
                 * @throws JSONException
                 */

                public Result createNetwork(String iface, String type, String address, String address6, Boolean autostart, String bond_primary, String bond_mode, String bond_xmit_hash_policy, String bridge_ports, Boolean bridge_vlan_aware, String cidr, String cidr6, String comments, String comments6, String gateway, String gateway6, Integer mtu, String netmask, Integer netmask6, String ovs_bonds, String ovs_bridge, String ovs_options, String ovs_ports, Integer ovs_tag, String slaves, Integer vlan_id, String vlan_raw_device) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("iface", iface);
                    parameters.put("type", type);
                    parameters.put("address", address);
                    parameters.put("address6", address6);
                    parameters.put("autostart", autostart);
                    parameters.put("bond-primary", bond_primary);
                    parameters.put("bond_mode", bond_mode);
                    parameters.put("bond_xmit_hash_policy", bond_xmit_hash_policy);
                    parameters.put("bridge_ports", bridge_ports);
                    parameters.put("bridge_vlan_aware", bridge_vlan_aware);
                    parameters.put("cidr", cidr);
                    parameters.put("cidr6", cidr6);
                    parameters.put("comments", comments);
                    parameters.put("comments6", comments6);
                    parameters.put("gateway", gateway);
                    parameters.put("gateway6", gateway6);
                    parameters.put("mtu", mtu);
                    parameters.put("netmask", netmask);
                    parameters.put("netmask6", netmask6);
                    parameters.put("ovs_bonds", ovs_bonds);
                    parameters.put("ovs_bridge", ovs_bridge);
                    parameters.put("ovs_options", ovs_options);
                    parameters.put("ovs_ports", ovs_ports);
                    parameters.put("ovs_tag", ovs_tag);
                    parameters.put("slaves", slaves);
                    parameters.put("vlan-id", vlan_id);
                    parameters.put("vlan-raw-device", vlan_raw_device);
                    return client.create("/nodes/" + this.node + "/network", parameters);
                }

                /**
                 * Create network device configuration
                 *
                 * @param iface Network interface name.
                 * @param type Network interface type Enum:
                 * bridge,bond,eth,alias,vlan,OVSBridge,OVSBond,OVSPort,OVSIntPort,unknown
                 * @return Result
                 * @throws JSONException
                 */

                public Result createNetwork(String iface, String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("iface", iface);
                    parameters.put("type", type);
                    return client.create("/nodes/" + this.node + "/network", parameters);
                }

                /**
                 * Reload network configuration
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result reloadNetworkConfig() throws JSONException {
                    return client.set("/nodes/" + this.node + "/network", null);
                }

            }

            public class PVETasks {

                private final PveClient client;
                private final Object node;

                protected PVETasks(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                public PVEUpidItem get(Object upid) {
                    return new PVEUpidItem(client, this.node, upid);
                }

                public class PVEUpidItem {

                    private final PveClient client;
                    private final Object node;
                    private final Object upid;

                    protected PVEUpidItem(PveClient client, Object node, Object upid) {
                        this.client = client;
                        this.node = node;
                        this.upid = upid;
                    }

                    private PVELog log;

                    public PVELog getLog() {
                        return log == null ? (log = new PVELog(client, this.node, this.upid)) : log;
                    }
                    private PVEStatus status;

                    public PVEStatus getStatus() {
                        return status == null ? (status = new PVEStatus(client, this.node, this.upid)) : status;
                    }

                    public class PVELog {

                        private final PveClient client;
                        private final Object node;
                        private final Object upid;

                        protected PVELog(PveClient client, Object node, Object upid) {
                            this.client = client;
                            this.node = node;
                            this.upid = upid;
                        }

                        /**
                         * Read task log.
                         *
                         * @param download Whether the tasklog file should be
                         * downloaded. This parameter can't be used in
                         * conjunction with other parameters
                         * @param limit The amount of lines to read from the
                         * tasklog.
                         * @param start Start at this line when reading the
                         * tasklog
                         * @return Result
                         * @throws JSONException
                         */
                        public Result readTaskLog(Boolean download, Integer limit, Integer start) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("download", download);
                            parameters.put("limit", limit);
                            parameters.put("start", start);
                            return client.get("/nodes/" + this.node + "/tasks/" + this.upid + "/log", parameters);
                        }

                        /**
                         * Read task log.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result readTaskLog() throws JSONException {
                            return client.get("/nodes/" + this.node + "/tasks/" + this.upid + "/log", null);
                        }

                    }

                    public class PVEStatus {

                        private final PveClient client;
                        private final Object node;
                        private final Object upid;

                        protected PVEStatus(PveClient client, Object node, Object upid) {
                            this.client = client;
                            this.node = node;
                            this.upid = upid;
                        }

                        /**
                         * Read task status.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result readTaskStatus() throws JSONException {
                            return client.get("/nodes/" + this.node + "/tasks/" + this.upid + "/status", null);
                        }

                    }

                    /**
                     * Stop a task.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result stopTask() throws JSONException {
                        return client.delete("/nodes/" + this.node + "/tasks/" + this.upid + "", null);
                    }

                    /**
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result upidIndex() throws JSONException {
                        return client.get("/nodes/" + this.node + "/tasks/" + this.upid + "", null);
                    }

                }

                /**
                 * Read task list for one node (finished tasks).
                 *
                 * @param errors Only list tasks with a status of ERROR.
                 * @param limit Only list this amount of tasks.
                 * @param since Only list tasks since this UNIX epoch.
                 * @param source List archived, active or all tasks. Enum:
                 * archive,active,all
                 * @param start List tasks beginning from this offset.
                 * @param statusfilter List of Task States that should be
                 * returned.
                 * @param typefilter Only list tasks of this type (e.g.,
                 * vzstart, vzdump).
                 * @param until Only list tasks until this UNIX epoch.
                 * @param userfilter Only list tasks from this user.
                 * @param vmid Only list tasks for this VM.
                 * @return Result
                 * @throws JSONException
                 */
                public Result nodeTasks(Boolean errors, Integer limit, Integer since, String source, Integer start, String statusfilter, String typefilter, Integer until, String userfilter, Integer vmid) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("errors", errors);
                    parameters.put("limit", limit);
                    parameters.put("since", since);
                    parameters.put("source", source);
                    parameters.put("start", start);
                    parameters.put("statusfilter", statusfilter);
                    parameters.put("typefilter", typefilter);
                    parameters.put("until", until);
                    parameters.put("userfilter", userfilter);
                    parameters.put("vmid", vmid);
                    return client.get("/nodes/" + this.node + "/tasks", parameters);
                }

                /**
                 * Read task list for one node (finished tasks).
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result nodeTasks() throws JSONException {
                    return client.get("/nodes/" + this.node + "/tasks", null);
                }

            }

            public class PVEScan {

                private final PveClient client;
                private final Object node;

                protected PVEScan(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                private PVENfs nfs;

                public PVENfs getNfs() {
                    return nfs == null ? (nfs = new PVENfs(client, this.node)) : nfs;
                }
                private PVECifs cifs;

                public PVECifs getCifs() {
                    return cifs == null ? (cifs = new PVECifs(client, this.node)) : cifs;
                }
                private PVEPbs pbs;

                public PVEPbs getPbs() {
                    return pbs == null ? (pbs = new PVEPbs(client, this.node)) : pbs;
                }
                private PVEGlusterfs glusterfs;

                public PVEGlusterfs getGlusterfs() {
                    return glusterfs == null ? (glusterfs = new PVEGlusterfs(client, this.node)) : glusterfs;
                }
                private PVEIscsi iscsi;

                public PVEIscsi getIscsi() {
                    return iscsi == null ? (iscsi = new PVEIscsi(client, this.node)) : iscsi;
                }
                private PVELvm lvm;

                public PVELvm getLvm() {
                    return lvm == null ? (lvm = new PVELvm(client, this.node)) : lvm;
                }
                private PVELvmthin lvmthin;

                public PVELvmthin getLvmthin() {
                    return lvmthin == null ? (lvmthin = new PVELvmthin(client, this.node)) : lvmthin;
                }
                private PVEZfs zfs;

                public PVEZfs getZfs() {
                    return zfs == null ? (zfs = new PVEZfs(client, this.node)) : zfs;
                }

                public class PVENfs {

                    private final PveClient client;
                    private final Object node;

                    protected PVENfs(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Scan remote NFS server.
                     *
                     * @param server The server address (name or IP).
                     * @return Result
                     * @throws JSONException
                     */
                    public Result nfsscan(String server) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("server", server);
                        return client.get("/nodes/" + this.node + "/scan/nfs", parameters);
                    }

                }

                public class PVECifs {

                    private final PveClient client;
                    private final Object node;

                    protected PVECifs(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Scan remote CIFS server.
                     *
                     * @param server The server address (name or IP).
                     * @param domain SMB domain (Workgroup).
                     * @param password User password.
                     * @param username User name.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result cifsscan(String server, String domain, String password, String username) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("server", server);
                        parameters.put("domain", domain);
                        parameters.put("password", password);
                        parameters.put("username", username);
                        return client.get("/nodes/" + this.node + "/scan/cifs", parameters);
                    }

                    /**
                     * Scan remote CIFS server.
                     *
                     * @param server The server address (name or IP).
                     * @return Result
                     * @throws JSONException
                     */

                    public Result cifsscan(String server) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("server", server);
                        return client.get("/nodes/" + this.node + "/scan/cifs", parameters);
                    }

                }

                public class PVEPbs {

                    private final PveClient client;
                    private final Object node;

                    protected PVEPbs(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Scan remote Proxmox Backup Server.
                     *
                     * @param password User password or API token secret.
                     * @param server The server address (name or IP).
                     * @param username User-name or API token-ID.
                     * @param fingerprint Certificate SHA 256 fingerprint.
                     * @param port Optional port.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result pbsscan(String password, String server, String username, String fingerprint, Integer port) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("password", password);
                        parameters.put("server", server);
                        parameters.put("username", username);
                        parameters.put("fingerprint", fingerprint);
                        parameters.put("port", port);
                        return client.get("/nodes/" + this.node + "/scan/pbs", parameters);
                    }

                    /**
                     * Scan remote Proxmox Backup Server.
                     *
                     * @param password User password or API token secret.
                     * @param server The server address (name or IP).
                     * @param username User-name or API token-ID.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result pbsscan(String password, String server, String username) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("password", password);
                        parameters.put("server", server);
                        parameters.put("username", username);
                        return client.get("/nodes/" + this.node + "/scan/pbs", parameters);
                    }

                }

                public class PVEGlusterfs {

                    private final PveClient client;
                    private final Object node;

                    protected PVEGlusterfs(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Scan remote GlusterFS server.
                     *
                     * @param server The server address (name or IP).
                     * @return Result
                     * @throws JSONException
                     */
                    public Result glusterfsscan(String server) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("server", server);
                        return client.get("/nodes/" + this.node + "/scan/glusterfs", parameters);
                    }

                }

                public class PVEIscsi {

                    private final PveClient client;
                    private final Object node;

                    protected PVEIscsi(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Scan remote iSCSI server.
                     *
                     * @param portal The iSCSI portal (IP or DNS name with
                     * optional port).
                     * @return Result
                     * @throws JSONException
                     */
                    public Result iscsiscan(String portal) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("portal", portal);
                        return client.get("/nodes/" + this.node + "/scan/iscsi", parameters);
                    }

                }

                public class PVELvm {

                    private final PveClient client;
                    private final Object node;

                    protected PVELvm(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * List local LVM volume groups.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result lvmscan() throws JSONException {
                        return client.get("/nodes/" + this.node + "/scan/lvm", null);
                    }

                }

                public class PVELvmthin {

                    private final PveClient client;
                    private final Object node;

                    protected PVELvmthin(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * List local LVM Thin Pools.
                     *
                     * @param vg
                     * @return Result
                     * @throws JSONException
                     */
                    public Result lvmthinscan(String vg) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("vg", vg);
                        return client.get("/nodes/" + this.node + "/scan/lvmthin", parameters);
                    }

                }

                public class PVEZfs {

                    private final PveClient client;
                    private final Object node;

                    protected PVEZfs(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Scan zfs pool list on local node.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result zfsscan() throws JSONException {
                        return client.get("/nodes/" + this.node + "/scan/zfs", null);
                    }

                }

                /**
                 * Index of available scan methods
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result index() throws JSONException {
                    return client.get("/nodes/" + this.node + "/scan", null);
                }

            }

            public class PVEHardware {

                private final PveClient client;
                private final Object node;

                protected PVEHardware(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                private PVEPci pci;

                public PVEPci getPci() {
                    return pci == null ? (pci = new PVEPci(client, this.node)) : pci;
                }
                private PVEUsb usb;

                public PVEUsb getUsb() {
                    return usb == null ? (usb = new PVEUsb(client, this.node)) : usb;
                }

                public class PVEPci {

                    private final PveClient client;
                    private final Object node;

                    protected PVEPci(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVEPciidItem get(Object pciid) {
                        return new PVEPciidItem(client, this.node, pciid);
                    }

                    public class PVEPciidItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object pciid;

                        protected PVEPciidItem(PveClient client, Object node, Object pciid) {
                            this.client = client;
                            this.node = node;
                            this.pciid = pciid;
                        }

                        private PVEMdev mdev;

                        public PVEMdev getMdev() {
                            return mdev == null ? (mdev = new PVEMdev(client, this.node, this.pciid)) : mdev;
                        }

                        public class PVEMdev {

                            private final PveClient client;
                            private final Object node;
                            private final Object pciid;

                            protected PVEMdev(PveClient client, Object node, Object pciid) {
                                this.client = client;
                                this.node = node;
                                this.pciid = pciid;
                            }

                            /**
                             * List mediated device types for given PCI device.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result mdevscan() throws JSONException {
                                return client.get("/nodes/" + this.node + "/hardware/pci/" + this.pciid + "/mdev", null);
                            }

                        }

                        /**
                         * Index of available pci methods
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result pciindex() throws JSONException {
                            return client.get("/nodes/" + this.node + "/hardware/pci/" + this.pciid + "", null);
                        }

                    }

                    /**
                     * List local PCI devices.
                     *
                     * @param pci_class_blacklist A list of blacklisted PCI
                     * classes, which will not be returned. Following are
                     * filtered by default: Memory Controller (05), Bridge (06)
                     * and Processor (0b).
                     * @param verbose If disabled, does only print the PCI IDs.
                     * Otherwise, additional information like vendor and device
                     * will be returned.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result pciscan(String pci_class_blacklist, Boolean verbose) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("pci-class-blacklist", pci_class_blacklist);
                        parameters.put("verbose", verbose);
                        return client.get("/nodes/" + this.node + "/hardware/pci", parameters);
                    }

                    /**
                     * List local PCI devices.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result pciscan() throws JSONException {
                        return client.get("/nodes/" + this.node + "/hardware/pci", null);
                    }

                }

                public class PVEUsb {

                    private final PveClient client;
                    private final Object node;

                    protected PVEUsb(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * List local USB devices.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result usbscan() throws JSONException {
                        return client.get("/nodes/" + this.node + "/hardware/usb", null);
                    }

                }

                /**
                 * Index of hardware types
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result index() throws JSONException {
                    return client.get("/nodes/" + this.node + "/hardware", null);
                }

            }

            public class PVECapabilities {

                private final PveClient client;
                private final Object node;

                protected PVECapabilities(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                private PVEQemu qemu;

                public PVEQemu getQemu() {
                    return qemu == null ? (qemu = new PVEQemu(client, this.node)) : qemu;
                }

                public class PVEQemu {

                    private final PveClient client;
                    private final Object node;

                    protected PVEQemu(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    private PVECpu cpu;

                    public PVECpu getCpu() {
                        return cpu == null ? (cpu = new PVECpu(client, this.node)) : cpu;
                    }
                    private PVEMachines machines;

                    public PVEMachines getMachines() {
                        return machines == null ? (machines = new PVEMachines(client, this.node)) : machines;
                    }

                    public class PVECpu {

                        private final PveClient client;
                        private final Object node;

                        protected PVECpu(PveClient client, Object node) {
                            this.client = client;
                            this.node = node;
                        }

                        /**
                         * List all custom and default CPU models.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result index() throws JSONException {
                            return client.get("/nodes/" + this.node + "/capabilities/qemu/cpu", null);
                        }

                    }

                    public class PVEMachines {

                        private final PveClient client;
                        private final Object node;

                        protected PVEMachines(PveClient client, Object node) {
                            this.client = client;
                            this.node = node;
                        }

                        /**
                         * Get available QEMU/KVM machine types.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result types() throws JSONException {
                            return client.get("/nodes/" + this.node + "/capabilities/qemu/machines", null);
                        }

                    }

                    /**
                     * QEMU capabilities index.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result qemuCapsIndex() throws JSONException {
                        return client.get("/nodes/" + this.node + "/capabilities/qemu", null);
                    }

                }

                /**
                 * Node capabilities index.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result index() throws JSONException {
                    return client.get("/nodes/" + this.node + "/capabilities", null);
                }

            }

            public class PVEStorage {

                private final PveClient client;
                private final Object node;

                protected PVEStorage(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                public PVEStorageItem get(Object storage) {
                    return new PVEStorageItem(client, this.node, storage);
                }

                public class PVEStorageItem {

                    private final PveClient client;
                    private final Object node;
                    private final Object storage;

                    protected PVEStorageItem(PveClient client, Object node, Object storage) {
                        this.client = client;
                        this.node = node;
                        this.storage = storage;
                    }

                    private PVEPrunebackups prunebackups;

                    public PVEPrunebackups getPrunebackups() {
                        return prunebackups == null ? (prunebackups = new PVEPrunebackups(client, this.node, this.storage)) : prunebackups;
                    }
                    private PVEContent content;

                    public PVEContent getContent() {
                        return content == null ? (content = new PVEContent(client, this.node, this.storage)) : content;
                    }
                    private PVEFileRestore fileRestore;

                    public PVEFileRestore getFileRestore() {
                        return fileRestore == null ? (fileRestore = new PVEFileRestore(client, this.node, this.storage)) : fileRestore;
                    }
                    private PVEStatus status;

                    public PVEStatus getStatus() {
                        return status == null ? (status = new PVEStatus(client, this.node, this.storage)) : status;
                    }
                    private PVERrd rrd;

                    public PVERrd getRrd() {
                        return rrd == null ? (rrd = new PVERrd(client, this.node, this.storage)) : rrd;
                    }
                    private PVERrddata rrddata;

                    public PVERrddata getRrddata() {
                        return rrddata == null ? (rrddata = new PVERrddata(client, this.node, this.storage)) : rrddata;
                    }
                    private PVEUpload upload;

                    public PVEUpload getUpload() {
                        return upload == null ? (upload = new PVEUpload(client, this.node, this.storage)) : upload;
                    }
                    private PVEDownloadUrl downloadUrl;

                    public PVEDownloadUrl getDownloadUrl() {
                        return downloadUrl == null ? (downloadUrl = new PVEDownloadUrl(client, this.node, this.storage)) : downloadUrl;
                    }

                    public class PVEPrunebackups {

                        private final PveClient client;
                        private final Object node;
                        private final Object storage;

                        protected PVEPrunebackups(PveClient client, Object node, Object storage) {
                            this.client = client;
                            this.node = node;
                            this.storage = storage;
                        }

                        /**
                         * Prune backups. Only those using the standard naming
                         * scheme are considered.
                         *
                         * @param prune_backups Use these retention options
                         * instead of those from the storage configuration.
                         * @param type Either 'qemu' or 'lxc'. Only consider
                         * backups for guests of this type. Enum: qemu,lxc
                         * @param vmid Only prune backups for this VM.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result delete(String prune_backups, String type, Integer vmid) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("prune-backups", prune_backups);
                            parameters.put("type", type);
                            parameters.put("vmid", vmid);
                            return client.delete("/nodes/" + this.node + "/storage/" + this.storage + "/prunebackups", parameters);
                        }

                        /**
                         * Prune backups. Only those using the standard naming
                         * scheme are considered.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result delete() throws JSONException {
                            return client.delete("/nodes/" + this.node + "/storage/" + this.storage + "/prunebackups", null);
                        }

                        /**
                         * Get prune information for backups. NOTE: this is only
                         * a preview and might not be what a subsequent prune
                         * call does if backups are removed/added in the
                         * meantime.
                         *
                         * @param prune_backups Use these retention options
                         * instead of those from the storage configuration.
                         * @param type Either 'qemu' or 'lxc'. Only consider
                         * backups for guests of this type. Enum: qemu,lxc
                         * @param vmid Only consider backups for this guest.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result dryrun(String prune_backups, String type, Integer vmid) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("prune-backups", prune_backups);
                            parameters.put("type", type);
                            parameters.put("vmid", vmid);
                            return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/prunebackups", parameters);
                        }

                        /**
                         * Get prune information for backups. NOTE: this is only
                         * a preview and might not be what a subsequent prune
                         * call does if backups are removed/added in the
                         * meantime.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result dryrun() throws JSONException {
                            return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/prunebackups", null);
                        }

                    }

                    public class PVEContent {

                        private final PveClient client;
                        private final Object node;
                        private final Object storage;

                        protected PVEContent(PveClient client, Object node, Object storage) {
                            this.client = client;
                            this.node = node;
                            this.storage = storage;
                        }

                        public PVEVolumeItem get(Object volume) {
                            return new PVEVolumeItem(client, this.node, this.storage, volume);
                        }

                        public class PVEVolumeItem {

                            private final PveClient client;
                            private final Object node;
                            private final Object storage;
                            private final Object volume;

                            protected PVEVolumeItem(PveClient client, Object node, Object storage, Object volume) {
                                this.client = client;
                                this.node = node;
                                this.storage = storage;
                                this.volume = volume;
                            }

                            /**
                             * Delete volume
                             *
                             * @param delay Time to wait for the task to finish.
                             * We return 'null' if the task finish within that
                             * time.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result delete(Integer delay) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("delay", delay);
                                return client.delete("/nodes/" + this.node + "/storage/" + this.storage + "/content/" + this.volume + "", parameters);
                            }

                            /**
                             * Delete volume
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result delete() throws JSONException {
                                return client.delete("/nodes/" + this.node + "/storage/" + this.storage + "/content/" + this.volume + "", null);
                            }

                            /**
                             * Get volume attributes
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result info() throws JSONException {
                                return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/content/" + this.volume + "", null);
                            }

                            /**
                             * Copy a volume. This is experimental code - do not
                             * use.
                             *
                             * @param target Target volume identifier
                             * @param target_node Target node. Default is local
                             * node.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result copy(String target, String target_node) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("target", target);
                                parameters.put("target_node", target_node);
                                return client.create("/nodes/" + this.node + "/storage/" + this.storage + "/content/" + this.volume + "", parameters);
                            }

                            /**
                             * Copy a volume. This is experimental code - do not
                             * use.
                             *
                             * @param target Target volume identifier
                             * @return Result
                             * @throws JSONException
                             */

                            public Result copy(String target) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("target", target);
                                return client.create("/nodes/" + this.node + "/storage/" + this.storage + "/content/" + this.volume + "", parameters);
                            }

                            /**
                             * Update volume attributes
                             *
                             * @param notes The new notes.
                             * @param protected_ Protection status. Currently
                             * only supported for backups.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result updateattributes(String notes, Boolean protected_) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("notes", notes);
                                parameters.put("protected", protected_);
                                return client.set("/nodes/" + this.node + "/storage/" + this.storage + "/content/" + this.volume + "", parameters);
                            }

                            /**
                             * Update volume attributes
                             *
                             * @return Result
                             * @throws JSONException
                             */

                            public Result updateattributes() throws JSONException {
                                return client.set("/nodes/" + this.node + "/storage/" + this.storage + "/content/" + this.volume + "", null);
                            }

                        }

                        /**
                         * List storage content.
                         *
                         * @param content Only list content of this type.
                         * @param vmid Only list images for this VM
                         * @return Result
                         * @throws JSONException
                         */
                        public Result index(String content, Integer vmid) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("content", content);
                            parameters.put("vmid", vmid);
                            return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/content", parameters);
                        }

                        /**
                         * List storage content.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result index() throws JSONException {
                            return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/content", null);
                        }

                        /**
                         * Allocate disk images.
                         *
                         * @param filename The name of the file to create.
                         * @param size Size in kilobyte (1024 bytes). Optional
                         * suffixes 'M' (megabyte, 1024K) and 'G' (gigabyte,
                         * 1024M)
                         * @param vmid Specify owner VM
                         * @param format Enum: raw,qcow2,subvol
                         * @return Result
                         * @throws JSONException
                         */

                        public Result create(String filename, String size, int vmid, String format) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("filename", filename);
                            parameters.put("size", size);
                            parameters.put("vmid", vmid);
                            parameters.put("format", format);
                            return client.create("/nodes/" + this.node + "/storage/" + this.storage + "/content", parameters);
                        }

                        /**
                         * Allocate disk images.
                         *
                         * @param filename The name of the file to create.
                         * @param size Size in kilobyte (1024 bytes). Optional
                         * suffixes 'M' (megabyte, 1024K) and 'G' (gigabyte,
                         * 1024M)
                         * @param vmid Specify owner VM
                         * @return Result
                         * @throws JSONException
                         */

                        public Result create(String filename, String size, int vmid) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("filename", filename);
                            parameters.put("size", size);
                            parameters.put("vmid", vmid);
                            return client.create("/nodes/" + this.node + "/storage/" + this.storage + "/content", parameters);
                        }

                    }

                    public class PVEFileRestore {

                        private final PveClient client;
                        private final Object node;
                        private final Object storage;

                        protected PVEFileRestore(PveClient client, Object node, Object storage) {
                            this.client = client;
                            this.node = node;
                            this.storage = storage;
                        }

                        private PVEList list;

                        public PVEList getList() {
                            return list == null ? (list = new PVEList(client, this.node, this.storage)) : list;
                        }
                        private PVEDownload download;

                        public PVEDownload getDownload() {
                            return download == null ? (download = new PVEDownload(client, this.node, this.storage)) : download;
                        }

                        public class PVEList {

                            private final PveClient client;
                            private final Object node;
                            private final Object storage;

                            protected PVEList(PveClient client, Object node, Object storage) {
                                this.client = client;
                                this.node = node;
                                this.storage = storage;
                            }

                            /**
                             * List files and directories for single file
                             * restore under the given path.
                             *
                             * @param filepath base64-path to the directory or
                             * file being listed, or "/".
                             * @param volume Backup volume ID or name. Currently
                             * only PBS snapshots are supported.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result list(String filepath, String volume) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("filepath", filepath);
                                parameters.put("volume", volume);
                                return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/file-restore/list", parameters);
                            }

                        }

                        public class PVEDownload {

                            private final PveClient client;
                            private final Object node;
                            private final Object storage;

                            protected PVEDownload(PveClient client, Object node, Object storage) {
                                this.client = client;
                                this.node = node;
                                this.storage = storage;
                            }

                            /**
                             * Extract a file or directory (as zip archive) from
                             * a PBS backup.
                             *
                             * @param filepath base64-path to the directory or
                             * file to download.
                             * @param volume Backup volume ID or name. Currently
                             * only PBS snapshots are supported.
                             * @param tar Download dirs as 'tar.zst' instead of
                             * 'zip'.
                             * @return Result
                             * @throws JSONException
                             */
                            public Result download(String filepath, String volume, Boolean tar) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("filepath", filepath);
                                parameters.put("volume", volume);
                                parameters.put("tar", tar);
                                return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/file-restore/download", parameters);
                            }

                            /**
                             * Extract a file or directory (as zip archive) from
                             * a PBS backup.
                             *
                             * @param filepath base64-path to the directory or
                             * file to download.
                             * @param volume Backup volume ID or name. Currently
                             * only PBS snapshots are supported.
                             * @return Result
                             * @throws JSONException
                             */

                            public Result download(String filepath, String volume) throws JSONException {
                                Map<String, Object> parameters = new HashMap<>();
                                parameters.put("filepath", filepath);
                                parameters.put("volume", volume);
                                return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/file-restore/download", parameters);
                            }

                        }

                    }

                    public class PVEStatus {

                        private final PveClient client;
                        private final Object node;
                        private final Object storage;

                        protected PVEStatus(PveClient client, Object node, Object storage) {
                            this.client = client;
                            this.node = node;
                            this.storage = storage;
                        }

                        /**
                         * Read storage status.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result readStatus() throws JSONException {
                            return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/status", null);
                        }

                    }

                    public class PVERrd {

                        private final PveClient client;
                        private final Object node;
                        private final Object storage;

                        protected PVERrd(PveClient client, Object node, Object storage) {
                            this.client = client;
                            this.node = node;
                            this.storage = storage;
                        }

                        /**
                         * Read storage RRD statistics (returns PNG).
                         *
                         * @param ds The list of datasources you want to
                         * display.
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @param cf The RRD consolidation function Enum:
                         * AVERAGE,MAX
                         * @return Result
                         * @throws JSONException
                         */
                        public Result rrd(String ds, String timeframe, String cf) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ds", ds);
                            parameters.put("timeframe", timeframe);
                            parameters.put("cf", cf);
                            return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/rrd", parameters);
                        }

                        /**
                         * Read storage RRD statistics (returns PNG).
                         *
                         * @param ds The list of datasources you want to
                         * display.
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @return Result
                         * @throws JSONException
                         */

                        public Result rrd(String ds, String timeframe) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("ds", ds);
                            parameters.put("timeframe", timeframe);
                            return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/rrd", parameters);
                        }

                    }

                    public class PVERrddata {

                        private final PveClient client;
                        private final Object node;
                        private final Object storage;

                        protected PVERrddata(PveClient client, Object node, Object storage) {
                            this.client = client;
                            this.node = node;
                            this.storage = storage;
                        }

                        /**
                         * Read storage RRD statistics.
                         *
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @param cf The RRD consolidation function Enum:
                         * AVERAGE,MAX
                         * @return Result
                         * @throws JSONException
                         */
                        public Result rrddata(String timeframe, String cf) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("timeframe", timeframe);
                            parameters.put("cf", cf);
                            return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/rrddata", parameters);
                        }

                        /**
                         * Read storage RRD statistics.
                         *
                         * @param timeframe Specify the time frame you are
                         * interested in. Enum: hour,day,week,month,year
                         * @return Result
                         * @throws JSONException
                         */

                        public Result rrddata(String timeframe) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("timeframe", timeframe);
                            return client.get("/nodes/" + this.node + "/storage/" + this.storage + "/rrddata", parameters);
                        }

                    }

                    public class PVEUpload {

                        private final PveClient client;
                        private final Object node;
                        private final Object storage;

                        protected PVEUpload(PveClient client, Object node, Object storage) {
                            this.client = client;
                            this.node = node;
                            this.storage = storage;
                        }

                        /**
                         * Upload templates and ISO images.
                         *
                         * @param content Content type. Enum: iso,vztmpl
                         * @param filename The name of the file to create.
                         * Caution: This will be normalized!
                         * @param checksum The expected checksum of the file.
                         * @param checksum_algorithm The algorithm to calculate
                         * the checksum of the file. Enum:
                         * md5,sha1,sha224,sha256,sha384,sha512
                         * @param tmpfilename The source file name. This
                         * parameter is usually set by the REST handler. You can
                         * only overwrite it when connecting to the trusted port
                         * on localhost.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result upload(String content, String filename, String checksum, String checksum_algorithm, String tmpfilename) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("content", content);
                            parameters.put("filename", filename);
                            parameters.put("checksum", checksum);
                            parameters.put("checksum-algorithm", checksum_algorithm);
                            parameters.put("tmpfilename", tmpfilename);
                            return client.create("/nodes/" + this.node + "/storage/" + this.storage + "/upload", parameters);
                        }

                        /**
                         * Upload templates and ISO images.
                         *
                         * @param content Content type. Enum: iso,vztmpl
                         * @param filename The name of the file to create.
                         * Caution: This will be normalized!
                         * @return Result
                         * @throws JSONException
                         */

                        public Result upload(String content, String filename) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("content", content);
                            parameters.put("filename", filename);
                            return client.create("/nodes/" + this.node + "/storage/" + this.storage + "/upload", parameters);
                        }

                    }

                    public class PVEDownloadUrl {

                        private final PveClient client;
                        private final Object node;
                        private final Object storage;

                        protected PVEDownloadUrl(PveClient client, Object node, Object storage) {
                            this.client = client;
                            this.node = node;
                            this.storage = storage;
                        }

                        /**
                         * Download templates and ISO images by using an URL.
                         *
                         * @param content Content type. Enum: iso,vztmpl
                         * @param filename The name of the file to create.
                         * Caution: This will be normalized!
                         * @param url The URL to download the file from.
                         * @param checksum The expected checksum of the file.
                         * @param checksum_algorithm The algorithm to calculate
                         * the checksum of the file. Enum:
                         * md5,sha1,sha224,sha256,sha384,sha512
                         * @param compression Decompress the downloaded file
                         * using the specified compression algorithm.
                         * @param verify_certificates If false, no SSL/TLS
                         * certificates will be verified.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result downloadUrl(String content, String filename, String url, String checksum, String checksum_algorithm, String compression, Boolean verify_certificates) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("content", content);
                            parameters.put("filename", filename);
                            parameters.put("url", url);
                            parameters.put("checksum", checksum);
                            parameters.put("checksum-algorithm", checksum_algorithm);
                            parameters.put("compression", compression);
                            parameters.put("verify-certificates", verify_certificates);
                            return client.create("/nodes/" + this.node + "/storage/" + this.storage + "/download-url", parameters);
                        }

                        /**
                         * Download templates and ISO images by using an URL.
                         *
                         * @param content Content type. Enum: iso,vztmpl
                         * @param filename The name of the file to create.
                         * Caution: This will be normalized!
                         * @param url The URL to download the file from.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result downloadUrl(String content, String filename, String url) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("content", content);
                            parameters.put("filename", filename);
                            parameters.put("url", url);
                            return client.create("/nodes/" + this.node + "/storage/" + this.storage + "/download-url", parameters);
                        }

                    }

                    /**
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result diridx() throws JSONException {
                        return client.get("/nodes/" + this.node + "/storage/" + this.storage + "", null);
                    }

                }

                /**
                 * Get status for all datastores.
                 *
                 * @param content Only list stores which support this content
                 * type.
                 * @param enabled Only list stores which are enabled (not
                 * disabled in config).
                 * @param format Include information about formats
                 * @param storage Only list status for specified storage
                 * @param target If target is different to 'node', we only lists
                 * shared storages which content is accessible on this 'node'
                 * and the specified 'target' node.
                 * @return Result
                 * @throws JSONException
                 */
                public Result index(String content, Boolean enabled, Boolean format, String storage, String target) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("content", content);
                    parameters.put("enabled", enabled);
                    parameters.put("format", format);
                    parameters.put("storage", storage);
                    parameters.put("target", target);
                    return client.get("/nodes/" + this.node + "/storage", parameters);
                }

                /**
                 * Get status for all datastores.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result index() throws JSONException {
                    return client.get("/nodes/" + this.node + "/storage", null);
                }

            }

            public class PVEDisks {

                private final PveClient client;
                private final Object node;

                protected PVEDisks(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                private PVELvm lvm;

                public PVELvm getLvm() {
                    return lvm == null ? (lvm = new PVELvm(client, this.node)) : lvm;
                }
                private PVELvmthin lvmthin;

                public PVELvmthin getLvmthin() {
                    return lvmthin == null ? (lvmthin = new PVELvmthin(client, this.node)) : lvmthin;
                }
                private PVEDirectory directory;

                public PVEDirectory getDirectory() {
                    return directory == null ? (directory = new PVEDirectory(client, this.node)) : directory;
                }
                private PVEZfs zfs;

                public PVEZfs getZfs() {
                    return zfs == null ? (zfs = new PVEZfs(client, this.node)) : zfs;
                }
                private PVEList list;

                public PVEList getList() {
                    return list == null ? (list = new PVEList(client, this.node)) : list;
                }
                private PVESmart smart;

                public PVESmart getSmart() {
                    return smart == null ? (smart = new PVESmart(client, this.node)) : smart;
                }
                private PVEInitgpt initgpt;

                public PVEInitgpt getInitgpt() {
                    return initgpt == null ? (initgpt = new PVEInitgpt(client, this.node)) : initgpt;
                }
                private PVEWipedisk wipedisk;

                public PVEWipedisk getWipedisk() {
                    return wipedisk == null ? (wipedisk = new PVEWipedisk(client, this.node)) : wipedisk;
                }

                public class PVELvm {

                    private final PveClient client;
                    private final Object node;

                    protected PVELvm(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVENameItem get(Object name) {
                        return new PVENameItem(client, this.node, name);
                    }

                    public class PVENameItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object name;

                        protected PVENameItem(PveClient client, Object node, Object name) {
                            this.client = client;
                            this.node = node;
                            this.name = name;
                        }

                        /**
                         * Remove an LVM Volume Group.
                         *
                         * @param cleanup_config Marks associated storage(s) as
                         * not available on this node anymore or removes them
                         * from the configuration (if configured for this node
                         * only).
                         * @param cleanup_disks Also wipe disks so they can be
                         * repurposed afterwards.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result delete(Boolean cleanup_config, Boolean cleanup_disks) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("cleanup-config", cleanup_config);
                            parameters.put("cleanup-disks", cleanup_disks);
                            return client.delete("/nodes/" + this.node + "/disks/lvm/" + this.name + "", parameters);
                        }

                        /**
                         * Remove an LVM Volume Group.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result delete() throws JSONException {
                            return client.delete("/nodes/" + this.node + "/disks/lvm/" + this.name + "", null);
                        }

                    }

                    /**
                     * List LVM Volume Groups
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/disks/lvm", null);
                    }

                    /**
                     * Create an LVM Volume Group
                     *
                     * @param device The block device you want to create the
                     * volume group on
                     * @param name The storage identifier.
                     * @param add_storage Configure storage using the Volume
                     * Group
                     * @return Result
                     * @throws JSONException
                     */

                    public Result create(String device, String name, Boolean add_storage) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("device", device);
                        parameters.put("name", name);
                        parameters.put("add_storage", add_storage);
                        return client.create("/nodes/" + this.node + "/disks/lvm", parameters);
                    }

                    /**
                     * Create an LVM Volume Group
                     *
                     * @param device The block device you want to create the
                     * volume group on
                     * @param name The storage identifier.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result create(String device, String name) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("device", device);
                        parameters.put("name", name);
                        return client.create("/nodes/" + this.node + "/disks/lvm", parameters);
                    }

                }

                public class PVELvmthin {

                    private final PveClient client;
                    private final Object node;

                    protected PVELvmthin(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVENameItem get(Object name) {
                        return new PVENameItem(client, this.node, name);
                    }

                    public class PVENameItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object name;

                        protected PVENameItem(PveClient client, Object node, Object name) {
                            this.client = client;
                            this.node = node;
                            this.name = name;
                        }

                        /**
                         * Remove an LVM thin pool.
                         *
                         * @param volume_group The storage identifier.
                         * @param cleanup_config Marks associated storage(s) as
                         * not available on this node anymore or removes them
                         * from the configuration (if configured for this node
                         * only).
                         * @param cleanup_disks Also wipe disks so they can be
                         * repurposed afterwards.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result delete(String volume_group, Boolean cleanup_config, Boolean cleanup_disks) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("volume-group", volume_group);
                            parameters.put("cleanup-config", cleanup_config);
                            parameters.put("cleanup-disks", cleanup_disks);
                            return client.delete("/nodes/" + this.node + "/disks/lvmthin/" + this.name + "", parameters);
                        }

                        /**
                         * Remove an LVM thin pool.
                         *
                         * @param volume_group The storage identifier.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result delete(String volume_group) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("volume-group", volume_group);
                            return client.delete("/nodes/" + this.node + "/disks/lvmthin/" + this.name + "", parameters);
                        }

                    }

                    /**
                     * List LVM thinpools
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/disks/lvmthin", null);
                    }

                    /**
                     * Create an LVM thinpool
                     *
                     * @param device The block device you want to create the
                     * thinpool on.
                     * @param name The storage identifier.
                     * @param add_storage Configure storage using the thinpool.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result create(String device, String name, Boolean add_storage) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("device", device);
                        parameters.put("name", name);
                        parameters.put("add_storage", add_storage);
                        return client.create("/nodes/" + this.node + "/disks/lvmthin", parameters);
                    }

                    /**
                     * Create an LVM thinpool
                     *
                     * @param device The block device you want to create the
                     * thinpool on.
                     * @param name The storage identifier.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result create(String device, String name) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("device", device);
                        parameters.put("name", name);
                        return client.create("/nodes/" + this.node + "/disks/lvmthin", parameters);
                    }

                }

                public class PVEDirectory {

                    private final PveClient client;
                    private final Object node;

                    protected PVEDirectory(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVENameItem get(Object name) {
                        return new PVENameItem(client, this.node, name);
                    }

                    public class PVENameItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object name;

                        protected PVENameItem(PveClient client, Object node, Object name) {
                            this.client = client;
                            this.node = node;
                            this.name = name;
                        }

                        /**
                         * Unmounts the storage and removes the mount unit.
                         *
                         * @param cleanup_config Marks associated storage(s) as
                         * not available on this node anymore or removes them
                         * from the configuration (if configured for this node
                         * only).
                         * @param cleanup_disks Also wipe disk so it can be
                         * repurposed afterwards.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result delete(Boolean cleanup_config, Boolean cleanup_disks) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("cleanup-config", cleanup_config);
                            parameters.put("cleanup-disks", cleanup_disks);
                            return client.delete("/nodes/" + this.node + "/disks/directory/" + this.name + "", parameters);
                        }

                        /**
                         * Unmounts the storage and removes the mount unit.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result delete() throws JSONException {
                            return client.delete("/nodes/" + this.node + "/disks/directory/" + this.name + "", null);
                        }

                    }

                    /**
                     * PVE Managed Directory storages.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/disks/directory", null);
                    }

                    /**
                     * Create a Filesystem on an unused disk. Will be mounted
                     * under '/mnt/pve/NAME'.
                     *
                     * @param device The block device you want to create the
                     * filesystem on.
                     * @param name The storage identifier.
                     * @param add_storage Configure storage using the directory.
                     * @param filesystem The desired filesystem. Enum: ext4,xfs
                     * @return Result
                     * @throws JSONException
                     */

                    public Result create(String device, String name, Boolean add_storage, String filesystem) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("device", device);
                        parameters.put("name", name);
                        parameters.put("add_storage", add_storage);
                        parameters.put("filesystem", filesystem);
                        return client.create("/nodes/" + this.node + "/disks/directory", parameters);
                    }

                    /**
                     * Create a Filesystem on an unused disk. Will be mounted
                     * under '/mnt/pve/NAME'.
                     *
                     * @param device The block device you want to create the
                     * filesystem on.
                     * @param name The storage identifier.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result create(String device, String name) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("device", device);
                        parameters.put("name", name);
                        return client.create("/nodes/" + this.node + "/disks/directory", parameters);
                    }

                }

                public class PVEZfs {

                    private final PveClient client;
                    private final Object node;

                    protected PVEZfs(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVENameItem get(Object name) {
                        return new PVENameItem(client, this.node, name);
                    }

                    public class PVENameItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object name;

                        protected PVENameItem(PveClient client, Object node, Object name) {
                            this.client = client;
                            this.node = node;
                            this.name = name;
                        }

                        /**
                         * Destroy a ZFS pool.
                         *
                         * @param cleanup_config Marks associated storage(s) as
                         * not available on this node anymore or removes them
                         * from the configuration (if configured for this node
                         * only).
                         * @param cleanup_disks Also wipe disks so they can be
                         * repurposed afterwards.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result delete(Boolean cleanup_config, Boolean cleanup_disks) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("cleanup-config", cleanup_config);
                            parameters.put("cleanup-disks", cleanup_disks);
                            return client.delete("/nodes/" + this.node + "/disks/zfs/" + this.name + "", parameters);
                        }

                        /**
                         * Destroy a ZFS pool.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result delete() throws JSONException {
                            return client.delete("/nodes/" + this.node + "/disks/zfs/" + this.name + "", null);
                        }

                        /**
                         * Get details about a zpool.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result detail() throws JSONException {
                            return client.get("/nodes/" + this.node + "/disks/zfs/" + this.name + "", null);
                        }

                    }

                    /**
                     * List Zpools.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/disks/zfs", null);
                    }

                    /**
                     * Create a ZFS pool.
                     *
                     * @param devices The block devices you want to create the
                     * zpool on.
                     * @param name The storage identifier.
                     * @param raidlevel The RAID level to use. Enum:
                     * single,mirror,raid10,raidz,raidz2,raidz3,draid,draid2,draid3
                     * @param add_storage Configure storage using the zpool.
                     * @param ashift Pool sector size exponent.
                     * @param compression The compression algorithm to use.
                     * Enum: on,off,gzip,lz4,lzjb,zle,zstd
                     * @param draid_config
                     * @return Result
                     * @throws JSONException
                     */

                    public Result create(String devices, String name, String raidlevel, Boolean add_storage, Integer ashift, String compression, String draid_config) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("devices", devices);
                        parameters.put("name", name);
                        parameters.put("raidlevel", raidlevel);
                        parameters.put("add_storage", add_storage);
                        parameters.put("ashift", ashift);
                        parameters.put("compression", compression);
                        parameters.put("draid-config", draid_config);
                        return client.create("/nodes/" + this.node + "/disks/zfs", parameters);
                    }

                    /**
                     * Create a ZFS pool.
                     *
                     * @param devices The block devices you want to create the
                     * zpool on.
                     * @param name The storage identifier.
                     * @param raidlevel The RAID level to use. Enum:
                     * single,mirror,raid10,raidz,raidz2,raidz3,draid,draid2,draid3
                     * @return Result
                     * @throws JSONException
                     */

                    public Result create(String devices, String name, String raidlevel) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("devices", devices);
                        parameters.put("name", name);
                        parameters.put("raidlevel", raidlevel);
                        return client.create("/nodes/" + this.node + "/disks/zfs", parameters);
                    }

                }

                public class PVEList {

                    private final PveClient client;
                    private final Object node;

                    protected PVEList(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * List local disks.
                     *
                     * @param include_partitions Also include partitions.
                     * @param skipsmart Skip smart checks.
                     * @param type Only list specific types of disks. Enum:
                     * unused,journal_disks
                     * @return Result
                     * @throws JSONException
                     */
                    public Result list(Boolean include_partitions, Boolean skipsmart, String type) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("include-partitions", include_partitions);
                        parameters.put("skipsmart", skipsmart);
                        parameters.put("type", type);
                        return client.get("/nodes/" + this.node + "/disks/list", parameters);
                    }

                    /**
                     * List local disks.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result list() throws JSONException {
                        return client.get("/nodes/" + this.node + "/disks/list", null);
                    }

                }

                public class PVESmart {

                    private final PveClient client;
                    private final Object node;

                    protected PVESmart(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Get SMART Health of a disk.
                     *
                     * @param disk Block device name
                     * @param healthonly If true returns only the health status
                     * @return Result
                     * @throws JSONException
                     */
                    public Result smart(String disk, Boolean healthonly) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("disk", disk);
                        parameters.put("healthonly", healthonly);
                        return client.get("/nodes/" + this.node + "/disks/smart", parameters);
                    }

                    /**
                     * Get SMART Health of a disk.
                     *
                     * @param disk Block device name
                     * @return Result
                     * @throws JSONException
                     */

                    public Result smart(String disk) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("disk", disk);
                        return client.get("/nodes/" + this.node + "/disks/smart", parameters);
                    }

                }

                public class PVEInitgpt {

                    private final PveClient client;
                    private final Object node;

                    protected PVEInitgpt(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Initialize Disk with GPT
                     *
                     * @param disk Block device name
                     * @param uuid UUID for the GPT table
                     * @return Result
                     * @throws JSONException
                     */
                    public Result initgpt(String disk, String uuid) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("disk", disk);
                        parameters.put("uuid", uuid);
                        return client.create("/nodes/" + this.node + "/disks/initgpt", parameters);
                    }

                    /**
                     * Initialize Disk with GPT
                     *
                     * @param disk Block device name
                     * @return Result
                     * @throws JSONException
                     */

                    public Result initgpt(String disk) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("disk", disk);
                        return client.create("/nodes/" + this.node + "/disks/initgpt", parameters);
                    }

                }

                public class PVEWipedisk {

                    private final PveClient client;
                    private final Object node;

                    protected PVEWipedisk(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Wipe a disk or partition.
                     *
                     * @param disk Block device name
                     * @return Result
                     * @throws JSONException
                     */
                    public Result wipeDisk(String disk) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("disk", disk);
                        return client.set("/nodes/" + this.node + "/disks/wipedisk", parameters);
                    }

                }

                /**
                 * Node index.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result index() throws JSONException {
                    return client.get("/nodes/" + this.node + "/disks", null);
                }

            }

            public class PVEApt {

                private final PveClient client;
                private final Object node;

                protected PVEApt(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                private PVEUpdate update;

                public PVEUpdate getUpdate() {
                    return update == null ? (update = new PVEUpdate(client, this.node)) : update;
                }
                private PVEChangelog changelog;

                public PVEChangelog getChangelog() {
                    return changelog == null ? (changelog = new PVEChangelog(client, this.node)) : changelog;
                }
                private PVERepositories repositories;

                public PVERepositories getRepositories() {
                    return repositories == null ? (repositories = new PVERepositories(client, this.node)) : repositories;
                }
                private PVEVersions versions;

                public PVEVersions getVersions() {
                    return versions == null ? (versions = new PVEVersions(client, this.node)) : versions;
                }

                public class PVEUpdate {

                    private final PveClient client;
                    private final Object node;

                    protected PVEUpdate(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * List available updates.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result listUpdates() throws JSONException {
                        return client.get("/nodes/" + this.node + "/apt/update", null);
                    }

                    /**
                     * This is used to resynchronize the package index files
                     * from their sources (apt-get update).
                     *
                     * @param notify Send notification about new packages.
                     * @param quiet Only produces output suitable for logging,
                     * omitting progress indicators.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateDatabase(Boolean notify, Boolean quiet) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("notify", notify);
                        parameters.put("quiet", quiet);
                        return client.create("/nodes/" + this.node + "/apt/update", parameters);
                    }

                    /**
                     * This is used to resynchronize the package index files
                     * from their sources (apt-get update).
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateDatabase() throws JSONException {
                        return client.create("/nodes/" + this.node + "/apt/update", null);
                    }

                }

                public class PVEChangelog {

                    private final PveClient client;
                    private final Object node;

                    protected PVEChangelog(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Get package changelogs.
                     *
                     * @param name Package name.
                     * @param version Package version.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result changelog(String name, String version) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("name", name);
                        parameters.put("version", version);
                        return client.get("/nodes/" + this.node + "/apt/changelog", parameters);
                    }

                    /**
                     * Get package changelogs.
                     *
                     * @param name Package name.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result changelog(String name) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("name", name);
                        return client.get("/nodes/" + this.node + "/apt/changelog", parameters);
                    }

                }

                public class PVERepositories {

                    private final PveClient client;
                    private final Object node;

                    protected PVERepositories(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Get APT repository information.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result repositories() throws JSONException {
                        return client.get("/nodes/" + this.node + "/apt/repositories", null);
                    }

                    /**
                     * Change the properties of a repository. Currently only
                     * allows enabling/disabling.
                     *
                     * @param index Index within the file (starting from 0).
                     * @param path Path to the containing file.
                     * @param digest Digest to detect modifications.
                     * @param enabled Whether the repository should be enabled
                     * or not.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result changeRepository(int index, String path, String digest, Boolean enabled) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("index", index);
                        parameters.put("path", path);
                        parameters.put("digest", digest);
                        parameters.put("enabled", enabled);
                        return client.create("/nodes/" + this.node + "/apt/repositories", parameters);
                    }

                    /**
                     * Change the properties of a repository. Currently only
                     * allows enabling/disabling.
                     *
                     * @param index Index within the file (starting from 0).
                     * @param path Path to the containing file.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result changeRepository(int index, String path) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("index", index);
                        parameters.put("path", path);
                        return client.create("/nodes/" + this.node + "/apt/repositories", parameters);
                    }

                    /**
                     * Add a standard repository to the configuration
                     *
                     * @param handle Handle that identifies a repository.
                     * @param digest Digest to detect modifications.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result addRepository(String handle, String digest) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("handle", handle);
                        parameters.put("digest", digest);
                        return client.set("/nodes/" + this.node + "/apt/repositories", parameters);
                    }

                    /**
                     * Add a standard repository to the configuration
                     *
                     * @param handle Handle that identifies a repository.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result addRepository(String handle) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("handle", handle);
                        return client.set("/nodes/" + this.node + "/apt/repositories", parameters);
                    }

                }

                public class PVEVersions {

                    private final PveClient client;
                    private final Object node;

                    protected PVEVersions(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Get package information for important Proxmox packages.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result versions() throws JSONException {
                        return client.get("/nodes/" + this.node + "/apt/versions", null);
                    }

                }

                /**
                 * Directory index for apt (Advanced Package Tool).
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result index() throws JSONException {
                    return client.get("/nodes/" + this.node + "/apt", null);
                }

            }

            public class PVEFirewall {

                private final PveClient client;
                private final Object node;

                protected PVEFirewall(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                private PVERules rules;

                public PVERules getRules() {
                    return rules == null ? (rules = new PVERules(client, this.node)) : rules;
                }
                private PVEOptions options;

                public PVEOptions getOptions() {
                    return options == null ? (options = new PVEOptions(client, this.node)) : options;
                }
                private PVELog log;

                public PVELog getLog() {
                    return log == null ? (log = new PVELog(client, this.node)) : log;
                }

                public class PVERules {

                    private final PveClient client;
                    private final Object node;

                    protected PVERules(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVEPosItem get(Object pos) {
                        return new PVEPosItem(client, this.node, pos);
                    }

                    public class PVEPosItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object pos;

                        protected PVEPosItem(PveClient client, Object node, Object pos) {
                            this.client = client;
                            this.node = node;
                            this.pos = pos;
                        }

                        /**
                         * Delete rule.
                         *
                         * @param digest Prevent changes if current
                         * configuration file has a different digest. This can
                         * be used to prevent concurrent modifications.
                         * @return Result
                         * @throws JSONException
                         */
                        public Result deleteRule(String digest) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("digest", digest);
                            return client.delete("/nodes/" + this.node + "/firewall/rules/" + this.pos + "", parameters);
                        }

                        /**
                         * Delete rule.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result deleteRule() throws JSONException {
                            return client.delete("/nodes/" + this.node + "/firewall/rules/" + this.pos + "", null);
                        }

                        /**
                         * Get single rule data.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result getRule() throws JSONException {
                            return client.get("/nodes/" + this.node + "/firewall/rules/" + this.pos + "", null);
                        }

                        /**
                         * Modify rule data.
                         *
                         * @param action Rule action ('ACCEPT', 'DROP',
                         * 'REJECT') or security group name.
                         * @param comment Descriptive comment.
                         * @param delete A list of settings you want to delete.
                         * @param dest Restrict packet destination address. This
                         * can refer to a single IP address, an IP set
                         * ('+ipsetname') or an IP alias definition. You can
                         * also specify an address range like
                         * '20.34.101.207-201.3.9.99', or a list of IP addresses
                         * and networks (entries are separated by comma). Please
                         * do not mix IPv4 and IPv6 addresses inside such lists.
                         * @param digest Prevent changes if current
                         * configuration file has a different digest. This can
                         * be used to prevent concurrent modifications.
                         * @param dport Restrict TCP/UDP destination port. You
                         * can use service names or simple numbers (0-65535), as
                         * defined in '/etc/services'. Port ranges can be
                         * specified with '\d+:\d+', for example '80:85', and
                         * you can use comma separated list to match several
                         * ports or ranges.
                         * @param enable Flag to enable/disable a rule.
                         * @param icmp_type Specify icmp-type. Only valid if
                         * proto equals 'icmp' or 'icmpv6'/'ipv6-icmp'.
                         * @param iface Network interface name. You have to use
                         * network configuration key names for VMs and
                         * containers ('net\d+'). Host related rules can use
                         * arbitrary strings.
                         * @param log Log level for firewall rule. Enum:
                         * emerg,alert,crit,err,warning,notice,info,debug,nolog
                         * @param macro Use predefined standard macro.
                         * @param moveto Move rule to new position
                         * &amp;lt;moveto&amp;gt;. Other arguments are ignored.
                         * @param proto IP protocol. You can use protocol names
                         * ('tcp'/'udp') or simple numbers, as defined in
                         * '/etc/protocols'.
                         * @param source Restrict packet source address. This
                         * can refer to a single IP address, an IP set
                         * ('+ipsetname') or an IP alias definition. You can
                         * also specify an address range like
                         * '20.34.101.207-201.3.9.99', or a list of IP addresses
                         * and networks (entries are separated by comma). Please
                         * do not mix IPv4 and IPv6 addresses inside such lists.
                         * @param sport Restrict TCP/UDP source port. You can
                         * use service names or simple numbers (0-65535), as
                         * defined in '/etc/services'. Port ranges can be
                         * specified with '\d+:\d+', for example '80:85', and
                         * you can use comma separated list to match several
                         * ports or ranges.
                         * @param type Rule type. Enum: in,out,group
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateRule(String action, String comment, String delete, String dest, String digest, String dport, Integer enable, String icmp_type, String iface, String log, String macro, Integer moveto, String proto, String source, String sport, String type) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("action", action);
                            parameters.put("comment", comment);
                            parameters.put("delete", delete);
                            parameters.put("dest", dest);
                            parameters.put("digest", digest);
                            parameters.put("dport", dport);
                            parameters.put("enable", enable);
                            parameters.put("icmp-type", icmp_type);
                            parameters.put("iface", iface);
                            parameters.put("log", log);
                            parameters.put("macro", macro);
                            parameters.put("moveto", moveto);
                            parameters.put("proto", proto);
                            parameters.put("source", source);
                            parameters.put("sport", sport);
                            parameters.put("type", type);
                            return client.set("/nodes/" + this.node + "/firewall/rules/" + this.pos + "", parameters);
                        }

                        /**
                         * Modify rule data.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateRule() throws JSONException {
                            return client.set("/nodes/" + this.node + "/firewall/rules/" + this.pos + "", null);
                        }

                    }

                    /**
                     * List rules.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result getRules() throws JSONException {
                        return client.get("/nodes/" + this.node + "/firewall/rules", null);
                    }

                    /**
                     * Create new rule.
                     *
                     * @param action Rule action ('ACCEPT', 'DROP', 'REJECT') or
                     * security group name.
                     * @param type Rule type. Enum: in,out,group
                     * @param comment Descriptive comment.
                     * @param dest Restrict packet destination address. This can
                     * refer to a single IP address, an IP set ('+ipsetname') or
                     * an IP alias definition. You can also specify an address
                     * range like '20.34.101.207-201.3.9.99', or a list of IP
                     * addresses and networks (entries are separated by comma).
                     * Please do not mix IPv4 and IPv6 addresses inside such
                     * lists.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param dport Restrict TCP/UDP destination port. You can
                     * use service names or simple numbers (0-65535), as defined
                     * in '/etc/services'. Port ranges can be specified with
                     * '\d+:\d+', for example '80:85', and you can use comma
                     * separated list to match several ports or ranges.
                     * @param enable Flag to enable/disable a rule.
                     * @param icmp_type Specify icmp-type. Only valid if proto
                     * equals 'icmp' or 'icmpv6'/'ipv6-icmp'.
                     * @param iface Network interface name. You have to use
                     * network configuration key names for VMs and containers
                     * ('net\d+'). Host related rules can use arbitrary strings.
                     * @param log Log level for firewall rule. Enum:
                     * emerg,alert,crit,err,warning,notice,info,debug,nolog
                     * @param macro Use predefined standard macro.
                     * @param pos Update rule at position &amp;lt;pos&amp;gt;.
                     * @param proto IP protocol. You can use protocol names
                     * ('tcp'/'udp') or simple numbers, as defined in
                     * '/etc/protocols'.
                     * @param source Restrict packet source address. This can
                     * refer to a single IP address, an IP set ('+ipsetname') or
                     * an IP alias definition. You can also specify an address
                     * range like '20.34.101.207-201.3.9.99', or a list of IP
                     * addresses and networks (entries are separated by comma).
                     * Please do not mix IPv4 and IPv6 addresses inside such
                     * lists.
                     * @param sport Restrict TCP/UDP source port. You can use
                     * service names or simple numbers (0-65535), as defined in
                     * '/etc/services'. Port ranges can be specified with
                     * '\d+:\d+', for example '80:85', and you can use comma
                     * separated list to match several ports or ranges.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createRule(String action, String type, String comment, String dest, String digest, String dport, Integer enable, String icmp_type, String iface, String log, String macro, Integer pos, String proto, String source, String sport) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("action", action);
                        parameters.put("type", type);
                        parameters.put("comment", comment);
                        parameters.put("dest", dest);
                        parameters.put("digest", digest);
                        parameters.put("dport", dport);
                        parameters.put("enable", enable);
                        parameters.put("icmp-type", icmp_type);
                        parameters.put("iface", iface);
                        parameters.put("log", log);
                        parameters.put("macro", macro);
                        parameters.put("pos", pos);
                        parameters.put("proto", proto);
                        parameters.put("source", source);
                        parameters.put("sport", sport);
                        return client.create("/nodes/" + this.node + "/firewall/rules", parameters);
                    }

                    /**
                     * Create new rule.
                     *
                     * @param action Rule action ('ACCEPT', 'DROP', 'REJECT') or
                     * security group name.
                     * @param type Rule type. Enum: in,out,group
                     * @return Result
                     * @throws JSONException
                     */

                    public Result createRule(String action, String type) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("action", action);
                        parameters.put("type", type);
                        return client.create("/nodes/" + this.node + "/firewall/rules", parameters);
                    }

                }

                public class PVEOptions {

                    private final PveClient client;
                    private final Object node;

                    protected PVEOptions(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Get host firewall options.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result getOptions() throws JSONException {
                        return client.get("/nodes/" + this.node + "/firewall/options", null);
                    }

                    /**
                     * Set Firewall options.
                     *
                     * @param delete A list of settings you want to delete.
                     * @param digest Prevent changes if current configuration
                     * file has a different digest. This can be used to prevent
                     * concurrent modifications.
                     * @param enable Enable host firewall rules.
                     * @param log_level_in Log level for incoming traffic. Enum:
                     * emerg,alert,crit,err,warning,notice,info,debug,nolog
                     * @param log_level_out Log level for outgoing traffic.
                     * Enum:
                     * emerg,alert,crit,err,warning,notice,info,debug,nolog
                     * @param log_nf_conntrack Enable logging of conntrack
                     * information.
                     * @param ndp Enable NDP (Neighbor Discovery Protocol).
                     * @param nf_conntrack_allow_invalid Allow invalid packets
                     * on connection tracking.
                     * @param nf_conntrack_helpers Enable conntrack helpers for
                     * specific protocols. Supported protocols: amanda, ftp,
                     * irc, netbios-ns, pptp, sane, sip, snmp, tftp
                     * @param nf_conntrack_max Maximum number of tracked
                     * connections.
                     * @param nf_conntrack_tcp_timeout_established Conntrack
                     * established timeout.
                     * @param nf_conntrack_tcp_timeout_syn_recv Conntrack syn
                     * recv timeout.
                     * @param nosmurfs Enable SMURFS filter.
                     * @param protection_synflood Enable synflood protection
                     * @param protection_synflood_burst Synflood protection rate
                     * burst by ip src.
                     * @param protection_synflood_rate Synflood protection rate
                     * syn/sec by ip src.
                     * @param smurf_log_level Log level for SMURFS filter. Enum:
                     * emerg,alert,crit,err,warning,notice,info,debug,nolog
                     * @param tcp_flags_log_level Log level for illegal tcp
                     * flags filter. Enum:
                     * emerg,alert,crit,err,warning,notice,info,debug,nolog
                     * @param tcpflags Filter illegal combinations of TCP flags.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result setOptions(String delete, String digest, Boolean enable, String log_level_in, String log_level_out, Boolean log_nf_conntrack, Boolean ndp, Boolean nf_conntrack_allow_invalid, String nf_conntrack_helpers, Integer nf_conntrack_max, Integer nf_conntrack_tcp_timeout_established, Integer nf_conntrack_tcp_timeout_syn_recv, Boolean nosmurfs, Boolean protection_synflood, Integer protection_synflood_burst, Integer protection_synflood_rate, String smurf_log_level, String tcp_flags_log_level, Boolean tcpflags) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("delete", delete);
                        parameters.put("digest", digest);
                        parameters.put("enable", enable);
                        parameters.put("log_level_in", log_level_in);
                        parameters.put("log_level_out", log_level_out);
                        parameters.put("log_nf_conntrack", log_nf_conntrack);
                        parameters.put("ndp", ndp);
                        parameters.put("nf_conntrack_allow_invalid", nf_conntrack_allow_invalid);
                        parameters.put("nf_conntrack_helpers", nf_conntrack_helpers);
                        parameters.put("nf_conntrack_max", nf_conntrack_max);
                        parameters.put("nf_conntrack_tcp_timeout_established", nf_conntrack_tcp_timeout_established);
                        parameters.put("nf_conntrack_tcp_timeout_syn_recv", nf_conntrack_tcp_timeout_syn_recv);
                        parameters.put("nosmurfs", nosmurfs);
                        parameters.put("protection_synflood", protection_synflood);
                        parameters.put("protection_synflood_burst", protection_synflood_burst);
                        parameters.put("protection_synflood_rate", protection_synflood_rate);
                        parameters.put("smurf_log_level", smurf_log_level);
                        parameters.put("tcp_flags_log_level", tcp_flags_log_level);
                        parameters.put("tcpflags", tcpflags);
                        return client.set("/nodes/" + this.node + "/firewall/options", parameters);
                    }

                    /**
                     * Set Firewall options.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result setOptions() throws JSONException {
                        return client.set("/nodes/" + this.node + "/firewall/options", null);
                    }

                }

                public class PVELog {

                    private final PveClient client;
                    private final Object node;

                    protected PVELog(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Read firewall log
                     *
                     * @param limit
                     * @param since Display log since this UNIX epoch.
                     * @param start
                     * @param until Display log until this UNIX epoch.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result log(Integer limit, Integer since, Integer start, Integer until) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("limit", limit);
                        parameters.put("since", since);
                        parameters.put("start", start);
                        parameters.put("until", until);
                        return client.get("/nodes/" + this.node + "/firewall/log", parameters);
                    }

                    /**
                     * Read firewall log
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result log() throws JSONException {
                        return client.get("/nodes/" + this.node + "/firewall/log", null);
                    }

                }

                /**
                 * Directory index.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result index() throws JSONException {
                    return client.get("/nodes/" + this.node + "/firewall", null);
                }

            }

            public class PVEReplication {

                private final PveClient client;
                private final Object node;

                protected PVEReplication(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                public PVEIdItem get(Object id) {
                    return new PVEIdItem(client, this.node, id);
                }

                public class PVEIdItem {

                    private final PveClient client;
                    private final Object node;
                    private final Object id;

                    protected PVEIdItem(PveClient client, Object node, Object id) {
                        this.client = client;
                        this.node = node;
                        this.id = id;
                    }

                    private PVEStatus status;

                    public PVEStatus getStatus() {
                        return status == null ? (status = new PVEStatus(client, this.node, this.id)) : status;
                    }
                    private PVELog log;

                    public PVELog getLog() {
                        return log == null ? (log = new PVELog(client, this.node, this.id)) : log;
                    }
                    private PVEScheduleNow scheduleNow;

                    public PVEScheduleNow getScheduleNow() {
                        return scheduleNow == null ? (scheduleNow = new PVEScheduleNow(client, this.node, this.id)) : scheduleNow;
                    }

                    public class PVEStatus {

                        private final PveClient client;
                        private final Object node;
                        private final Object id;

                        protected PVEStatus(PveClient client, Object node, Object id) {
                            this.client = client;
                            this.node = node;
                            this.id = id;
                        }

                        /**
                         * Get replication job status.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result jobStatus() throws JSONException {
                            return client.get("/nodes/" + this.node + "/replication/" + this.id + "/status", null);
                        }

                    }

                    public class PVELog {

                        private final PveClient client;
                        private final Object node;
                        private final Object id;

                        protected PVELog(PveClient client, Object node, Object id) {
                            this.client = client;
                            this.node = node;
                            this.id = id;
                        }

                        /**
                         * Read replication job log.
                         *
                         * @param limit
                         * @param start
                         * @return Result
                         * @throws JSONException
                         */
                        public Result readJobLog(Integer limit, Integer start) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("limit", limit);
                            parameters.put("start", start);
                            return client.get("/nodes/" + this.node + "/replication/" + this.id + "/log", parameters);
                        }

                        /**
                         * Read replication job log.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result readJobLog() throws JSONException {
                            return client.get("/nodes/" + this.node + "/replication/" + this.id + "/log", null);
                        }

                    }

                    public class PVEScheduleNow {

                        private final PveClient client;
                        private final Object node;
                        private final Object id;

                        protected PVEScheduleNow(PveClient client, Object node, Object id) {
                            this.client = client;
                            this.node = node;
                            this.id = id;
                        }

                        /**
                         * Schedule replication job to start as soon as
                         * possible.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result scheduleNow() throws JSONException {
                            return client.create("/nodes/" + this.node + "/replication/" + this.id + "/schedule_now", null);
                        }

                    }

                    /**
                     * Directory index.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/replication/" + this.id + "", null);
                    }

                }

                /**
                 * List status of all replication jobs on this node.
                 *
                 * @param guest Only list replication jobs for this guest.
                 * @return Result
                 * @throws JSONException
                 */
                public Result status(Integer guest) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("guest", guest);
                    return client.get("/nodes/" + this.node + "/replication", parameters);
                }

                /**
                 * List status of all replication jobs on this node.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result status() throws JSONException {
                    return client.get("/nodes/" + this.node + "/replication", null);
                }

            }

            public class PVECertificates {

                private final PveClient client;
                private final Object node;

                protected PVECertificates(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                private PVEAcme acme;

                public PVEAcme getAcme() {
                    return acme == null ? (acme = new PVEAcme(client, this.node)) : acme;
                }
                private PVEInfo info;

                public PVEInfo getInfo() {
                    return info == null ? (info = new PVEInfo(client, this.node)) : info;
                }
                private PVECustom custom;

                public PVECustom getCustom() {
                    return custom == null ? (custom = new PVECustom(client, this.node)) : custom;
                }

                public class PVEAcme {

                    private final PveClient client;
                    private final Object node;

                    protected PVEAcme(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    private PVECertificate certificate;

                    public PVECertificate getCertificate() {
                        return certificate == null ? (certificate = new PVECertificate(client, this.node)) : certificate;
                    }

                    public class PVECertificate {

                        private final PveClient client;
                        private final Object node;

                        protected PVECertificate(PveClient client, Object node) {
                            this.client = client;
                            this.node = node;
                        }

                        /**
                         * Revoke existing certificate from CA.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result revokeCertificate() throws JSONException {
                            return client.delete("/nodes/" + this.node + "/certificates/acme/certificate", null);
                        }

                        /**
                         * Order a new certificate from ACME-compatible CA.
                         *
                         * @param force Overwrite existing custom certificate.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result newCertificate(Boolean force) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("force", force);
                            return client.create("/nodes/" + this.node + "/certificates/acme/certificate", parameters);
                        }

                        /**
                         * Order a new certificate from ACME-compatible CA.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result newCertificate() throws JSONException {
                            return client.create("/nodes/" + this.node + "/certificates/acme/certificate", null);
                        }

                        /**
                         * Renew existing certificate from CA.
                         *
                         * @param force Force renewal even if expiry is more
                         * than 30 days away.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result renewCertificate(Boolean force) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("force", force);
                            return client.set("/nodes/" + this.node + "/certificates/acme/certificate", parameters);
                        }

                        /**
                         * Renew existing certificate from CA.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result renewCertificate() throws JSONException {
                            return client.set("/nodes/" + this.node + "/certificates/acme/certificate", null);
                        }

                    }

                    /**
                     * ACME index.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/certificates/acme", null);
                    }

                }

                public class PVEInfo {

                    private final PveClient client;
                    private final Object node;

                    protected PVEInfo(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * Get information about node's certificates.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result info() throws JSONException {
                        return client.get("/nodes/" + this.node + "/certificates/info", null);
                    }

                }

                public class PVECustom {

                    private final PveClient client;
                    private final Object node;

                    protected PVECustom(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    /**
                     * DELETE custom certificate chain and key.
                     *
                     * @param restart Restart pveproxy.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result removeCustomCert(Boolean restart) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("restart", restart);
                        return client.delete("/nodes/" + this.node + "/certificates/custom", parameters);
                    }

                    /**
                     * DELETE custom certificate chain and key.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result removeCustomCert() throws JSONException {
                        return client.delete("/nodes/" + this.node + "/certificates/custom", null);
                    }

                    /**
                     * Upload or update custom certificate chain and key.
                     *
                     * @param certificates PEM encoded certificate (chain).
                     * @param force Overwrite existing custom or ACME
                     * certificate files.
                     * @param key PEM encoded private key.
                     * @param restart Restart pveproxy.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result uploadCustomCert(String certificates, Boolean force, String key, Boolean restart) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("certificates", certificates);
                        parameters.put("force", force);
                        parameters.put("key", key);
                        parameters.put("restart", restart);
                        return client.create("/nodes/" + this.node + "/certificates/custom", parameters);
                    }

                    /**
                     * Upload or update custom certificate chain and key.
                     *
                     * @param certificates PEM encoded certificate (chain).
                     * @return Result
                     * @throws JSONException
                     */

                    public Result uploadCustomCert(String certificates) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("certificates", certificates);
                        return client.create("/nodes/" + this.node + "/certificates/custom", parameters);
                    }

                }

                /**
                 * Node index.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result index() throws JSONException {
                    return client.get("/nodes/" + this.node + "/certificates", null);
                }

            }

            public class PVEConfig {

                private final PveClient client;
                private final Object node;

                protected PVEConfig(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Get node configuration options.
                 *
                 * @param property Return only a specific property from the node
                 * configuration. Enum:
                 * acme,acmedomain0,acmedomain1,acmedomain2,acmedomain3,acmedomain4,acmedomain5,description,startall-onboot-delay,wakeonlan
                 * @return Result
                 * @throws JSONException
                 */
                public Result getConfig(String property) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("property", property);
                    return client.get("/nodes/" + this.node + "/config", parameters);
                }

                /**
                 * Get node configuration options.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result getConfig() throws JSONException {
                    return client.get("/nodes/" + this.node + "/config", null);
                }

                /**
                 * Set node configuration options.
                 *
                 * @param acme Node specific ACME settings.
                 * @param acmedomainN ACME domain and validation plugin
                 * @param delete A list of settings you want to delete.
                 * @param description Description for the Node. Shown in the
                 * web-interface node notes panel. This is saved as comment
                 * inside the configuration file.
                 * @param digest Prevent changes if current configuration file
                 * has different SHA1 digest. This can be used to prevent
                 * concurrent modifications.
                 * @param startall_onboot_delay Initial delay in seconds, before
                 * starting all the Virtual Guests with on-boot enabled.
                 * @param wakeonlan MAC address for wake on LAN
                 * @return Result
                 * @throws JSONException
                 */

                public Result setOptions(String acme, Map<Integer, String> acmedomainN, String delete, String description, String digest, Integer startall_onboot_delay, String wakeonlan) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("acme", acme);
                    parameters.put("delete", delete);
                    parameters.put("description", description);
                    parameters.put("digest", digest);
                    parameters.put("startall-onboot-delay", startall_onboot_delay);
                    parameters.put("wakeonlan", wakeonlan);
                    addIndexedParameter(parameters, "acmedomain", acmedomainN);
                    return client.set("/nodes/" + this.node + "/config", parameters);
                }

                /**
                 * Set node configuration options.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result setOptions() throws JSONException {
                    return client.set("/nodes/" + this.node + "/config", null);
                }

            }

            public class PVESdn {

                private final PveClient client;
                private final Object node;

                protected PVESdn(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                private PVEZones zones;

                public PVEZones getZones() {
                    return zones == null ? (zones = new PVEZones(client, this.node)) : zones;
                }

                public class PVEZones {

                    private final PveClient client;
                    private final Object node;

                    protected PVEZones(PveClient client, Object node) {
                        this.client = client;
                        this.node = node;
                    }

                    public PVEZoneItem get(Object zone) {
                        return new PVEZoneItem(client, this.node, zone);
                    }

                    public class PVEZoneItem {

                        private final PveClient client;
                        private final Object node;
                        private final Object zone;

                        protected PVEZoneItem(PveClient client, Object node, Object zone) {
                            this.client = client;
                            this.node = node;
                            this.zone = zone;
                        }

                        private PVEContent content;

                        public PVEContent getContent() {
                            return content == null ? (content = new PVEContent(client, this.node, this.zone)) : content;
                        }

                        public class PVEContent {

                            private final PveClient client;
                            private final Object node;
                            private final Object zone;

                            protected PVEContent(PveClient client, Object node, Object zone) {
                                this.client = client;
                                this.node = node;
                                this.zone = zone;
                            }

                            /**
                             * List zone content.
                             *
                             * @return Result
                             * @throws JSONException
                             */
                            public Result index() throws JSONException {
                                return client.get("/nodes/" + this.node + "/sdn/zones/" + this.zone + "/content", null);
                            }

                        }

                        /**
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result diridx() throws JSONException {
                            return client.get("/nodes/" + this.node + "/sdn/zones/" + this.zone + "", null);
                        }

                    }

                    /**
                     * Get status for all zones.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result index() throws JSONException {
                        return client.get("/nodes/" + this.node + "/sdn/zones", null);
                    }

                }

                /**
                 * SDN index.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result sdnindex() throws JSONException {
                    return client.get("/nodes/" + this.node + "/sdn", null);
                }

            }

            public class PVEVersion {

                private final PveClient client;
                private final Object node;

                protected PVEVersion(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * API version details
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result version() throws JSONException {
                    return client.get("/nodes/" + this.node + "/version", null);
                }

            }

            public class PVEStatus {

                private final PveClient client;
                private final Object node;

                protected PVEStatus(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Read node status
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result status() throws JSONException {
                    return client.get("/nodes/" + this.node + "/status", null);
                }

                /**
                 * Reboot or shutdown a node.
                 *
                 * @param command Specify the command. Enum: reboot,shutdown
                 * @return Result
                 * @throws JSONException
                 */

                public Result nodeCmd(String command) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("command", command);
                    return client.create("/nodes/" + this.node + "/status", parameters);
                }

            }

            public class PVENetstat {

                private final PveClient client;
                private final Object node;

                protected PVENetstat(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Read tap/vm network device interface counters
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result netstat() throws JSONException {
                    return client.get("/nodes/" + this.node + "/netstat", null);
                }

            }

            public class PVEExecute {

                private final PveClient client;
                private final Object node;

                protected PVEExecute(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Execute multiple commands in order, root only.
                 *
                 * @param commands JSON encoded array of commands.
                 * @return Result
                 * @throws JSONException
                 */
                public Result execute(String commands) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("commands", commands);
                    return client.create("/nodes/" + this.node + "/execute", parameters);
                }

            }

            public class PVEWakeonlan {

                private final PveClient client;
                private final Object node;

                protected PVEWakeonlan(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Try to wake a node via 'wake on LAN' network packet.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result wakeonlan() throws JSONException {
                    return client.create("/nodes/" + this.node + "/wakeonlan", null);
                }

            }

            public class PVERrd {

                private final PveClient client;
                private final Object node;

                protected PVERrd(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Read node RRD statistics (returns PNG)
                 *
                 * @param ds The list of datasources you want to display.
                 * @param timeframe Specify the time frame you are interested
                 * in. Enum: hour,day,week,month,year
                 * @param cf The RRD consolidation function Enum: AVERAGE,MAX
                 * @return Result
                 * @throws JSONException
                 */
                public Result rrd(String ds, String timeframe, String cf) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("ds", ds);
                    parameters.put("timeframe", timeframe);
                    parameters.put("cf", cf);
                    return client.get("/nodes/" + this.node + "/rrd", parameters);
                }

                /**
                 * Read node RRD statistics (returns PNG)
                 *
                 * @param ds The list of datasources you want to display.
                 * @param timeframe Specify the time frame you are interested
                 * in. Enum: hour,day,week,month,year
                 * @return Result
                 * @throws JSONException
                 */

                public Result rrd(String ds, String timeframe) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("ds", ds);
                    parameters.put("timeframe", timeframe);
                    return client.get("/nodes/" + this.node + "/rrd", parameters);
                }

            }

            public class PVERrddata {

                private final PveClient client;
                private final Object node;

                protected PVERrddata(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Read node RRD statistics
                 *
                 * @param timeframe Specify the time frame you are interested
                 * in. Enum: hour,day,week,month,year
                 * @param cf The RRD consolidation function Enum: AVERAGE,MAX
                 * @return Result
                 * @throws JSONException
                 */
                public Result rrddata(String timeframe, String cf) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("timeframe", timeframe);
                    parameters.put("cf", cf);
                    return client.get("/nodes/" + this.node + "/rrddata", parameters);
                }

                /**
                 * Read node RRD statistics
                 *
                 * @param timeframe Specify the time frame you are interested
                 * in. Enum: hour,day,week,month,year
                 * @return Result
                 * @throws JSONException
                 */

                public Result rrddata(String timeframe) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("timeframe", timeframe);
                    return client.get("/nodes/" + this.node + "/rrddata", parameters);
                }

            }

            public class PVESyslog {

                private final PveClient client;
                private final Object node;

                protected PVESyslog(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Read system log
                 *
                 * @param limit
                 * @param service Service ID
                 * @param since Display all log since this date-time string.
                 * @param start
                 * @param until Display all log until this date-time string.
                 * @return Result
                 * @throws JSONException
                 */
                public Result syslog(Integer limit, String service, String since, Integer start, String until) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("limit", limit);
                    parameters.put("service", service);
                    parameters.put("since", since);
                    parameters.put("start", start);
                    parameters.put("until", until);
                    return client.get("/nodes/" + this.node + "/syslog", parameters);
                }

                /**
                 * Read system log
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result syslog() throws JSONException {
                    return client.get("/nodes/" + this.node + "/syslog", null);
                }

            }

            public class PVEJournal {

                private final PveClient client;
                private final Object node;

                protected PVEJournal(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Read Journal
                 *
                 * @param endcursor End before the given Cursor. Conflicts with
                 * 'until'
                 * @param lastentries Limit to the last X lines. Conflicts with
                 * a range.
                 * @param since Display all log since this UNIX epoch. Conflicts
                 * with 'startcursor'.
                 * @param startcursor Start after the given Cursor. Conflicts
                 * with 'since'
                 * @param until Display all log until this UNIX epoch. Conflicts
                 * with 'endcursor'.
                 * @return Result
                 * @throws JSONException
                 */
                public Result journal(String endcursor, Integer lastentries, Integer since, String startcursor, Integer until) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("endcursor", endcursor);
                    parameters.put("lastentries", lastentries);
                    parameters.put("since", since);
                    parameters.put("startcursor", startcursor);
                    parameters.put("until", until);
                    return client.get("/nodes/" + this.node + "/journal", parameters);
                }

                /**
                 * Read Journal
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result journal() throws JSONException {
                    return client.get("/nodes/" + this.node + "/journal", null);
                }

            }

            public class PVEVncshell {

                private final PveClient client;
                private final Object node;

                protected PVEVncshell(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Creates a VNC Shell proxy.
                 *
                 * @param cmd Run specific command or default to login (requires
                 * 'root@pam') Enum: ceph_install,login,upgrade
                 * @param cmd_opts Add parameters to a command. Encoded as null
                 * terminated strings.
                 * @param height sets the height of the console in pixels.
                 * @param websocket use websocket instead of standard vnc.
                 * @param width sets the width of the console in pixels.
                 * @return Result
                 * @throws JSONException
                 */
                public Result vncshell(String cmd, String cmd_opts, Integer height, Boolean websocket, Integer width) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("cmd", cmd);
                    parameters.put("cmd-opts", cmd_opts);
                    parameters.put("height", height);
                    parameters.put("websocket", websocket);
                    parameters.put("width", width);
                    return client.create("/nodes/" + this.node + "/vncshell", parameters);
                }

                /**
                 * Creates a VNC Shell proxy.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result vncshell() throws JSONException {
                    return client.create("/nodes/" + this.node + "/vncshell", null);
                }

            }

            public class PVETermproxy {

                private final PveClient client;
                private final Object node;

                protected PVETermproxy(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Creates a VNC Shell proxy.
                 *
                 * @param cmd Run specific command or default to login (requires
                 * 'root@pam') Enum: ceph_install,login,upgrade
                 * @param cmd_opts Add parameters to a command. Encoded as null
                 * terminated strings.
                 * @return Result
                 * @throws JSONException
                 */
                public Result termproxy(String cmd, String cmd_opts) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("cmd", cmd);
                    parameters.put("cmd-opts", cmd_opts);
                    return client.create("/nodes/" + this.node + "/termproxy", parameters);
                }

                /**
                 * Creates a VNC Shell proxy.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result termproxy() throws JSONException {
                    return client.create("/nodes/" + this.node + "/termproxy", null);
                }

            }

            public class PVEVncwebsocket {

                private final PveClient client;
                private final Object node;

                protected PVEVncwebsocket(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Opens a websocket for VNC traffic.
                 *
                 * @param port Port number returned by previous vncproxy call.
                 * @param vncticket Ticket from previous call to vncproxy.
                 * @return Result
                 * @throws JSONException
                 */
                public Result vncwebsocket(int port, String vncticket) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("port", port);
                    parameters.put("vncticket", vncticket);
                    return client.get("/nodes/" + this.node + "/vncwebsocket", parameters);
                }

            }

            public class PVESpiceshell {

                private final PveClient client;
                private final Object node;

                protected PVESpiceshell(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Creates a SPICE shell.
                 *
                 * @param cmd Run specific command or default to login (requires
                 * 'root@pam') Enum: ceph_install,login,upgrade
                 * @param cmd_opts Add parameters to a command. Encoded as null
                 * terminated strings.
                 * @param proxy SPICE proxy server. This can be used by the
                 * client to specify the proxy server. All nodes in a cluster
                 * runs 'spiceproxy', so it is up to the client to choose one.
                 * By default, we return the node where the VM is currently
                 * running. As reasonable setting is to use same node you use to
                 * connect to the API (This is window.location.hostname for the
                 * JS GUI).
                 * @return Result
                 * @throws JSONException
                 */
                public Result spiceshell(String cmd, String cmd_opts, String proxy) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("cmd", cmd);
                    parameters.put("cmd-opts", cmd_opts);
                    parameters.put("proxy", proxy);
                    return client.create("/nodes/" + this.node + "/spiceshell", parameters);
                }

                /**
                 * Creates a SPICE shell.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result spiceshell() throws JSONException {
                    return client.create("/nodes/" + this.node + "/spiceshell", null);
                }

            }

            public class PVEDns {

                private final PveClient client;
                private final Object node;

                protected PVEDns(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Read DNS settings.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result dns() throws JSONException {
                    return client.get("/nodes/" + this.node + "/dns", null);
                }

                /**
                 * Write DNS settings.
                 *
                 * @param search Search domain for host-name lookup.
                 * @param dns1 First name server IP address.
                 * @param dns2 Second name server IP address.
                 * @param dns3 Third name server IP address.
                 * @return Result
                 * @throws JSONException
                 */

                public Result updateDns(String search, String dns1, String dns2, String dns3) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("search", search);
                    parameters.put("dns1", dns1);
                    parameters.put("dns2", dns2);
                    parameters.put("dns3", dns3);
                    return client.set("/nodes/" + this.node + "/dns", parameters);
                }

                /**
                 * Write DNS settings.
                 *
                 * @param search Search domain for host-name lookup.
                 * @return Result
                 * @throws JSONException
                 */

                public Result updateDns(String search) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("search", search);
                    return client.set("/nodes/" + this.node + "/dns", parameters);
                }

            }

            public class PVETime {

                private final PveClient client;
                private final Object node;

                protected PVETime(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Read server time and time zone settings.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result time() throws JSONException {
                    return client.get("/nodes/" + this.node + "/time", null);
                }

                /**
                 * Set time zone.
                 *
                 * @param timezone Time zone. The file
                 * '/usr/share/zoneinfo/zone.tab' contains the list of valid
                 * names.
                 * @return Result
                 * @throws JSONException
                 */

                public Result setTimezone(String timezone) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("timezone", timezone);
                    return client.set("/nodes/" + this.node + "/time", parameters);
                }

            }

            public class PVEAplinfo {

                private final PveClient client;
                private final Object node;

                protected PVEAplinfo(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Get list of appliances.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result aplinfo() throws JSONException {
                    return client.get("/nodes/" + this.node + "/aplinfo", null);
                }

                /**
                 * Download appliance templates.
                 *
                 * @param storage The storage where the template will be stored
                 * @param template The template which will downloaded
                 * @return Result
                 * @throws JSONException
                 */

                public Result aplDownload(String storage, String template) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("storage", storage);
                    parameters.put("template", template);
                    return client.create("/nodes/" + this.node + "/aplinfo", parameters);
                }

            }

            public class PVEQueryUrlMetadata {

                private final PveClient client;
                private final Object node;

                protected PVEQueryUrlMetadata(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Query metadata of an URL: file size, file name and mime type.
                 *
                 * @param url The URL to query the metadata from.
                 * @param verify_certificates If false, no SSL/TLS certificates
                 * will be verified.
                 * @return Result
                 * @throws JSONException
                 */
                public Result queryUrlMetadata(String url, Boolean verify_certificates) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("url", url);
                    parameters.put("verify-certificates", verify_certificates);
                    return client.get("/nodes/" + this.node + "/query-url-metadata", parameters);
                }

                /**
                 * Query metadata of an URL: file size, file name and mime type.
                 *
                 * @param url The URL to query the metadata from.
                 * @return Result
                 * @throws JSONException
                 */

                public Result queryUrlMetadata(String url) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("url", url);
                    return client.get("/nodes/" + this.node + "/query-url-metadata", parameters);
                }

            }

            public class PVEReport {

                private final PveClient client;
                private final Object node;

                protected PVEReport(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Gather various systems information about a node
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result report() throws JSONException {
                    return client.get("/nodes/" + this.node + "/report", null);
                }

            }

            public class PVEStartall {

                private final PveClient client;
                private final Object node;

                protected PVEStartall(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Start all VMs and containers located on this node (by default
                 * only those with onboot=1).
                 *
                 * @param force Issue start command even if virtual guest have
                 * 'onboot' not set or set to off.
                 * @param vms Only consider guests from this comma separated
                 * list of VMIDs.
                 * @return Result
                 * @throws JSONException
                 */
                public Result startall(Boolean force, String vms) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("force", force);
                    parameters.put("vms", vms);
                    return client.create("/nodes/" + this.node + "/startall", parameters);
                }

                /**
                 * Start all VMs and containers located on this node (by default
                 * only those with onboot=1).
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result startall() throws JSONException {
                    return client.create("/nodes/" + this.node + "/startall", null);
                }

            }

            public class PVEStopall {

                private final PveClient client;
                private final Object node;

                protected PVEStopall(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Stop all VMs and Containers.
                 *
                 * @param force_stop Force a hard-stop after the timeout.
                 * @param timeout Timeout for each guest shutdown task.
                 * Depending on `force-stop`, the shutdown gets then simply
                 * aborted or a hard-stop is forced.
                 * @param vms Only consider Guests with these IDs.
                 * @return Result
                 * @throws JSONException
                 */
                public Result stopall(Boolean force_stop, Integer timeout, String vms) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("force-stop", force_stop);
                    parameters.put("timeout", timeout);
                    parameters.put("vms", vms);
                    return client.create("/nodes/" + this.node + "/stopall", parameters);
                }

                /**
                 * Stop all VMs and Containers.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result stopall() throws JSONException {
                    return client.create("/nodes/" + this.node + "/stopall", null);
                }

            }

            public class PVESuspendall {

                private final PveClient client;
                private final Object node;

                protected PVESuspendall(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Suspend all VMs.
                 *
                 * @param vms Only consider Guests with these IDs.
                 * @return Result
                 * @throws JSONException
                 */
                public Result suspendall(String vms) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("vms", vms);
                    return client.create("/nodes/" + this.node + "/suspendall", parameters);
                }

                /**
                 * Suspend all VMs.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result suspendall() throws JSONException {
                    return client.create("/nodes/" + this.node + "/suspendall", null);
                }

            }

            public class PVEMigrateall {

                private final PveClient client;
                private final Object node;

                protected PVEMigrateall(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Migrate all VMs and Containers.
                 *
                 * @param target Target node.
                 * @param maxworkers Maximal number of parallel migration job.
                 * If not set, uses'max_workers' from datacenter.cfg. One of
                 * both must be set!
                 * @param vms Only consider Guests with these IDs.
                 * @param with_local_disks Enable live storage migration for
                 * local disk
                 * @return Result
                 * @throws JSONException
                 */
                public Result migrateall(String target, Integer maxworkers, String vms, Boolean with_local_disks) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("target", target);
                    parameters.put("maxworkers", maxworkers);
                    parameters.put("vms", vms);
                    parameters.put("with-local-disks", with_local_disks);
                    return client.create("/nodes/" + this.node + "/migrateall", parameters);
                }

                /**
                 * Migrate all VMs and Containers.
                 *
                 * @param target Target node.
                 * @return Result
                 * @throws JSONException
                 */

                public Result migrateall(String target) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("target", target);
                    return client.create("/nodes/" + this.node + "/migrateall", parameters);
                }

            }

            public class PVEHosts {

                private final PveClient client;
                private final Object node;

                protected PVEHosts(PveClient client, Object node) {
                    this.client = client;
                    this.node = node;
                }

                /**
                 * Get the content of /etc/hosts.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result getEtcHosts() throws JSONException {
                    return client.get("/nodes/" + this.node + "/hosts", null);
                }

                /**
                 * Write /etc/hosts.
                 *
                 * @param data The target content of /etc/hosts.
                 * @param digest Prevent changes if current configuration file
                 * has a different digest. This can be used to prevent
                 * concurrent modifications.
                 * @return Result
                 * @throws JSONException
                 */

                public Result writeEtcHosts(String data, String digest) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("data", data);
                    parameters.put("digest", digest);
                    return client.create("/nodes/" + this.node + "/hosts", parameters);
                }

                /**
                 * Write /etc/hosts.
                 *
                 * @param data The target content of /etc/hosts.
                 * @return Result
                 * @throws JSONException
                 */

                public Result writeEtcHosts(String data) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("data", data);
                    return client.create("/nodes/" + this.node + "/hosts", parameters);
                }

            }

            /**
             * Node index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/nodes/" + this.node + "", null);
            }

        }

        /**
         * Cluster node index.
         *
         * @return Result
         * @throws JSONException
         */
        public Result index() throws JSONException {
            return client.get("/nodes", null);
        }

    }

    public class PVEStorage {

        private final PveClient client;

        protected PVEStorage(PveClient client) {
            this.client = client;

        }

        public PVEStorageItem get(Object storage) {
            return new PVEStorageItem(client, storage);
        }

        public class PVEStorageItem {

            private final PveClient client;
            private final Object storage;

            protected PVEStorageItem(PveClient client, Object storage) {
                this.client = client;
                this.storage = storage;
            }

            /**
             * Delete storage configuration.
             *
             * @return Result
             * @throws JSONException
             */
            public Result delete() throws JSONException {
                return client.delete("/storage/" + this.storage + "", null);
            }

            /**
             * Read storage configuration.
             *
             * @return Result
             * @throws JSONException
             */

            public Result read() throws JSONException {
                return client.get("/storage/" + this.storage + "", null);
            }

            /**
             * Update storage configuration.
             *
             * @param blocksize block size
             * @param bwlimit Set I/O bandwidth limit for various operations (in
             * KiB/s).
             * @param comstar_hg host group for comstar views
             * @param comstar_tg target group for comstar views
             * @param content Allowed content types. NOTE: the value 'rootdir'
             * is used for Containers, and value 'images' for VMs.
             * @param content_dirs Overrides for default content type
             * directories.
             * @param create_base_path Create the base directory if it doesn't
             * exist.
             * @param create_subdirs Populate the directory with the default
             * structure.
             * @param data_pool Data Pool (for erasure coding only)
             * @param delete A list of settings you want to delete.
             * @param digest Prevent changes if current configuration file has a
             * different digest. This can be used to prevent concurrent
             * modifications.
             * @param disable Flag to disable the storage.
             * @param domain CIFS domain.
             * @param encryption_key Encryption key. Use 'autogen' to generate
             * one automatically without passphrase.
             * @param fingerprint Certificate SHA 256 fingerprint.
             * @param format Default image format.
             * @param fs_name The Ceph filesystem name.
             * @param fuse Mount CephFS through FUSE.
             * @param is_mountpoint Assume the given path is an externally
             * managed mountpoint and consider the storage offline if it is not
             * mounted. Using a boolean (yes/no) value serves as a shortcut to
             * using the target path in this field.
             * @param keyring Client keyring contents (for external clusters).
             * @param krbd Always access rbd through krbd kernel module.
             * @param lio_tpg target portal group for Linux LIO targets
             * @param master_pubkey Base64-encoded, PEM-formatted public RSA
             * key. Used to encrypt a copy of the encryption-key which will be
             * added to each encrypted backup.
             * @param max_protected_backups Maximal number of protected backups
             * per guest. Use '-1' for unlimited.
             * @param maxfiles Deprecated: use 'prune-backups' instead. Maximal
             * number of backup files per VM. Use '0' for unlimited.
             * @param mkdir Create the directory if it doesn't exist and
             * populate it with default sub-dirs. NOTE: Deprecated, use the
             * 'create-base-path' and 'create-subdirs' options instead.
             * @param monhost IP addresses of monitors (for external clusters).
             * @param mountpoint mount point
             * @param namespace_ Namespace.
             * @param nocow Set the NOCOW flag on files. Disables data
             * checksumming and causes data errors to be unrecoverable from
             * while allowing direct I/O. Only use this if data does not need to
             * be any more safe than on a single ext4 formatted disk with no
             * underlying raid system.
             * @param nodes List of cluster node names.
             * @param nowritecache disable write caching on the target
             * @param options NFS/CIFS mount options (see 'man nfs' or 'man
             * mount.cifs')
             * @param password Password for accessing the share/datastore.
             * @param pool Pool.
             * @param port For non default port.
             * @param preallocation Preallocation mode for raw and qcow2 images.
             * Using 'metadata' on raw images results in preallocation=off.
             * Enum: off,metadata,falloc,full
             * @param prune_backups The retention options with shorter intervals
             * are processed first with --keep-last being the very first one.
             * Each option covers a specific period of time. We say that backups
             * within this period are covered by this option. The next option
             * does not take care of already covered backups and only considers
             * older backups.
             * @param saferemove Zero-out data when removing LVs.
             * @param saferemove_throughput Wipe throughput (cstream -t
             * parameter value).
             * @param server Server IP or DNS name.
             * @param server2 Backup volfile server IP or DNS name.
             * @param shared Mark storage as shared.
             * @param smbversion SMB protocol version. 'default' if not set,
             * negotiates the highest SMB2+ version supported by both the client
             * and server. Enum: default,2.0,2.1,3,3.0,3.11
             * @param sparse use sparse volumes
             * @param subdir Subdir to mount.
             * @param tagged_only Only use logical volumes tagged with
             * 'pve-vm-ID'.
             * @param transport Gluster transport: tcp or rdma Enum:
             * tcp,rdma,unix
             * @param username RBD Id.
             * @return Result
             * @throws JSONException
             */

            public Result update(String blocksize, String bwlimit, String comstar_hg, String comstar_tg, String content, String content_dirs, Boolean create_base_path, Boolean create_subdirs, String data_pool, String delete, String digest, Boolean disable, String domain, String encryption_key, String fingerprint, String format, String fs_name, Boolean fuse, String is_mountpoint, String keyring, Boolean krbd, String lio_tpg, String master_pubkey, Integer max_protected_backups, Integer maxfiles, Boolean mkdir, String monhost, String mountpoint, String namespace_, Boolean nocow, String nodes, Boolean nowritecache, String options, String password, String pool, Integer port, String preallocation, String prune_backups, Boolean saferemove, String saferemove_throughput, String server, String server2, Boolean shared, String smbversion, Boolean sparse, String subdir, Boolean tagged_only, String transport, String username) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("blocksize", blocksize);
                parameters.put("bwlimit", bwlimit);
                parameters.put("comstar_hg", comstar_hg);
                parameters.put("comstar_tg", comstar_tg);
                parameters.put("content", content);
                parameters.put("content-dirs", content_dirs);
                parameters.put("create-base-path", create_base_path);
                parameters.put("create-subdirs", create_subdirs);
                parameters.put("data-pool", data_pool);
                parameters.put("delete", delete);
                parameters.put("digest", digest);
                parameters.put("disable", disable);
                parameters.put("domain", domain);
                parameters.put("encryption-key", encryption_key);
                parameters.put("fingerprint", fingerprint);
                parameters.put("format", format);
                parameters.put("fs-name", fs_name);
                parameters.put("fuse", fuse);
                parameters.put("is_mountpoint", is_mountpoint);
                parameters.put("keyring", keyring);
                parameters.put("krbd", krbd);
                parameters.put("lio_tpg", lio_tpg);
                parameters.put("master-pubkey", master_pubkey);
                parameters.put("max-protected-backups", max_protected_backups);
                parameters.put("maxfiles", maxfiles);
                parameters.put("mkdir", mkdir);
                parameters.put("monhost", monhost);
                parameters.put("mountpoint", mountpoint);
                parameters.put("namespace", namespace_);
                parameters.put("nocow", nocow);
                parameters.put("nodes", nodes);
                parameters.put("nowritecache", nowritecache);
                parameters.put("options", options);
                parameters.put("password", password);
                parameters.put("pool", pool);
                parameters.put("port", port);
                parameters.put("preallocation", preallocation);
                parameters.put("prune-backups", prune_backups);
                parameters.put("saferemove", saferemove);
                parameters.put("saferemove_throughput", saferemove_throughput);
                parameters.put("server", server);
                parameters.put("server2", server2);
                parameters.put("shared", shared);
                parameters.put("smbversion", smbversion);
                parameters.put("sparse", sparse);
                parameters.put("subdir", subdir);
                parameters.put("tagged_only", tagged_only);
                parameters.put("transport", transport);
                parameters.put("username", username);
                return client.set("/storage/" + this.storage + "", parameters);
            }

            /**
             * Update storage configuration.
             *
             * @return Result
             * @throws JSONException
             */

            public Result update() throws JSONException {
                return client.set("/storage/" + this.storage + "", null);
            }

        }

        /**
         * Storage index.
         *
         * @param type Only list storage of specific type Enum:
         * btrfs,cephfs,cifs,dir,glusterfs,iscsi,iscsidirect,lvm,lvmthin,nfs,pbs,rbd,zfs,zfspool
         * @return Result
         * @throws JSONException
         */
        public Result index(String type) throws JSONException {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("type", type);
            return client.get("/storage", parameters);
        }

        /**
         * Storage index.
         *
         * @return Result
         * @throws JSONException
         */

        public Result index() throws JSONException {
            return client.get("/storage", null);
        }

        /**
         * Create a new storage.
         *
         * @param storage The storage identifier.
         * @param type Storage type. Enum:
         * btrfs,cephfs,cifs,dir,glusterfs,iscsi,iscsidirect,lvm,lvmthin,nfs,pbs,rbd,zfs,zfspool
         * @param authsupported Authsupported.
         * @param base_ Base volume. This volume is automatically activated.
         * @param blocksize block size
         * @param bwlimit Set I/O bandwidth limit for various operations (in
         * KiB/s).
         * @param comstar_hg host group for comstar views
         * @param comstar_tg target group for comstar views
         * @param content Allowed content types. NOTE: the value 'rootdir' is
         * used for Containers, and value 'images' for VMs.
         * @param content_dirs Overrides for default content type directories.
         * @param create_base_path Create the base directory if it doesn't
         * exist.
         * @param create_subdirs Populate the directory with the default
         * structure.
         * @param data_pool Data Pool (for erasure coding only)
         * @param datastore Proxmox Backup Server datastore name.
         * @param disable Flag to disable the storage.
         * @param domain CIFS domain.
         * @param encryption_key Encryption key. Use 'autogen' to generate one
         * automatically without passphrase.
         * @param export NFS export path.
         * @param fingerprint Certificate SHA 256 fingerprint.
         * @param format Default image format.
         * @param fs_name The Ceph filesystem name.
         * @param fuse Mount CephFS through FUSE.
         * @param is_mountpoint Assume the given path is an externally managed
         * mountpoint and consider the storage offline if it is not mounted.
         * Using a boolean (yes/no) value serves as a shortcut to using the
         * target path in this field.
         * @param iscsiprovider iscsi provider
         * @param keyring Client keyring contents (for external clusters).
         * @param krbd Always access rbd through krbd kernel module.
         * @param lio_tpg target portal group for Linux LIO targets
         * @param master_pubkey Base64-encoded, PEM-formatted public RSA key.
         * Used to encrypt a copy of the encryption-key which will be added to
         * each encrypted backup.
         * @param max_protected_backups Maximal number of protected backups per
         * guest. Use '-1' for unlimited.
         * @param maxfiles Deprecated: use 'prune-backups' instead. Maximal
         * number of backup files per VM. Use '0' for unlimited.
         * @param mkdir Create the directory if it doesn't exist and populate it
         * with default sub-dirs. NOTE: Deprecated, use the 'create-base-path'
         * and 'create-subdirs' options instead.
         * @param monhost IP addresses of monitors (for external clusters).
         * @param mountpoint mount point
         * @param namespace_ Namespace.
         * @param nocow Set the NOCOW flag on files. Disables data checksumming
         * and causes data errors to be unrecoverable from while allowing direct
         * I/O. Only use this if data does not need to be any more safe than on
         * a single ext4 formatted disk with no underlying raid system.
         * @param nodes List of cluster node names.
         * @param nowritecache disable write caching on the target
         * @param options NFS/CIFS mount options (see 'man nfs' or 'man
         * mount.cifs')
         * @param password Password for accessing the share/datastore.
         * @param path File system path.
         * @param pool Pool.
         * @param port For non default port.
         * @param portal iSCSI portal (IP or DNS name with optional port).
         * @param preallocation Preallocation mode for raw and qcow2 images.
         * Using 'metadata' on raw images results in preallocation=off. Enum:
         * off,metadata,falloc,full
         * @param prune_backups The retention options with shorter intervals are
         * processed first with --keep-last being the very first one. Each
         * option covers a specific period of time. We say that backups within
         * this period are covered by this option. The next option does not take
         * care of already covered backups and only considers older backups.
         * @param saferemove Zero-out data when removing LVs.
         * @param saferemove_throughput Wipe throughput (cstream -t parameter
         * value).
         * @param server Server IP or DNS name.
         * @param server2 Backup volfile server IP or DNS name.
         * @param share CIFS share.
         * @param shared Mark storage as shared.
         * @param smbversion SMB protocol version. 'default' if not set,
         * negotiates the highest SMB2+ version supported by both the client and
         * server. Enum: default,2.0,2.1,3,3.0,3.11
         * @param sparse use sparse volumes
         * @param subdir Subdir to mount.
         * @param tagged_only Only use logical volumes tagged with 'pve-vm-ID'.
         * @param target iSCSI target.
         * @param thinpool LVM thin pool LV name.
         * @param transport Gluster transport: tcp or rdma Enum: tcp,rdma,unix
         * @param username RBD Id.
         * @param vgname Volume group name.
         * @param volume Glusterfs Volume.
         * @return Result
         * @throws JSONException
         */

        public Result create(String storage, String type, String authsupported, String base_, String blocksize, String bwlimit, String comstar_hg, String comstar_tg, String content, String content_dirs, Boolean create_base_path, Boolean create_subdirs, String data_pool, String datastore, Boolean disable, String domain, String encryption_key, String export, String fingerprint, String format, String fs_name, Boolean fuse, String is_mountpoint, String iscsiprovider, String keyring, Boolean krbd, String lio_tpg, String master_pubkey, Integer max_protected_backups, Integer maxfiles, Boolean mkdir, String monhost, String mountpoint, String namespace_, Boolean nocow, String nodes, Boolean nowritecache, String options, String password, String path, String pool, Integer port, String portal, String preallocation, String prune_backups, Boolean saferemove, String saferemove_throughput, String server, String server2, String share, Boolean shared, String smbversion, Boolean sparse, String subdir, Boolean tagged_only, String target, String thinpool, String transport, String username, String vgname, String volume) throws JSONException {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("storage", storage);
            parameters.put("type", type);
            parameters.put("authsupported", authsupported);
            parameters.put("base", base_);
            parameters.put("blocksize", blocksize);
            parameters.put("bwlimit", bwlimit);
            parameters.put("comstar_hg", comstar_hg);
            parameters.put("comstar_tg", comstar_tg);
            parameters.put("content", content);
            parameters.put("content-dirs", content_dirs);
            parameters.put("create-base-path", create_base_path);
            parameters.put("create-subdirs", create_subdirs);
            parameters.put("data-pool", data_pool);
            parameters.put("datastore", datastore);
            parameters.put("disable", disable);
            parameters.put("domain", domain);
            parameters.put("encryption-key", encryption_key);
            parameters.put("export", export);
            parameters.put("fingerprint", fingerprint);
            parameters.put("format", format);
            parameters.put("fs-name", fs_name);
            parameters.put("fuse", fuse);
            parameters.put("is_mountpoint", is_mountpoint);
            parameters.put("iscsiprovider", iscsiprovider);
            parameters.put("keyring", keyring);
            parameters.put("krbd", krbd);
            parameters.put("lio_tpg", lio_tpg);
            parameters.put("master-pubkey", master_pubkey);
            parameters.put("max-protected-backups", max_protected_backups);
            parameters.put("maxfiles", maxfiles);
            parameters.put("mkdir", mkdir);
            parameters.put("monhost", monhost);
            parameters.put("mountpoint", mountpoint);
            parameters.put("namespace", namespace_);
            parameters.put("nocow", nocow);
            parameters.put("nodes", nodes);
            parameters.put("nowritecache", nowritecache);
            parameters.put("options", options);
            parameters.put("password", password);
            parameters.put("path", path);
            parameters.put("pool", pool);
            parameters.put("port", port);
            parameters.put("portal", portal);
            parameters.put("preallocation", preallocation);
            parameters.put("prune-backups", prune_backups);
            parameters.put("saferemove", saferemove);
            parameters.put("saferemove_throughput", saferemove_throughput);
            parameters.put("server", server);
            parameters.put("server2", server2);
            parameters.put("share", share);
            parameters.put("shared", shared);
            parameters.put("smbversion", smbversion);
            parameters.put("sparse", sparse);
            parameters.put("subdir", subdir);
            parameters.put("tagged_only", tagged_only);
            parameters.put("target", target);
            parameters.put("thinpool", thinpool);
            parameters.put("transport", transport);
            parameters.put("username", username);
            parameters.put("vgname", vgname);
            parameters.put("volume", volume);
            return client.create("/storage", parameters);
        }

        /**
         * Create a new storage.
         *
         * @param storage The storage identifier.
         * @param type Storage type. Enum:
         * btrfs,cephfs,cifs,dir,glusterfs,iscsi,iscsidirect,lvm,lvmthin,nfs,pbs,rbd,zfs,zfspool
         * @return Result
         * @throws JSONException
         */

        public Result create(String storage, String type) throws JSONException {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("storage", storage);
            parameters.put("type", type);
            return client.create("/storage", parameters);
        }

    }

    public class PVEAccess {

        private final PveClient client;

        protected PVEAccess(PveClient client) {
            this.client = client;

        }

        private PVEUsers users;

        public PVEUsers getUsers() {
            return users == null ? (users = new PVEUsers(client)) : users;
        }
        private PVEGroups groups;

        public PVEGroups getGroups() {
            return groups == null ? (groups = new PVEGroups(client)) : groups;
        }
        private PVERoles roles;

        public PVERoles getRoles() {
            return roles == null ? (roles = new PVERoles(client)) : roles;
        }
        private PVEAcl acl;

        public PVEAcl getAcl() {
            return acl == null ? (acl = new PVEAcl(client)) : acl;
        }
        private PVEDomains domains;

        public PVEDomains getDomains() {
            return domains == null ? (domains = new PVEDomains(client)) : domains;
        }
        private PVEOpenid openid;

        public PVEOpenid getOpenid() {
            return openid == null ? (openid = new PVEOpenid(client)) : openid;
        }
        private PVETfa tfa;

        public PVETfa getTfa() {
            return tfa == null ? (tfa = new PVETfa(client)) : tfa;
        }
        private PVETicket ticket;

        public PVETicket getTicket() {
            return ticket == null ? (ticket = new PVETicket(client)) : ticket;
        }
        private PVEPassword password;

        public PVEPassword getPassword() {
            return password == null ? (password = new PVEPassword(client)) : password;
        }
        private PVEPermissions permissions;

        public PVEPermissions getPermissions() {
            return permissions == null ? (permissions = new PVEPermissions(client)) : permissions;
        }

        public class PVEUsers {

            private final PveClient client;

            protected PVEUsers(PveClient client) {
                this.client = client;

            }

            public PVEUseridItem get(Object userid) {
                return new PVEUseridItem(client, userid);
            }

            public class PVEUseridItem {

                private final PveClient client;
                private final Object userid;

                protected PVEUseridItem(PveClient client, Object userid) {
                    this.client = client;
                    this.userid = userid;
                }

                private PVETfa tfa;

                public PVETfa getTfa() {
                    return tfa == null ? (tfa = new PVETfa(client, this.userid)) : tfa;
                }
                private PVEUnlockTfa unlockTfa;

                public PVEUnlockTfa getUnlockTfa() {
                    return unlockTfa == null ? (unlockTfa = new PVEUnlockTfa(client, this.userid)) : unlockTfa;
                }
                private PVEToken token;

                public PVEToken getToken() {
                    return token == null ? (token = new PVEToken(client, this.userid)) : token;
                }

                public class PVETfa {

                    private final PveClient client;
                    private final Object userid;

                    protected PVETfa(PveClient client, Object userid) {
                        this.client = client;
                        this.userid = userid;
                    }

                    /**
                     * Get user TFA types (Personal and Realm).
                     *
                     * @param multiple Request all entries as an array.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result readUserTfaType(Boolean multiple) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("multiple", multiple);
                        return client.get("/access/users/" + this.userid + "/tfa", parameters);
                    }

                    /**
                     * Get user TFA types (Personal and Realm).
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result readUserTfaType() throws JSONException {
                        return client.get("/access/users/" + this.userid + "/tfa", null);
                    }

                }

                public class PVEUnlockTfa {

                    private final PveClient client;
                    private final Object userid;

                    protected PVEUnlockTfa(PveClient client, Object userid) {
                        this.client = client;
                        this.userid = userid;
                    }

                    /**
                     * Unlock a user's TFA authentication.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result unlockTfa() throws JSONException {
                        return client.set("/access/users/" + this.userid + "/unlock-tfa", null);
                    }

                }

                public class PVEToken {

                    private final PveClient client;
                    private final Object userid;

                    protected PVEToken(PveClient client, Object userid) {
                        this.client = client;
                        this.userid = userid;
                    }

                    public PVETokenidItem get(Object tokenid) {
                        return new PVETokenidItem(client, this.userid, tokenid);
                    }

                    public class PVETokenidItem {

                        private final PveClient client;
                        private final Object userid;
                        private final Object tokenid;

                        protected PVETokenidItem(PveClient client, Object userid, Object tokenid) {
                            this.client = client;
                            this.userid = userid;
                            this.tokenid = tokenid;
                        }

                        /**
                         * Remove API token for a specific user.
                         *
                         * @return Result
                         * @throws JSONException
                         */
                        public Result removeToken() throws JSONException {
                            return client.delete("/access/users/" + this.userid + "/token/" + this.tokenid + "", null);
                        }

                        /**
                         * Get specific API token information.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result readToken() throws JSONException {
                            return client.get("/access/users/" + this.userid + "/token/" + this.tokenid + "", null);
                        }

                        /**
                         * Generate a new API token for a specific user. NOTE:
                         * returns API token value, which needs to be stored as
                         * it cannot be retrieved afterwards!
                         *
                         * @param comment
                         * @param expire API token expiration date (seconds
                         * since epoch). '0' means no expiration date.
                         * @param privsep Restrict API token privileges with
                         * separate ACLs (default), or give full privileges of
                         * corresponding user.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result generateToken(String comment, Integer expire, Boolean privsep) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("comment", comment);
                            parameters.put("expire", expire);
                            parameters.put("privsep", privsep);
                            return client.create("/access/users/" + this.userid + "/token/" + this.tokenid + "", parameters);
                        }

                        /**
                         * Generate a new API token for a specific user. NOTE:
                         * returns API token value, which needs to be stored as
                         * it cannot be retrieved afterwards!
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result generateToken() throws JSONException {
                            return client.create("/access/users/" + this.userid + "/token/" + this.tokenid + "", null);
                        }

                        /**
                         * Update API token for a specific user.
                         *
                         * @param comment
                         * @param expire API token expiration date (seconds
                         * since epoch). '0' means no expiration date.
                         * @param privsep Restrict API token privileges with
                         * separate ACLs (default), or give full privileges of
                         * corresponding user.
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateTokenInfo(String comment, Integer expire, Boolean privsep) throws JSONException {
                            Map<String, Object> parameters = new HashMap<>();
                            parameters.put("comment", comment);
                            parameters.put("expire", expire);
                            parameters.put("privsep", privsep);
                            return client.set("/access/users/" + this.userid + "/token/" + this.tokenid + "", parameters);
                        }

                        /**
                         * Update API token for a specific user.
                         *
                         * @return Result
                         * @throws JSONException
                         */

                        public Result updateTokenInfo() throws JSONException {
                            return client.set("/access/users/" + this.userid + "/token/" + this.tokenid + "", null);
                        }

                    }

                    /**
                     * Get user API tokens.
                     *
                     * @return Result
                     * @throws JSONException
                     */
                    public Result tokenIndex() throws JSONException {
                        return client.get("/access/users/" + this.userid + "/token", null);
                    }

                }

                /**
                 * Delete user.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result deleteUser() throws JSONException {
                    return client.delete("/access/users/" + this.userid + "", null);
                }

                /**
                 * Get user configuration.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result readUser() throws JSONException {
                    return client.get("/access/users/" + this.userid + "", null);
                }

                /**
                 * Update user configuration.
                 *
                 * @param append
                 * @param comment
                 * @param email
                 * @param enable Enable the account (default). You can set this
                 * to '0' to disable the account
                 * @param expire Account expiration date (seconds since epoch).
                 * '0' means no expiration date.
                 * @param firstname
                 * @param groups
                 * @param keys Keys for two factor auth (yubico).
                 * @param lastname
                 * @return Result
                 * @throws JSONException
                 */

                public Result updateUser(Boolean append, String comment, String email, Boolean enable, Integer expire, String firstname, String groups, String keys, String lastname) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("append", append);
                    parameters.put("comment", comment);
                    parameters.put("email", email);
                    parameters.put("enable", enable);
                    parameters.put("expire", expire);
                    parameters.put("firstname", firstname);
                    parameters.put("groups", groups);
                    parameters.put("keys", keys);
                    parameters.put("lastname", lastname);
                    return client.set("/access/users/" + this.userid + "", parameters);
                }

                /**
                 * Update user configuration.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result updateUser() throws JSONException {
                    return client.set("/access/users/" + this.userid + "", null);
                }

            }

            /**
             * User index.
             *
             * @param enabled Optional filter for enable property.
             * @param full Include group and token information.
             * @return Result
             * @throws JSONException
             */
            public Result index(Boolean enabled, Boolean full) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("enabled", enabled);
                parameters.put("full", full);
                return client.get("/access/users", parameters);
            }

            /**
             * User index.
             *
             * @return Result
             * @throws JSONException
             */

            public Result index() throws JSONException {
                return client.get("/access/users", null);
            }

            /**
             * Create new user.
             *
             * @param userid Full User ID, in the `name@realm` format.
             * @param comment
             * @param email
             * @param enable Enable the account (default). You can set this to
             * '0' to disable the account
             * @param expire Account expiration date (seconds since epoch). '0'
             * means no expiration date.
             * @param firstname
             * @param groups
             * @param keys Keys for two factor auth (yubico).
             * @param lastname
             * @param password Initial password.
             * @return Result
             * @throws JSONException
             */

            public Result createUser(String userid, String comment, String email, Boolean enable, Integer expire, String firstname, String groups, String keys, String lastname, String password) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("userid", userid);
                parameters.put("comment", comment);
                parameters.put("email", email);
                parameters.put("enable", enable);
                parameters.put("expire", expire);
                parameters.put("firstname", firstname);
                parameters.put("groups", groups);
                parameters.put("keys", keys);
                parameters.put("lastname", lastname);
                parameters.put("password", password);
                return client.create("/access/users", parameters);
            }

            /**
             * Create new user.
             *
             * @param userid Full User ID, in the `name@realm` format.
             * @return Result
             * @throws JSONException
             */

            public Result createUser(String userid) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("userid", userid);
                return client.create("/access/users", parameters);
            }

        }

        public class PVEGroups {

            private final PveClient client;

            protected PVEGroups(PveClient client) {
                this.client = client;

            }

            public PVEGroupidItem get(Object groupid) {
                return new PVEGroupidItem(client, groupid);
            }

            public class PVEGroupidItem {

                private final PveClient client;
                private final Object groupid;

                protected PVEGroupidItem(PveClient client, Object groupid) {
                    this.client = client;
                    this.groupid = groupid;
                }

                /**
                 * Delete group.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result deleteGroup() throws JSONException {
                    return client.delete("/access/groups/" + this.groupid + "", null);
                }

                /**
                 * Get group configuration.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result readGroup() throws JSONException {
                    return client.get("/access/groups/" + this.groupid + "", null);
                }

                /**
                 * Update group data.
                 *
                 * @param comment
                 * @return Result
                 * @throws JSONException
                 */

                public Result updateGroup(String comment) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("comment", comment);
                    return client.set("/access/groups/" + this.groupid + "", parameters);
                }

                /**
                 * Update group data.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result updateGroup() throws JSONException {
                    return client.set("/access/groups/" + this.groupid + "", null);
                }

            }

            /**
             * Group index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/access/groups", null);
            }

            /**
             * Create new group.
             *
             * @param groupid
             * @param comment
             * @return Result
             * @throws JSONException
             */

            public Result createGroup(String groupid, String comment) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("groupid", groupid);
                parameters.put("comment", comment);
                return client.create("/access/groups", parameters);
            }

            /**
             * Create new group.
             *
             * @param groupid
             * @return Result
             * @throws JSONException
             */

            public Result createGroup(String groupid) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("groupid", groupid);
                return client.create("/access/groups", parameters);
            }

        }

        public class PVERoles {

            private final PveClient client;

            protected PVERoles(PveClient client) {
                this.client = client;

            }

            public PVERoleidItem get(Object roleid) {
                return new PVERoleidItem(client, roleid);
            }

            public class PVERoleidItem {

                private final PveClient client;
                private final Object roleid;

                protected PVERoleidItem(PveClient client, Object roleid) {
                    this.client = client;
                    this.roleid = roleid;
                }

                /**
                 * Delete role.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result deleteRole() throws JSONException {
                    return client.delete("/access/roles/" + this.roleid + "", null);
                }

                /**
                 * Get role configuration.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result readRole() throws JSONException {
                    return client.get("/access/roles/" + this.roleid + "", null);
                }

                /**
                 * Update an existing role.
                 *
                 * @param append
                 * @param privs
                 * @return Result
                 * @throws JSONException
                 */

                public Result updateRole(Boolean append, String privs) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("append", append);
                    parameters.put("privs", privs);
                    return client.set("/access/roles/" + this.roleid + "", parameters);
                }

                /**
                 * Update an existing role.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result updateRole() throws JSONException {
                    return client.set("/access/roles/" + this.roleid + "", null);
                }

            }

            /**
             * Role index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/access/roles", null);
            }

            /**
             * Create new role.
             *
             * @param roleid
             * @param privs
             * @return Result
             * @throws JSONException
             */

            public Result createRole(String roleid, String privs) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("roleid", roleid);
                parameters.put("privs", privs);
                return client.create("/access/roles", parameters);
            }

            /**
             * Create new role.
             *
             * @param roleid
             * @return Result
             * @throws JSONException
             */

            public Result createRole(String roleid) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("roleid", roleid);
                return client.create("/access/roles", parameters);
            }

        }

        public class PVEAcl {

            private final PveClient client;

            protected PVEAcl(PveClient client) {
                this.client = client;

            }

            /**
             * Get Access Control List (ACLs).
             *
             * @return Result
             * @throws JSONException
             */
            public Result readAcl() throws JSONException {
                return client.get("/access/acl", null);
            }

            /**
             * Update Access Control List (add or remove permissions).
             *
             * @param path Access control path
             * @param roles List of roles.
             * @param delete Remove permissions (instead of adding it).
             * @param groups List of groups.
             * @param propagate Allow to propagate (inherit) permissions.
             * @param tokens List of API tokens.
             * @param users List of users.
             * @return Result
             * @throws JSONException
             */

            public Result updateAcl(String path, String roles, Boolean delete, String groups, Boolean propagate, String tokens, String users) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("path", path);
                parameters.put("roles", roles);
                parameters.put("delete", delete);
                parameters.put("groups", groups);
                parameters.put("propagate", propagate);
                parameters.put("tokens", tokens);
                parameters.put("users", users);
                return client.set("/access/acl", parameters);
            }

            /**
             * Update Access Control List (add or remove permissions).
             *
             * @param path Access control path
             * @param roles List of roles.
             * @return Result
             * @throws JSONException
             */

            public Result updateAcl(String path, String roles) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("path", path);
                parameters.put("roles", roles);
                return client.set("/access/acl", parameters);
            }

        }

        public class PVEDomains {

            private final PveClient client;

            protected PVEDomains(PveClient client) {
                this.client = client;

            }

            public PVERealmItem get(Object realm) {
                return new PVERealmItem(client, realm);
            }

            public class PVERealmItem {

                private final PveClient client;
                private final Object realm;

                protected PVERealmItem(PveClient client, Object realm) {
                    this.client = client;
                    this.realm = realm;
                }

                private PVESync sync;

                public PVESync getSync() {
                    return sync == null ? (sync = new PVESync(client, this.realm)) : sync;
                }

                public class PVESync {

                    private final PveClient client;
                    private final Object realm;

                    protected PVESync(PveClient client, Object realm) {
                        this.client = client;
                        this.realm = realm;
                    }

                    /**
                     * Syncs users and/or groups from the configured LDAP to
                     * user.cfg. NOTE: Synced groups will have the name
                     * 'name-$realm', so make sure those groups do not exist to
                     * prevent overwriting.
                     *
                     * @param dry_run If set, does not write anything.
                     * @param enable_new Enable newly synced users immediately.
                     * @param full DEPRECATED: use 'remove-vanished' instead. If
                     * set, uses the LDAP Directory as source of truth, deleting
                     * users or groups not returned from the sync and removing
                     * all locally modified properties of synced users. If not
                     * set, only syncs information which is present in the
                     * synced data, and does not delete or modify anything else.
                     * @param purge DEPRECATED: use 'remove-vanished' instead.
                     * Remove ACLs for users or groups which were removed from
                     * the config during a sync.
                     * @param remove_vanished A semicolon-seperated list of
                     * things to remove when they or the user vanishes during a
                     * sync. The following values are possible: 'entry' removes
                     * the user/group when not returned from the sync.
                     * 'properties' removes the set properties on existing
                     * user/group that do not appear in the source (even custom
                     * ones). 'acl' removes acls when the user/group is not
                     * returned from the sync. Instead of a list it also can be
                     * 'none' (the default).
                     * @param scope Select what to sync. Enum: users,groups,both
                     * @return Result
                     * @throws JSONException
                     */
                    public Result sync(Boolean dry_run, Boolean enable_new, Boolean full, Boolean purge, String remove_vanished, String scope) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("dry-run", dry_run);
                        parameters.put("enable-new", enable_new);
                        parameters.put("full", full);
                        parameters.put("purge", purge);
                        parameters.put("remove-vanished", remove_vanished);
                        parameters.put("scope", scope);
                        return client.create("/access/domains/" + this.realm + "/sync", parameters);
                    }

                    /**
                     * Syncs users and/or groups from the configured LDAP to
                     * user.cfg. NOTE: Synced groups will have the name
                     * 'name-$realm', so make sure those groups do not exist to
                     * prevent overwriting.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result sync() throws JSONException {
                        return client.create("/access/domains/" + this.realm + "/sync", null);
                    }

                }

                /**
                 * Delete an authentication server.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result delete() throws JSONException {
                    return client.delete("/access/domains/" + this.realm + "", null);
                }

                /**
                 * Get auth server configuration.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result read() throws JSONException {
                    return client.get("/access/domains/" + this.realm + "", null);
                }

                /**
                 * Update authentication server settings.
                 *
                 * @param acr_values Specifies the Authentication Context Class
                 * Reference values that theAuthorization Server is being
                 * requested to use for the Auth Request.
                 * @param autocreate Automatically create users if they do not
                 * exist.
                 * @param base_dn LDAP base domain name
                 * @param bind_dn LDAP bind domain name
                 * @param capath Path to the CA certificate store
                 * @param case_sensitive username is case-sensitive
                 * @param cert Path to the client certificate
                 * @param certkey Path to the client certificate key
                 * @param check_connection Check bind connection to the server.
                 * @param client_id OpenID Client ID
                 * @param client_key OpenID Client Key
                 * @param comment Description.
                 * @param default_ Use this as default realm
                 * @param delete A list of settings you want to delete.
                 * @param digest Prevent changes if current configuration file
                 * has a different digest. This can be used to prevent
                 * concurrent modifications.
                 * @param domain AD domain name
                 * @param filter LDAP filter for user sync.
                 * @param group_classes The objectclasses for groups.
                 * @param group_dn LDAP base domain name for group sync. If not
                 * set, the base_dn will be used.
                 * @param group_filter LDAP filter for group sync.
                 * @param group_name_attr LDAP attribute representing a groups
                 * name. If not set or found, the first value of the DN will be
                 * used as name.
                 * @param issuer_url OpenID Issuer Url
                 * @param mode LDAP protocol mode. Enum:
                 * ldap,ldaps,ldap+starttls
                 * @param password LDAP bind password. Will be stored in
                 * '/etc/pve/priv/realm/&amp;lt;REALM&amp;gt;.pw'.
                 * @param port Server port.
                 * @param prompt Specifies whether the Authorization Server
                 * prompts the End-User for reauthentication and consent.
                 * @param scopes Specifies the scopes (user details) that should
                 * be authorized and returned, for example 'email' or 'profile'.
                 * @param secure Use secure LDAPS protocol. DEPRECATED: use
                 * 'mode' instead.
                 * @param server1 Server IP address (or DNS name)
                 * @param server2 Fallback Server IP address (or DNS name)
                 * @param sslversion LDAPS TLS/SSL version. It's not recommended
                 * to use version older than 1.2! Enum:
                 * tlsv1,tlsv1_1,tlsv1_2,tlsv1_3
                 * @param sync_defaults_options The default options for behavior
                 * of synchronizations.
                 * @param sync_attributes Comma separated list of key=value
                 * pairs for specifying which LDAP attributes map to which PVE
                 * user field. For example, to map the LDAP attribute 'mail' to
                 * PVEs 'email', write 'email=mail'. By default, each PVE user
                 * field is represented by an LDAP attribute of the same name.
                 * @param tfa Use Two-factor authentication.
                 * @param user_attr LDAP user attribute name
                 * @param user_classes The objectclasses for users.
                 * @param verify Verify the server's SSL certificate
                 * @return Result
                 * @throws JSONException
                 */

                public Result update(String acr_values, Boolean autocreate, String base_dn, String bind_dn, String capath, Boolean case_sensitive, String cert, String certkey, Boolean check_connection, String client_id, String client_key, String comment, Boolean default_, String delete, String digest, String domain, String filter, String group_classes, String group_dn, String group_filter, String group_name_attr, String issuer_url, String mode, String password, Integer port, String prompt, String scopes, Boolean secure, String server1, String server2, String sslversion, String sync_defaults_options, String sync_attributes, String tfa, String user_attr, String user_classes, Boolean verify) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("acr-values", acr_values);
                    parameters.put("autocreate", autocreate);
                    parameters.put("base_dn", base_dn);
                    parameters.put("bind_dn", bind_dn);
                    parameters.put("capath", capath);
                    parameters.put("case-sensitive", case_sensitive);
                    parameters.put("cert", cert);
                    parameters.put("certkey", certkey);
                    parameters.put("check-connection", check_connection);
                    parameters.put("client-id", client_id);
                    parameters.put("client-key", client_key);
                    parameters.put("comment", comment);
                    parameters.put("default", default_);
                    parameters.put("delete", delete);
                    parameters.put("digest", digest);
                    parameters.put("domain", domain);
                    parameters.put("filter", filter);
                    parameters.put("group_classes", group_classes);
                    parameters.put("group_dn", group_dn);
                    parameters.put("group_filter", group_filter);
                    parameters.put("group_name_attr", group_name_attr);
                    parameters.put("issuer-url", issuer_url);
                    parameters.put("mode", mode);
                    parameters.put("password", password);
                    parameters.put("port", port);
                    parameters.put("prompt", prompt);
                    parameters.put("scopes", scopes);
                    parameters.put("secure", secure);
                    parameters.put("server1", server1);
                    parameters.put("server2", server2);
                    parameters.put("sslversion", sslversion);
                    parameters.put("sync-defaults-options", sync_defaults_options);
                    parameters.put("sync_attributes", sync_attributes);
                    parameters.put("tfa", tfa);
                    parameters.put("user_attr", user_attr);
                    parameters.put("user_classes", user_classes);
                    parameters.put("verify", verify);
                    return client.set("/access/domains/" + this.realm + "", parameters);
                }

                /**
                 * Update authentication server settings.
                 *
                 * @return Result
                 * @throws JSONException
                 */

                public Result update() throws JSONException {
                    return client.set("/access/domains/" + this.realm + "", null);
                }

            }

            /**
             * Authentication domain index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/access/domains", null);
            }

            /**
             * Add an authentication server.
             *
             * @param realm Authentication domain ID
             * @param type Realm type. Enum: ad,ldap,openid,pam,pve
             * @param acr_values Specifies the Authentication Context Class
             * Reference values that theAuthorization Server is being requested
             * to use for the Auth Request.
             * @param autocreate Automatically create users if they do not
             * exist.
             * @param base_dn LDAP base domain name
             * @param bind_dn LDAP bind domain name
             * @param capath Path to the CA certificate store
             * @param case_sensitive username is case-sensitive
             * @param cert Path to the client certificate
             * @param certkey Path to the client certificate key
             * @param check_connection Check bind connection to the server.
             * @param client_id OpenID Client ID
             * @param client_key OpenID Client Key
             * @param comment Description.
             * @param default_ Use this as default realm
             * @param domain AD domain name
             * @param filter LDAP filter for user sync.
             * @param group_classes The objectclasses for groups.
             * @param group_dn LDAP base domain name for group sync. If not set,
             * the base_dn will be used.
             * @param group_filter LDAP filter for group sync.
             * @param group_name_attr LDAP attribute representing a groups name.
             * If not set or found, the first value of the DN will be used as
             * name.
             * @param issuer_url OpenID Issuer Url
             * @param mode LDAP protocol mode. Enum: ldap,ldaps,ldap+starttls
             * @param password LDAP bind password. Will be stored in
             * '/etc/pve/priv/realm/&amp;lt;REALM&amp;gt;.pw'.
             * @param port Server port.
             * @param prompt Specifies whether the Authorization Server prompts
             * the End-User for reauthentication and consent.
             * @param scopes Specifies the scopes (user details) that should be
             * authorized and returned, for example 'email' or 'profile'.
             * @param secure Use secure LDAPS protocol. DEPRECATED: use 'mode'
             * instead.
             * @param server1 Server IP address (or DNS name)
             * @param server2 Fallback Server IP address (or DNS name)
             * @param sslversion LDAPS TLS/SSL version. It's not recommended to
             * use version older than 1.2! Enum: tlsv1,tlsv1_1,tlsv1_2,tlsv1_3
             * @param sync_defaults_options The default options for behavior of
             * synchronizations.
             * @param sync_attributes Comma separated list of key=value pairs
             * for specifying which LDAP attributes map to which PVE user field.
             * For example, to map the LDAP attribute 'mail' to PVEs 'email',
             * write 'email=mail'. By default, each PVE user field is
             * represented by an LDAP attribute of the same name.
             * @param tfa Use Two-factor authentication.
             * @param user_attr LDAP user attribute name
             * @param user_classes The objectclasses for users.
             * @param username_claim OpenID claim used to generate the unique
             * username.
             * @param verify Verify the server's SSL certificate
             * @return Result
             * @throws JSONException
             */

            public Result create(String realm, String type, String acr_values, Boolean autocreate, String base_dn, String bind_dn, String capath, Boolean case_sensitive, String cert, String certkey, Boolean check_connection, String client_id, String client_key, String comment, Boolean default_, String domain, String filter, String group_classes, String group_dn, String group_filter, String group_name_attr, String issuer_url, String mode, String password, Integer port, String prompt, String scopes, Boolean secure, String server1, String server2, String sslversion, String sync_defaults_options, String sync_attributes, String tfa, String user_attr, String user_classes, String username_claim, Boolean verify) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("realm", realm);
                parameters.put("type", type);
                parameters.put("acr-values", acr_values);
                parameters.put("autocreate", autocreate);
                parameters.put("base_dn", base_dn);
                parameters.put("bind_dn", bind_dn);
                parameters.put("capath", capath);
                parameters.put("case-sensitive", case_sensitive);
                parameters.put("cert", cert);
                parameters.put("certkey", certkey);
                parameters.put("check-connection", check_connection);
                parameters.put("client-id", client_id);
                parameters.put("client-key", client_key);
                parameters.put("comment", comment);
                parameters.put("default", default_);
                parameters.put("domain", domain);
                parameters.put("filter", filter);
                parameters.put("group_classes", group_classes);
                parameters.put("group_dn", group_dn);
                parameters.put("group_filter", group_filter);
                parameters.put("group_name_attr", group_name_attr);
                parameters.put("issuer-url", issuer_url);
                parameters.put("mode", mode);
                parameters.put("password", password);
                parameters.put("port", port);
                parameters.put("prompt", prompt);
                parameters.put("scopes", scopes);
                parameters.put("secure", secure);
                parameters.put("server1", server1);
                parameters.put("server2", server2);
                parameters.put("sslversion", sslversion);
                parameters.put("sync-defaults-options", sync_defaults_options);
                parameters.put("sync_attributes", sync_attributes);
                parameters.put("tfa", tfa);
                parameters.put("user_attr", user_attr);
                parameters.put("user_classes", user_classes);
                parameters.put("username-claim", username_claim);
                parameters.put("verify", verify);
                return client.create("/access/domains", parameters);
            }

            /**
             * Add an authentication server.
             *
             * @param realm Authentication domain ID
             * @param type Realm type. Enum: ad,ldap,openid,pam,pve
             * @return Result
             * @throws JSONException
             */

            public Result create(String realm, String type) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("realm", realm);
                parameters.put("type", type);
                return client.create("/access/domains", parameters);
            }

        }

        public class PVEOpenid {

            private final PveClient client;

            protected PVEOpenid(PveClient client) {
                this.client = client;

            }

            private PVEAuthUrl authUrl;

            public PVEAuthUrl getAuthUrl() {
                return authUrl == null ? (authUrl = new PVEAuthUrl(client)) : authUrl;
            }
            private PVELogin login;

            public PVELogin getLogin() {
                return login == null ? (login = new PVELogin(client)) : login;
            }

            public class PVEAuthUrl {

                private final PveClient client;

                protected PVEAuthUrl(PveClient client) {
                    this.client = client;

                }

                /**
                 * Get the OpenId Authorization Url for the specified realm.
                 *
                 * @param realm Authentication domain ID
                 * @param redirect_url Redirection Url. The client should set
                 * this to the used server url (location.origin).
                 * @return Result
                 * @throws JSONException
                 */
                public Result authUrl(String realm, String redirect_url) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("realm", realm);
                    parameters.put("redirect-url", redirect_url);
                    return client.create("/access/openid/auth-url", parameters);
                }

            }

            public class PVELogin {

                private final PveClient client;

                protected PVELogin(PveClient client) {
                    this.client = client;

                }

                /**
                 * Verify OpenID authorization code and create a ticket.
                 *
                 * @param code OpenId authorization code.
                 * @param redirect_url Redirection Url. The client should set
                 * this to the used server url (location.origin).
                 * @param state OpenId state.
                 * @return Result
                 * @throws JSONException
                 */
                public Result login(String code, String redirect_url, String state) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("code", code);
                    parameters.put("redirect-url", redirect_url);
                    parameters.put("state", state);
                    return client.create("/access/openid/login", parameters);
                }

            }

            /**
             * Directory index.
             *
             * @return Result
             * @throws JSONException
             */
            public Result index() throws JSONException {
                return client.get("/access/openid", null);
            }

        }

        public class PVETfa {

            private final PveClient client;

            protected PVETfa(PveClient client) {
                this.client = client;

            }

            public PVEUseridItem get(Object userid) {
                return new PVEUseridItem(client, userid);
            }

            public class PVEUseridItem {

                private final PveClient client;
                private final Object userid;

                protected PVEUseridItem(PveClient client, Object userid) {
                    this.client = client;
                    this.userid = userid;
                }

                public PVEIdItem get(Object id) {
                    return new PVEIdItem(client, this.userid, id);
                }

                public class PVEIdItem {

                    private final PveClient client;
                    private final Object userid;
                    private final Object id;

                    protected PVEIdItem(PveClient client, Object userid, Object id) {
                        this.client = client;
                        this.userid = userid;
                        this.id = id;
                    }

                    /**
                     * Delete a TFA entry by ID.
                     *
                     * @param password The current password.
                     * @return Result
                     * @throws JSONException
                     */
                    public Result deleteTfa(String password) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("password", password);
                        return client.delete("/access/tfa/" + this.userid + "/" + this.id + "", parameters);
                    }

                    /**
                     * Delete a TFA entry by ID.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result deleteTfa() throws JSONException {
                        return client.delete("/access/tfa/" + this.userid + "/" + this.id + "", null);
                    }

                    /**
                     * Fetch a requested TFA entry if present.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result getTfaEntry() throws JSONException {
                        return client.get("/access/tfa/" + this.userid + "/" + this.id + "", null);
                    }

                    /**
                     * Add a TFA entry for a user.
                     *
                     * @param description A description to distinguish multiple
                     * entries from one another
                     * @param enable Whether the entry should be enabled for
                     * login.
                     * @param password The current password.
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateTfaEntry(String description, Boolean enable, String password) throws JSONException {
                        Map<String, Object> parameters = new HashMap<>();
                        parameters.put("description", description);
                        parameters.put("enable", enable);
                        parameters.put("password", password);
                        return client.set("/access/tfa/" + this.userid + "/" + this.id + "", parameters);
                    }

                    /**
                     * Add a TFA entry for a user.
                     *
                     * @return Result
                     * @throws JSONException
                     */

                    public Result updateTfaEntry() throws JSONException {
                        return client.set("/access/tfa/" + this.userid + "/" + this.id + "", null);
                    }

                }

                /**
                 * List TFA configurations of users.
                 *
                 * @return Result
                 * @throws JSONException
                 */
                public Result listUserTfa() throws JSONException {
                    return client.get("/access/tfa/" + this.userid + "", null);
                }

                /**
                 * Add a TFA entry for a user.
                 *
                 * @param type TFA Entry Type. Enum:
                 * totp,u2f,webauthn,recovery,yubico
                 * @param challenge When responding to a u2f challenge: the
                 * original challenge string
                 * @param description A description to distinguish multiple
                 * entries from one another
                 * @param password The current password.
                 * @param totp A totp URI.
                 * @param value The current value for the provided totp URI, or
                 * a Webauthn/U2F challenge response
                 * @return Result
                 * @throws JSONException
                 */

                public Result addTfaEntry(String type, String challenge, String description, String password, String totp, String value) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("type", type);
                    parameters.put("challenge", challenge);
                    parameters.put("description", description);
                    parameters.put("password", password);
                    parameters.put("totp", totp);
                    parameters.put("value", value);
                    return client.create("/access/tfa/" + this.userid + "", parameters);
                }

                /**
                 * Add a TFA entry for a user.
                 *
                 * @param type TFA Entry Type. Enum:
                 * totp,u2f,webauthn,recovery,yubico
                 * @return Result
                 * @throws JSONException
                 */

                public Result addTfaEntry(String type) throws JSONException {
                    Map<String, Object> parameters = new HashMap<>();
                    parameters.put("type", type);
                    return client.create("/access/tfa/" + this.userid + "", parameters);
                }

            }

            /**
             * List TFA configurations of users.
             *
             * @return Result
             * @throws JSONException
             */
            public Result listTfa() throws JSONException {
                return client.get("/access/tfa", null);
            }

        }

        public class PVETicket {

            private final PveClient client;

            protected PVETicket(PveClient client) {
                this.client = client;

            }

            /**
             * Dummy. Useful for formatters which want to provide a login page.
             *
             * @return Result
             * @throws JSONException
             */
            public Result getTicket() throws JSONException {
                return client.get("/access/ticket", null);
            }

            /**
             * Create or verify authentication ticket.
             *
             * @param password The secret password. This can also be a valid
             * ticket.
             * @param username User name
             * @param new_format This parameter is now ignored and assumed to be
             * 1.
             * @param otp One-time password for Two-factor authentication.
             * @param path Verify ticket, and check if user have access 'privs'
             * on 'path'
             * @param privs Verify ticket, and check if user have access 'privs'
             * on 'path'
             * @param realm You can optionally pass the realm using this
             * parameter. Normally the realm is simply added to the username
             * &amp;lt;username&amp;gt;@&amp;lt;relam&amp;gt;.
             * @param tfa_challenge The signed TFA challenge string the user
             * wants to respond to.
             * @return Result
             * @throws JSONException
             */

            public Result createTicket(String password, String username, Boolean new_format, String otp, String path, String privs, String realm, String tfa_challenge) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("password", password);
                parameters.put("username", username);
                parameters.put("new-format", new_format);
                parameters.put("otp", otp);
                parameters.put("path", path);
                parameters.put("privs", privs);
                parameters.put("realm", realm);
                parameters.put("tfa-challenge", tfa_challenge);
                return client.create("/access/ticket", parameters);
            }

            /**
             * Create or verify authentication ticket.
             *
             * @param password The secret password. This can also be a valid
             * ticket.
             * @param username User name
             * @return Result
             * @throws JSONException
             */

            public Result createTicket(String password, String username) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("password", password);
                parameters.put("username", username);
                return client.create("/access/ticket", parameters);
            }

        }

        public class PVEPassword {

            private final PveClient client;

            protected PVEPassword(PveClient client) {
                this.client = client;

            }

            /**
             * Change user password.
             *
             * @param password The new password.
             * @param userid Full User ID, in the `name@realm` format.
             * @return Result
             * @throws JSONException
             */
            public Result changePassword(String password, String userid) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("password", password);
                parameters.put("userid", userid);
                return client.set("/access/password", parameters);
            }

        }

        public class PVEPermissions {

            private final PveClient client;

            protected PVEPermissions(PveClient client) {
                this.client = client;

            }

            /**
             * Retrieve effective permissions of given user/token.
             *
             * @param path Only dump this specific path, not the whole tree.
             * @param userid User ID or full API token ID
             * @return Result
             * @throws JSONException
             */
            public Result permissions(String path, String userid) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("path", path);
                parameters.put("userid", userid);
                return client.get("/access/permissions", parameters);
            }

            /**
             * Retrieve effective permissions of given user/token.
             *
             * @return Result
             * @throws JSONException
             */

            public Result permissions() throws JSONException {
                return client.get("/access/permissions", null);
            }

        }

        /**
         * Directory index.
         *
         * @return Result
         * @throws JSONException
         */
        public Result index() throws JSONException {
            return client.get("/access", null);
        }

    }

    public class PVEPools {

        private final PveClient client;

        protected PVEPools(PveClient client) {
            this.client = client;

        }

        public PVEPoolidItem get(Object poolid) {
            return new PVEPoolidItem(client, poolid);
        }

        public class PVEPoolidItem {

            private final PveClient client;
            private final Object poolid;

            protected PVEPoolidItem(PveClient client, Object poolid) {
                this.client = client;
                this.poolid = poolid;
            }

            /**
             * Delete pool (deprecated, no support for nested pools, use 'DELETE
             * /pools/?poolid={poolid}').
             *
             * @return Result
             * @throws JSONException
             */
            public Result deletePoolDeprecated() throws JSONException {
                return client.delete("/pools/" + this.poolid + "", null);
            }

            /**
             * Get pool configuration (deprecated, no support for nested pools,
             * use 'GET /pools/?poolid={poolid}').
             *
             * @param type Enum: qemu,lxc,storage
             * @return Result
             * @throws JSONException
             */

            public Result readPool(String type) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("type", type);
                return client.get("/pools/" + this.poolid + "", parameters);
            }

            /**
             * Get pool configuration (deprecated, no support for nested pools,
             * use 'GET /pools/?poolid={poolid}').
             *
             * @return Result
             * @throws JSONException
             */

            public Result readPool() throws JSONException {
                return client.get("/pools/" + this.poolid + "", null);
            }

            /**
             * Update pool data (deprecated, no support for nested pools - use
             * 'PUT /pools/?poolid={poolid}' instead).
             *
             * @param allow_move Allow adding a guest even if already in another
             * pool. The guest will be removed from its current pool and added
             * to this one.
             * @param comment
             * @param delete Remove the passed VMIDs and/or storage IDs instead
             * of adding them.
             * @param storage List of storage IDs to add or remove from this
             * pool.
             * @param vms List of guest VMIDs to add or remove from this pool.
             * @return Result
             * @throws JSONException
             */

            public Result updatePoolDeprecated(Boolean allow_move, String comment, Boolean delete, String storage, String vms) throws JSONException {
                Map<String, Object> parameters = new HashMap<>();
                parameters.put("allow-move", allow_move);
                parameters.put("comment", comment);
                parameters.put("delete", delete);
                parameters.put("storage", storage);
                parameters.put("vms", vms);
                return client.set("/pools/" + this.poolid + "", parameters);
            }

            /**
             * Update pool data (deprecated, no support for nested pools - use
             * 'PUT /pools/?poolid={poolid}' instead).
             *
             * @return Result
             * @throws JSONException
             */

            public Result updatePoolDeprecated() throws JSONException {
                return client.set("/pools/" + this.poolid + "", null);
            }

        }

        /**
         * Delete pool.
         *
         * @param poolid
         * @return Result
         * @throws JSONException
         */
        public Result deletePool(String poolid) throws JSONException {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("poolid", poolid);
            return client.delete("/pools", parameters);
        }

        /**
         * List pools or get pool configuration.
         *
         * @param poolid
         * @param type Enum: qemu,lxc,storage
         * @return Result
         * @throws JSONException
         */

        public Result index(String poolid, String type) throws JSONException {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("poolid", poolid);
            parameters.put("type", type);
            return client.get("/pools", parameters);
        }

        /**
         * List pools or get pool configuration.
         *
         * @return Result
         * @throws JSONException
         */

        public Result index() throws JSONException {
            return client.get("/pools", null);
        }

        /**
         * Create new pool.
         *
         * @param poolid
         * @param comment
         * @return Result
         * @throws JSONException
         */

        public Result createPool(String poolid, String comment) throws JSONException {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("poolid", poolid);
            parameters.put("comment", comment);
            return client.create("/pools", parameters);
        }

        /**
         * Create new pool.
         *
         * @param poolid
         * @return Result
         * @throws JSONException
         */

        public Result createPool(String poolid) throws JSONException {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("poolid", poolid);
            return client.create("/pools", parameters);
        }

        /**
         * Update pool.
         *
         * @param poolid
         * @param allow_move Allow adding a guest even if already in another
         * pool. The guest will be removed from its current pool and added to
         * this one.
         * @param comment
         * @param delete Remove the passed VMIDs and/or storage IDs instead of
         * adding them.
         * @param storage List of storage IDs to add or remove from this pool.
         * @param vms List of guest VMIDs to add or remove from this pool.
         * @return Result
         * @throws JSONException
         */

        public Result updatePool(String poolid, Boolean allow_move, String comment, Boolean delete, String storage, String vms) throws JSONException {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("poolid", poolid);
            parameters.put("allow-move", allow_move);
            parameters.put("comment", comment);
            parameters.put("delete", delete);
            parameters.put("storage", storage);
            parameters.put("vms", vms);
            return client.set("/pools", parameters);
        }

        /**
         * Update pool.
         *
         * @param poolid
         * @return Result
         * @throws JSONException
         */

        public Result updatePool(String poolid) throws JSONException {
            Map<String, Object> parameters = new HashMap<>();
            parameters.put("poolid", poolid);
            return client.set("/pools", parameters);
        }

    }

    public class PVEVersion {

        private final PveClient client;

        protected PVEVersion(PveClient client) {
            this.client = client;

        }

        /**
         * API version details, including some parts of the global datacenter
         * config.
         *
         * @return Result
         * @throws JSONException
         */
        public Result version() throws JSONException {
            return client.get("/version", null);
        }

    }

}
